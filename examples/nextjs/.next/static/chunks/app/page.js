/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnicolasmontone%2Fpluggy%2Ftest%2Fuse-pluggy-connect%2Fexample-nextjs%2Fcomponents%2Fopen-pluggy-button.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnicolasmontone%2Fpluggy%2Ftest%2Fuse-pluggy-connect%2Fexample-nextjs%2Fcomponents%2Fopen-pluggy-button.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/open-pluggy-button.tsx */ \"(app-pages-browser)/./components/open-pluggy-button.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZuaWNvbGFzbW9udG9uZSUyRnBsdWdneSUyRnRlc3QlMkZ1c2UtcGx1Z2d5LWNvbm5lY3QlMkZleGFtcGxlLW5leHRqcyUyRmNvbXBvbmVudHMlMkZvcGVuLXBsdWdneS1idXR0b24udHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLGdNQUF1SyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzBhMGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiL1VzZXJzL25pY29sYXNtb250b25lL3BsdWdneS90ZXN0L3VzZS1wbHVnZ3ktY29ubmVjdC9leGFtcGxlLW5leHRqcy9jb21wb25lbnRzL29wZW4tcGx1Z2d5LWJ1dHRvbi50c3hcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnicolasmontone%2Fpluggy%2Ftest%2Fuse-pluggy-connect%2Fexample-nextjs%2Fcomponents%2Fopen-pluggy-button.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMsdUJBQXVCLHdCQUF3Qix3QkFBd0IsMEZBQTBGLHNCQUFzQixtQkFBbUIscUJBQXFCLHFCQUFxQix3QkFBd0IsdUJBQXVCLDBCQUEwQix3QkFBd0IsWUFBWSxtSkFBbUosbUVBQW1FLDhCQUE4Qix5SEFBeUgsOEJBQThCLHdCQUF3Qiw2RkFBNkYsNkJBQTZCLG1CQUFtQiwwQkFBMEIsb0JBQW9CLGNBQWMscUdBQXFHLHdEQUF3RCxtSkFBbUosNEJBQTRCLG9CQUFvQiw2REFBNkQseUNBQXlDLHVCQUF1Qix3QkFBd0IsOERBQThELGFBQWEsd0VBQXdFLHNCQUFzQixjQUFjLFNBQVMsdUJBQXVCLGtCQUFrQiw2RUFBNkUsdUJBQXVCLDZCQUE2QixxQkFBcUIsd0JBQXdCLGNBQWMsd0NBQXdDLCtCQUErQix1QkFBdUIsbUNBQW1DLHVCQUF1Qix5QkFBeUIsZ0NBQWdDLFNBQVMsMEJBQTBCLDRDQUE0Qyx3QkFBd0Isc0JBQXNCLG1CQUFtQixVQUFVLGVBQWUsU0FBUywwQkFBMEIsdUNBQXVDLHNCQUFzQixZQUFZLElBQUksTUFBTSxjQUFjLFNBQVMsZ0NBQWdDLHdCQUF3Qiw2REFBNkQsMEJBQTBCLDZEQUE2RCxNQUFNLGlDQUFpQyxvQkFBb0IsdUJBQXVCLHNCQUFzQixLQUFLLHdCQUF3QiwwQ0FBMEMsU0FBUyx1QkFBdUIsdUJBQXVCLDBCQUEwQixzQkFBc0IsaUJBQWlCLFNBQVMsZ0JBQWdCLFNBQVMseUJBQXlCLHNEQUFzRCx1QkFBdUIsd0JBQXdCLDZDQUE2Qyw4QkFBOEIsb0JBQW9CLFNBQVMsMkdBQTJHLFdBQVcsdUJBQXVCLFVBQVUsSUFBSSx3QkFBd0IscUNBQXFDLDBEQUEwRCxxQ0FBcUMsbUVBQW1FLG1FQUFtRSw2Q0FBNkMsNkZBQTZGLGtCQUFrQixlQUFlLGVBQWUsNEJBQTRCLElBQUksS0FBSyxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLGdCQUFnQixVQUFVLHlDQUF5QyxnQ0FBZ0Msb0pBQW9KLHVCQUF1QixtQ0FBbUMsc0JBQXNCLG1FQUFtRSxpQkFBaUIsdUJBQXVCLE1BQU0sa0JBQWtCLElBQUksUUFBUSxXQUFXLEtBQUssZ0JBQWdCLDRCQUE0QixRQUFRLFFBQVEsV0FBVyxLQUFLLFdBQVcsNkJBQTZCLGlCQUFpQix3QkFBd0IsbUVBQW1FLFlBQVksWUFBWSxVQUFVLHlCQUF5Qix1QkFBdUIsZ0JBQWdCLHFEQUFxRCxvQkFBb0Isd0JBQXdCLDRIQUE0SCxlQUFlLDhDQUE4QyxzQkFBc0IsWUFBWSxNQUFNLEVBQUUsVUFBVSwrQ0FBK0Msb0RBQW9ELCtEQUErRCx1QkFBdUIsNENBQTRDLGNBQWMsa0NBQWtDLHVCQUF1QixTQUFTLDZCQUE2Qiw2QkFBNkIsWUFBWSx1QkFBdUIsSUFBSSxrQkFBa0IsU0FBUyxpQ0FBaUMsY0FBYyxTQUFTLFNBQVMsT0FBTyxPQUFPLFNBQVMsU0FBUyxlQUFlLFlBQVksVUFBVSxvQ0FBb0Msa0RBQWtELHdDQUF3Qyx1REFBdUQsMENBQTBDLGtGQUFrRix5REFBeUQsdUJBQXVCLFNBQVMsZ0NBQWdDLHFCQUFxQixXQUFXLFVBQVUsT0FBTywwQ0FBMEMsa0JBQWtCLFlBQVksa0VBQWtFLFlBQVksSUFBSSxNQUFNLGlCQUFpQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixtQkFBbUIsbUJBQW1CLGFBQWEsOENBQThDLGtCQUFrQixrQkFBa0IsbURBQW1ELDJDQUEyQywwREFBMEQsMkNBQTJDLHdFQUF3RSx3QkFBd0IsbUNBQW1DLDRDQUE0QyxTQUFTLDBCQUEwQix1Q0FBdUMsRUFBRSxrQkFBa0IsNEJBQTRCLHdCQUF3QixNQUFNLDZDQUE2QyxxREFBcUQsNkJBQTZCLHVDQUF1Qyx3QkFBd0Isa0hBQWtILGtCQUFrQixJQUFJLGtCQUFrQixlQUFlLGtCQUFrQixJQUFJLGtCQUFrQixjQUFjLHdDQUF3QywyQ0FBMkMsZUFBZSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsT0FBTyxPQUFPLE9BQU8sT0FBTyxxQkFBcUIsVUFBVSxVQUFVLG9CQUFvQixzQkFBc0IsbUJBQW1CLFlBQVksSUFBSSxLQUFLLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxnQkFBZ0IsZ0JBQWdCLFVBQVUseUNBQXlDLHlCQUF5Qix3QkFBd0IsSUFBSSxJQUFJLHNCQUFzQixhQUFhLHVCQUF1QixjQUFjLEtBQUssbUJBQW1CLGlCQUFpQixvQkFBb0IsZ0JBQWdCLGNBQWMsa0JBQWtCLGFBQWEsU0FBUyxjQUFjLHdCQUF3QixtQkFBbUIsdUJBQXVCLGlCQUFpQixTQUFTLCtCQUErQiw2QkFBNkIsUUFBUSxxREFBcUQsTUFBTSxnREFBZ0QsS0FBSyxxREFBcUQsaUNBQWlDLDREQUE0RCxpQ0FBaUMsUUFBUSxlQUFlLGVBQWUsa0JBQWtCLDBCQUEwQiwyREFBMkQsMkJBQTJCLFNBQVMsSUFBSSxLQUFLLEtBQUssTUFBTSxtQkFBbUIsVUFBVSxZQUFZLEtBQUssNEJBQTRCLE1BQU0sTUFBTSxTQUFTLFFBQVEsSUFBSSxLQUFLLHFDQUFxQyxjQUFjLHdCQUF3QixLQUFLLGlCQUFpQixPQUFPLEtBQUssZUFBZSxRQUFRLEtBQUssS0FBSyxXQUFXLFlBQVksSUFBSSxLQUFLLDRCQUE0QixRQUFRLE9BQU8sZUFBZSxTQUFTLG1EQUFtRCxpQ0FBaUMsaURBQWlELDhDQUE4Qyx5REFBeUQsK0NBQStDLDJCQUEyQixlQUFlLGlCQUFpQixPQUFPLElBQUksS0FBSyxZQUFZLFFBQVEsS0FBSyxlQUFlLFVBQVUsTUFBTSxZQUFZLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLFNBQVMsU0FBUyw0QkFBNEIsbURBQW1ELDZCQUE2Qix5Q0FBeUMsOEJBQThCLDJCQUEyQiw4QkFBOEIsMENBQTBDLDRCQUE0QixzREFBc0QsK0NBQStDLGtCQUFrQixTQUFTLGNBQWMsSUFBSSw0Q0FBNEMsSUFBSSxjQUFjLElBQUkscUJBQXFCLFFBQVEsZ0JBQWdCLFFBQVEsMEJBQTBCLEtBQUssSUFBSSxhQUFhLEtBQUssMkZBQTJGLG9CQUFvQiwwQkFBMEIsMENBQTBDLCtEQUErRCxlQUFlLFlBQVksTUFBTSxFQUFFLFVBQVUsc0NBQXNDLG9EQUFvRCwwQ0FBMEMseURBQXlELDRDQUE0QyxpRkFBaUYseURBQXlELHVCQUF1QixVQUFVLDBDQUEwQyxPQUFPLG1FQUFtRSw0QkFBNEIsd0JBQXdCLDBCQUEwQixLQUFLLHNDQUFzQywwQkFBMEIsdUJBQXVCLFNBQVMsUUFBUSxXQUFXLFdBQVcsV0FBVyxnQ0FBZ0MsV0FBVyxZQUFZLFVBQVUsaUJBQWlCLElBQUksTUFBTSxnQkFBZ0Isa0JBQWtCLGlCQUFpQixVQUFVLEtBQUssTUFBTSxnQkFBZ0IsU0FBUyxpQ0FBaUMsNEJBQTRCLCtCQUErQixLQUFLLE1BQU0sZ0JBQWdCLFNBQVMsU0FBUyxnREFBZ0QsdUNBQXVDLHVCQUF1QixPQUFPLGFBQWEsUUFBUSxJQUFJLGlCQUFpQixTQUFTLDBCQUEwQixlQUFlLFVBQVUsS0FBSyxnQ0FBZ0MsV0FBVyxrQ0FBa0MsZUFBZSxTQUFTLDJDQUEyQyxTQUFTLFFBQVEsV0FBVyxxREFBcUQsU0FBUywyQkFBMkIsU0FBUyx1QkFBdUIsWUFBWSxJQUFJLEtBQUssaUNBQWlDLFNBQVMsNEJBQTRCLFNBQVMsdUJBQXVCLFlBQVksSUFBSSxLQUFLLDZCQUE2QixTQUFTLHlCQUF5QixlQUFlLGVBQWUsb0JBQW9CLFNBQVMsWUFBWSxJQUFJLEtBQUssV0FBVyxTQUFTLDZCQUE2QixtQkFBbUIsU0FBUyxZQUFZLFdBQVcsTUFBTSx3Q0FBd0MsU0FBUywyQ0FBMkMsa0JBQWtCLE1BQU0sc0JBQXNCLFFBQVEsS0FBSyxXQUFXLGFBQWEsSUFBSSxRQUFRLEtBQUssV0FBVyxhQUFhLElBQUksV0FBVyx5QkFBeUIsMENBQTBDLFVBQVUsNEJBQTRCLDJEQUEyRCx1RUFBdUUsdURBQXVELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsVUFBVSx1REFBdUQsUUFBUSxRQUFRLE9BQU8sNkJBQTZCLGtCQUFrQixRQUFRLHFCQUFxQixpQkFBaUIsVUFBVSxtREFBbUQsUUFBUSxtQ0FBbUMsZ0JBQWdCLHlEQUF5RCxRQUFRLG1DQUFtQyw2QkFBNkIseURBQXlELFFBQVEsbUNBQW1DLDZCQUE2Qix5REFBeUQsUUFBUSxtQ0FBbUMsK0RBQStELHlEQUF5RCxRQUFRLG1DQUFtQyxnRUFBZ0UscURBQXFELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsT0FBTywyQkFBMkIsVUFBVSxxREFBcUQsUUFBUSxRQUFRLG1DQUFtQyxRQUFRLFFBQVEsa0JBQWtCLHFCQUFxQixpQkFBaUIsT0FBTywyQkFBMkIsVUFBVSxpREFBaUQsUUFBUSxtQ0FBbUMsaUNBQWlDLDBCQUEwQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMseURBQXlELHVEQUF1RCxRQUFRLG1DQUFtQyx5REFBeUQsdURBQXVELFFBQVEsbUNBQW1DLGlDQUFpQyx1REFBdUQsUUFBUSxtQ0FBbUMsa0NBQWtDLHlEQUF5RCxRQUFRLG1DQUFtQyxpQ0FBaUMseURBQXlELFFBQVEsbUNBQW1DLGtDQUFrQywrQkFBK0IsMEZBQTBGLHNFQUFzRSwyREFBMkQsMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixRQUFRLFFBQVEsY0FBYyx1QkFBdUIsa0JBQWtCLFlBQVksMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixVQUFVLFFBQVEsZ0JBQWdCLHdCQUF3QixrQkFBa0IsWUFBWSx1REFBdUQsS0FBSyxRQUFRLGlDQUFpQyxjQUFjLFlBQVksNkRBQTZELEtBQUssUUFBUSxtQ0FBbUMsY0FBYyxnQkFBZ0IsWUFBWSw2REFBNkQsS0FBSyxRQUFRLG1DQUFtQyxjQUFjLGdCQUFnQixZQUFZLDZEQUE2RCxLQUFLLFFBQVEsd0NBQXdDLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGNBQWMsWUFBWSw2REFBNkQsS0FBSyxRQUFRLHdDQUF3QyxlQUFlLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsUUFBUSxRQUFRLFFBQVEsY0FBYyx1QkFBdUIsZ0NBQWdDLElBQUkseUJBQXlCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsVUFBVSxRQUFRLFFBQVEsZ0JBQWdCLHdCQUF3QixnQ0FBZ0MsSUFBSSx5QkFBeUIsWUFBWSxxREFBcUQsS0FBSyxRQUFRLG9DQUFvQyxpQkFBaUIsY0FBYyxZQUFZLDJEQUEyRCxLQUFLLFFBQVEsd0NBQXdDLGNBQWMsZ0JBQWdCLFlBQVksMkRBQTJELEtBQUssUUFBUSx3Q0FBd0MsY0FBYyxnQkFBZ0IsWUFBWSwyREFBMkQsS0FBSyxRQUFRLGtEQUFrRCxjQUFjLGdCQUFnQixpQkFBaUIsaUJBQWlCLFlBQVksMkRBQTJELEtBQUssUUFBUSxrREFBa0Qsd0JBQXdCLGVBQWUsaUJBQWlCLGdCQUFnQixnQkFBZ0IsWUFBWSxtQ0FBbUMsMkRBQTJELGtEQUFrRCwrQkFBK0IsS0FBSyxRQUFRLE9BQU8saUVBQWlFLHNCQUFzQixXQUFXLDJEQUEyRCxvQ0FBb0MsMkRBQTJELHFDQUFxQyxnQ0FBZ0MsS0FBSyxRQUFRLE9BQU8sbUVBQW1FLHNCQUFzQixXQUFXLDZEQUE2RCxxQ0FBcUMsNkRBQTZELHNDQUFzQyw2Q0FBNkMsMEVBQTBFLFVBQVUsMkJBQTJCLDBCQUEwQixVQUFVLGdCQUFnQixrQkFBa0IsMENBQTBDLFFBQVEsa0RBQWtELGtFQUFrRSx1REFBdUQsK0JBQStCLG1CQUFtQixlQUFlLFVBQVUsa0VBQWtFLHVCQUF1Qiw0QkFBNEIsY0FBYyxLQUFLLEtBQUssa0JBQWtCLEtBQUssc0RBQXNELFVBQVUsNkNBQTZDLHdCQUF3Qix3QkFBd0IsSUFBSSxJQUFJLGNBQWMsNkJBQTZCLElBQUksY0FBYyx1Q0FBdUMsaURBQWlELCtDQUErQyw0Q0FBNEMsaUJBQWlCLHNCQUFzQixvQ0FBb0MsTUFBTSw2QkFBNkIsUUFBUSw4QkFBOEIsWUFBWSxzQ0FBc0MsMkNBQTJDLFNBQVMsWUFBWSxRQUFRLGtDQUFrQyxVQUFVLE1BQU0sd0JBQXdCLFFBQVEsSUFBSSxLQUFLLFdBQVcsS0FBSyw0Q0FBNEMsZUFBZSxVQUFVLHlFQUF5RSxRQUFRLE1BQU0sS0FBSyxrQkFBa0IsYUFBYSwwQkFBMEIsd0JBQXdCLGtCQUFrQix5QkFBeUIsdUJBQXVCLHNCQUFzQixRQUFRLFNBQVMsMEJBQTBCLGNBQWMsTUFBTSxlQUFlLFdBQVcsU0FBUyxZQUFZLElBQUksS0FBSyxrQkFBa0IscUJBQXFCLE9BQU8sWUFBWSxpQ0FBaUMsU0FBUyxpQkFBaUIsaUNBQWlDLFNBQVMsSUFBSSxTQUFTLFlBQVksaUNBQWlDLElBQUksU0FBUyw4QkFBOEIsV0FBVyxpQ0FBaUMsT0FBTyxVQUFVLGtCQUFrQixVQUFVLGdCQUFnQixrQkFBa0IsMEJBQTBCLGlCQUFpQixrQkFBa0IsdUNBQXVDLG1CQUFtQixrQkFBa0Isb0RBQW9ELEtBQUssdUNBQXVDLFNBQVMseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssNEJBQTRCLFNBQVMsNkJBQTZCLFVBQVUsU0FBUyxZQUFZLFdBQVcsS0FBSyxrQkFBa0Isa0JBQWtCLE9BQU8sUUFBUSxVQUFVLFVBQVUsU0FBUywwQkFBMEIscUNBQXFDLDZCQUE2QixZQUFZLElBQUksS0FBSyxvQ0FBb0MsWUFBWSxTQUFTLHlCQUF5QiwyR0FBMkcsd0JBQXdCLGFBQWEsaUJBQWlCLHlCQUF5QixxQkFBcUIsWUFBWSxLQUFLLEtBQUssV0FBVyxZQUFZLEtBQUssS0FBSyxrQkFBa0IsU0FBUyxHQUFHO0FBQ3p4dkI7QUFDQSwyQkFBMkIsUUFBUSxjQUFjLGVBQWUsV0FBVyxTQUFTLGNBQWMsYUFBYSxhQUFhLEtBQUssY0FBYyxPQUFPLEtBQUssS0FBSyxJQUFJLDJCQUEyQixjQUFjLE9BQU8sS0FBSyxLQUFLLElBQUksMkJBQTJCLFVBQVUsTUFBTSxlQUFlLCtCQUErQixLQUFLLGtCQUFrQixNQUFNLGtDQUFrQyw4QkFBOEIsVUFBVSxjQUFjLGVBQWUsV0FBVywrQ0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz9kZTk1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/css/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/components/loader/css/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContainerCss: function() { return /* binding */ getContainerCss; },\n/* harmony export */   getLoaderCSS: function() { return /* binding */ getLoaderCSS; }\n/* harmony export */ });\nconst getContainerCss = ({ uid }) => `\n    #${uid} iframe.${uid}_prerender-frame {\n        display: inline-block;\n        position: absolute;\n\n        /* loader frame size hardcoded intentionally*/\n        width: 150px;\n        height: 300px;\n\n        /* center iframe inside parent relative */\n        top: 50%;\n        left: 50%;\n        transform: translateX(-50%) translateY(-50%);\n    }\n\n    #${uid} iframe {\n        opacity: 0;\n        transition: opacity .2s ease-in-out;\n    }\n\n    #${uid} iframe.${uid}_invisible {\n        opacity: 0;\n        z-index: -1;\n    }\n\n    #${uid} iframe.${uid}_visible {\n        opacity: 1;\n    }\n`;\nconst getLoaderCSS = () => `\n    body {\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n        position: fixed;\n        top: 0;\n        left: 0;\n        margin: 0;\n    }\n\n    /* Active Animation */\n    @-webkit-keyframes loader {\n      from {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n      }\n      to {\n        -webkit-transform: rotate(360deg);\n        transform: rotate(360deg);\n      }\n    }\n\n    @keyframes loader {\n      from {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg);\n      }\n      to {\n        -webkit-transform: rotate(360deg);\n        transform: rotate(360deg);\n      }\n    }\n\n\n    .ui.loader.active,\n    .ui.loader.visible {\n      display: block;\n    }\n    .ui.loader {\n      display: none;\n      position: absolute;\n      top: 50%;\n      left: 50%;\n      margin: 0;\n      text-align: center;\n      z-index: 1000;\n      transform: translateX(-50%) translateY(-50%);\n    }\n\n    .ui.loader:before {\n      position: absolute;\n      content: '';\n      top: 0;\n      left: 50%;\n      width: 100%;\n      height: 100%;\n      border-radius: 500rem;\n      border: .2em solid rgba(0,0,0,.1);\n    }\n\n    .ui.loader:before {\n      border: 0;\n    }\n\n    .ui.loader:after {\n      position: absolute;\n      content: '';\n      top: 0;\n      left: 50%;\n      width: 100%;\n      height: 100%;\n      animation: loader .6s linear;\n      animation-iteration-count: infinite;\n      border-radius: 500rem;\n      border-color: #e25468 transparent transparent;\n      border-style: solid;\n      border-width: .2em;\n      box-shadow: 0 0 0 1px transparent;\n    }\n\n\n    .ui.inverted.dimmer .ui.loader,\n    .ui.loader {\n      width: 2.28571429rem;\n      height: 2.28571429rem;\n      font-size: 1em;\n    }\n\n    .ui.inverted.dimmer .ui.big.loader,\n    .ui.big.loader {\n      width: 3.71428571rem;\n      height: 3.71428571rem;\n      font-size: 1.28571429em;\n    }\n\n    .ui.loader:after,\n    .ui.loader:before {\n      width: 2.28571429rem;\n      height: 2.28571429rem;\n      margin: 0 0 0 -1.14285714rem;\n    }\n\n    .ui.big.loader:after,\n    .ui.big.loader:before {\n      width: 3.71428571rem;\n      height: 3.71428571rem;\n      margin: 0 0 0 -1.85714286rem;\n    }\n`;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9sb2FkZXIvY3NzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFtQixFQUFFLEVBQUUsQ0FBQztPQUN0RCxHQUFHLFdBQVcsR0FBRzs7Ozs7Ozs7Ozs7Ozs7T0FjakIsR0FBRzs7Ozs7T0FLSCxHQUFHLFdBQVcsR0FBRzs7Ozs7T0FLakIsR0FBRyxXQUFXLEdBQUc7OztDQUd2QixDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLEdBQUcsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkdqQyxDQUFDIn0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2NvbXBvbmVudHMvbG9hZGVyL2Nzcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLDJCQUEyQixLQUFLO0FBQ3ZDLE9BQU8sS0FBSyxTQUFTLElBQUk7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLEtBQUs7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxLQUFLLFNBQVMsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxLQUFLLFNBQVMsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2NvbXBvbmVudHMvbG9hZGVyL2Nzcy9pbmRleC5qcz9kZTE0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBnZXRDb250YWluZXJDc3MgPSAoeyB1aWQgfSkgPT4gYFxuICAgICMke3VpZH0gaWZyYW1lLiR7dWlkfV9wcmVyZW5kZXItZnJhbWUge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgICAgICAvKiBsb2FkZXIgZnJhbWUgc2l6ZSBoYXJkY29kZWQgaW50ZW50aW9uYWxseSovXG4gICAgICAgIHdpZHRoOiAxNTBweDtcbiAgICAgICAgaGVpZ2h0OiAzMDBweDtcblxuICAgICAgICAvKiBjZW50ZXIgaWZyYW1lIGluc2lkZSBwYXJlbnQgcmVsYXRpdmUgKi9cbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgfVxuXG4gICAgIyR7dWlkfSBpZnJhbWUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IC4ycyBlYXNlLWluLW91dDtcbiAgICB9XG5cbiAgICAjJHt1aWR9IGlmcmFtZS4ke3VpZH1faW52aXNpYmxlIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgei1pbmRleDogLTE7XG4gICAgfVxuXG4gICAgIyR7dWlkfSBpZnJhbWUuJHt1aWR9X3Zpc2libGUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgIH1cbmA7XG5leHBvcnQgY29uc3QgZ2V0TG9hZGVyQ1NTID0gKCkgPT4gYFxuICAgIGJvZHkge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgIH1cblxuICAgIC8qIEFjdGl2ZSBBbmltYXRpb24gKi9cbiAgICBALXdlYmtpdC1rZXlmcmFtZXMgbG9hZGVyIHtcbiAgICAgIGZyb20ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgbG9hZGVyIHtcbiAgICAgIGZyb20ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcbiAgICAgIH1cbiAgICAgIHRvIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLnVpLmxvYWRlci5hY3RpdmUsXG4gICAgLnVpLmxvYWRlci52aXNpYmxlIHtcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIH1cbiAgICAudWkubG9hZGVyIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIHotaW5kZXg6IDEwMDA7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTtcbiAgICB9XG5cbiAgICAudWkubG9hZGVyOmJlZm9yZSB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBjb250ZW50OiAnJztcbiAgICAgIHRvcDogMDtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgYm9yZGVyLXJhZGl1czogNTAwcmVtO1xuICAgICAgYm9yZGVyOiAuMmVtIHNvbGlkIHJnYmEoMCwwLDAsLjEpO1xuICAgIH1cblxuICAgIC51aS5sb2FkZXI6YmVmb3JlIHtcbiAgICAgIGJvcmRlcjogMDtcbiAgICB9XG5cbiAgICAudWkubG9hZGVyOmFmdGVyIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgdG9wOiAwO1xuICAgICAgbGVmdDogNTAlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBhbmltYXRpb246IGxvYWRlciAuNnMgbGluZWFyO1xuICAgICAgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDogaW5maW5pdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MDByZW07XG4gICAgICBib3JkZXItY29sb3I6ICNlMjU0NjggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgYm9yZGVyLXdpZHRoOiAuMmVtO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHRyYW5zcGFyZW50O1xuICAgIH1cblxuXG4gICAgLnVpLmludmVydGVkLmRpbW1lciAudWkubG9hZGVyLFxuICAgIC51aS5sb2FkZXIge1xuICAgICAgd2lkdGg6IDIuMjg1NzE0MjlyZW07XG4gICAgICBoZWlnaHQ6IDIuMjg1NzE0MjlyZW07XG4gICAgICBmb250LXNpemU6IDFlbTtcbiAgICB9XG5cbiAgICAudWkuaW52ZXJ0ZWQuZGltbWVyIC51aS5iaWcubG9hZGVyLFxuICAgIC51aS5iaWcubG9hZGVyIHtcbiAgICAgIHdpZHRoOiAzLjcxNDI4NTcxcmVtO1xuICAgICAgaGVpZ2h0OiAzLjcxNDI4NTcxcmVtO1xuICAgICAgZm9udC1zaXplOiAxLjI4NTcxNDI5ZW07XG4gICAgfVxuXG4gICAgLnVpLmxvYWRlcjphZnRlcixcbiAgICAudWkubG9hZGVyOmJlZm9yZSB7XG4gICAgICB3aWR0aDogMi4yODU3MTQyOXJlbTtcbiAgICAgIGhlaWdodDogMi4yODU3MTQyOXJlbTtcbiAgICAgIG1hcmdpbjogMCAwIDAgLTEuMTQyODU3MTRyZW07XG4gICAgfVxuXG4gICAgLnVpLmJpZy5sb2FkZXI6YWZ0ZXIsXG4gICAgLnVpLmJpZy5sb2FkZXI6YmVmb3JlIHtcbiAgICAgIHdpZHRoOiAzLjcxNDI4NTcxcmVtO1xuICAgICAgaGVpZ2h0OiAzLjcxNDI4NTcxcmVtO1xuICAgICAgbWFyZ2luOiAwIDAgMCAtMS44NTcxNDI4NnJlbTtcbiAgICB9XG5gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjRzl1Wlc1MGN5OXNiMkZrWlhJdlkzTnpMMmx1WkdWNExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEUxQlFVMHNRMEZCUXl4TlFVRk5MR1ZCUVdVc1IwRkJSeXhEUVVGRExFVkJRVVVzUjBGQlJ5eEZRVUZ0UWl4RlFVRkZMRVZCUVVVc1EwRkJRenRQUVVOMFJDeEhRVUZITEZkQlFWY3NSMEZCUnpzN096czdPenM3T3pzN096czdUMEZqYWtJc1IwRkJSenM3T3pzN1QwRkxTQ3hIUVVGSExGZEJRVmNzUjBGQlJ6czdPenM3VDBGTGFrSXNSMEZCUnl4WFFVRlhMRWRCUVVjN096dERRVWQyUWl4RFFVRkRPMEZCUlVZc1RVRkJUU3hEUVVGRExFMUJRVTBzV1VGQldTeEhRVUZITEVkQlFVY3NSVUZCUlN4RFFVRkRPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPME5CTmtkcVF5eERRVUZESW4wPSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/css/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/html/index.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/components/loader/html/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loaderComponentHtml: function() { return /* binding */ loaderComponentHtml; }\n/* harmony export */ });\n/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/css/index.js\");\n\nconst loaderComponentHtml = ({ nonce, text, }) => `\n        <div class='preloader spinner'>\n            <style ${nonce ? `nonce=\"${nonce}\"` : ''}>\n              ${(0,_css__WEBPACK_IMPORTED_MODULE_0__.getLoaderCSS)()}\n            </style>\n\n            <div class='ui big active loader'>\n              ${text\n    ? `<div class='content'>\n                      <div class='ui text loader'>\n                        ${text}\n                      </div>\n                    </div>`\n    : ''}\n            </div>\n        </div>\n`;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9sb2FkZXIvaHRtbC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRXRDLE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLENBQUMsRUFDbEMsS0FBSyxFQUNMLElBQUksR0FJTCxFQUFFLEVBQUUsQ0FBQzs7cUJBRWUsS0FBSyxDQUFDLENBQUMsQ0FBQyxVQUFVLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNwQyxZQUFZLEVBQUU7Ozs7Z0JBS2QsSUFBSTtJQUNGLENBQUMsQ0FBQzs7MEJBRU0sSUFBSTs7MkJBRUg7SUFDVCxDQUFDLENBQUMsRUFDTjs7O0NBR2IsQ0FBQyJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2NvbXBvbmVudHMvbG9hZGVyL2h0bWwvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFDL0IsK0JBQStCLGNBQWM7QUFDcEQ7QUFDQSxxQkFBcUIsa0JBQWtCLE1BQU0sUUFBUTtBQUNyRCxnQkFBZ0Isa0RBQVk7QUFDNUI7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9wbHVnZ3ktY29ubmVjdC1zZGsvZGlzdC9tb2R1bGUvY29tcG9uZW50cy9sb2FkZXIvaHRtbC9pbmRleC5qcz9iZmYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvYWRlckNTUyB9IGZyb20gJy4uL2Nzcyc7XG5leHBvcnQgY29uc3QgbG9hZGVyQ29tcG9uZW50SHRtbCA9ICh7IG5vbmNlLCB0ZXh0LCB9KSA9PiBgXG4gICAgICAgIDxkaXYgY2xhc3M9J3ByZWxvYWRlciBzcGlubmVyJz5cbiAgICAgICAgICAgIDxzdHlsZSAke25vbmNlID8gYG5vbmNlPVwiJHtub25jZX1cImAgOiAnJ30+XG4gICAgICAgICAgICAgICR7Z2V0TG9hZGVyQ1NTKCl9XG4gICAgICAgICAgICA8L3N0eWxlPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSd1aSBiaWcgYWN0aXZlIGxvYWRlcic+XG4gICAgICAgICAgICAgICR7dGV4dFxuICAgID8gYDxkaXYgY2xhc3M9J2NvbnRlbnQnPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J3VpIHRleHQgbG9hZGVyJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dGV4dH1cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+YFxuICAgIDogJyd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjRzl1Wlc1MGN5OXNiMkZrWlhJdmFIUnRiQzlwYm1SbGVDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lRVUZCUVN4UFFVRlBMRVZCUVVVc1dVRkJXU3hGUVVGRkxFMUJRVTBzVVVGQlVTeERRVUZETzBGQlJYUkRMRTFCUVUwc1EwRkJReXhOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMRU5CUVVNc1JVRkRiRU1zUzBGQlN5eEZRVU5NTEVsQlFVa3NSMEZKVEN4RlFVRkZMRVZCUVVVc1EwRkJRenM3Y1VKQlJXVXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhWUVVGVkxFdEJRVXNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZPMmRDUVVOd1F5eFpRVUZaTEVWQlFVVTdPenM3WjBKQlMyUXNTVUZCU1R0SlFVTkdMRU5CUVVNc1EwRkJRenM3TUVKQlJVMHNTVUZCU1RzN01rSkJSVWc3U1VGRFZDeERRVUZETEVOQlFVTXNSVUZEVGpzN08wTkJSMklzUTBGQlF5SjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/html/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/modal/css/index.js":
/*!************************************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/components/modal/css/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCSS: function() { return /* binding */ getCSS; }\n/* harmony export */ });\nconst getCSS = ({ uid, themeColor, height, width, allowFullscreen, }) => `\n/* Modal Content/Box */\n@keyframes ${uid}_fadeIn {\n  0% {\n    opacity: 0;\n  }\n  50% {\n    visibility: hidden;\n    opacity: 0;\n  }\n  100% {\n    visibility: visible;\n    opacity: 1;\n  }\n}\n\n#${uid} {\n  /* prevent container el from taking site space */\n  height: 0;\n\n  /* prevent special container cursors from leaking in*/\n  cursor: default;\n}\n\n.${uid}_has-modal-visible {\n  /* modal is opened/visible, prevent scrolling */\n  overflow: hidden;\n}\n\n.${uid}_close:hover,\n.${uid}_close:focus {\n  color: white;\n  background: #${themeColor};\n  text-decoration: none;\n  cursor: pointer;\n}\n\n.${uid}_modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 5000000000;\n  background: rgba(0, 0, 0, 0.7);\n}\n\n.${uid}_modal-container {\n  /* center the modal content */\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.${uid}_modal {\n  width: ${width};\n  max-width: 500px;\n  height: ${height};\n  max-height: 100%;\n  z-index: 100;\n  background: white;\n  border: none;\n  border-radius: 10px;\n\n  /* modal box-shadow */\n  -webkit-box-shadow: 0 4px 24px rgba(0,0,0,0.5);\n  -moz-box-shadow: 0 4px 24px rgba(0,0,0,0.5);\n  box-shadow: 0 4px 24px rgba(0,0,0,0.5);\n  -webkit-background-clip: padding-box;\n  -moz-background-clip: padding-box;\n  background-clip: padding-box;\n}\n\n/* dark theme */\n.${uid}_modal.dark {\n  background: #121212;\n}\n\n.${uid}_closed {\n  display: none;\n}\n\n.${uid}_modal-content {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n\n  border-radius: 10px;\n}\n\n.${uid}_modal .close-button {\n  position: absolute;\n  z-index: 1;\n  top: 10px;\n  right: 20px;\n  background: black;\n  color: white;\n  padding: 5px 10px;\n  font-size: 1.3rem;\n}\n\n.${uid}_container {\n    height: 100%;\n    width: 100%;\n    position: relative;\n}\n\n.${uid}_container iframe {\n    height: 100%;\n    width: 100%;\n}\n\n${allowFullscreen\n    ? `\n    /** when display is narrower that 500px (mobile device)\n    open modal in full screen */\n    @media screen and (max-width: 500px) {\n      .${uid}_modal {\n        height: 100%;\n        width: 100%;\n        border-radius: 0px;\n      }\n    }`\n    : ''}\n`;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9tb2RhbC9jc3MvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxDQUFDLE1BQU0sTUFBTSxHQUFHLENBQUMsRUFDckIsR0FBRyxFQUNILFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUNMLGVBQWUsR0FPaEIsRUFBRSxFQUFFLENBQUM7O2FBRU8sR0FBRzs7Ozs7Ozs7Ozs7Ozs7R0FjYixHQUFHOzs7Ozs7OztHQVFILEdBQUc7Ozs7O0dBS0gsR0FBRztHQUNILEdBQUc7O2lCQUVXLFVBQVU7Ozs7O0dBS3hCLEdBQUc7Ozs7Ozs7Ozs7R0FVSCxHQUFHOzs7Ozs7O0dBT0gsR0FBRztXQUNLLEtBQUs7O1lBRUosTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQmYsR0FBRzs7OztHQUlILEdBQUc7Ozs7R0FJSCxHQUFHOzs7Ozs7OztHQVFILEdBQUc7Ozs7Ozs7Ozs7O0dBV0gsR0FBRzs7Ozs7O0dBTUgsR0FBRzs7Ozs7RUFNSixlQUFlO0lBQ2IsQ0FBQyxDQUFDOzs7O1NBSUcsR0FBRzs7Ozs7TUFLTjtJQUNGLENBQUMsQ0FBQyxFQUNOO0NBQ0MsQ0FBQyJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2NvbXBvbmVudHMvbW9kYWwvY3NzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxrQkFBa0Isa0RBQWtEO0FBQzNFO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBOztBQUVBLEdBQUcsSUFBSTtBQUNQLEdBQUcsSUFBSTtBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRyxJQUFJO0FBQ1AsV0FBVztBQUNYO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7O0FBRUEsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9wbHVnZ3ktY29ubmVjdC1zZGsvZGlzdC9tb2R1bGUvY29tcG9uZW50cy9tb2RhbC9jc3MvaW5kZXguanM/YTZhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZ2V0Q1NTID0gKHsgdWlkLCB0aGVtZUNvbG9yLCBoZWlnaHQsIHdpZHRoLCBhbGxvd0Z1bGxzY3JlZW4sIH0pID0+IGBcbi8qIE1vZGFsIENvbnRlbnQvQm94ICovXG5Aa2V5ZnJhbWVzICR7dWlkfV9mYWRlSW4ge1xuICAwJSB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxuICA1MCUge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG4gIDEwMCUge1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxufVxuXG4jJHt1aWR9IHtcbiAgLyogcHJldmVudCBjb250YWluZXIgZWwgZnJvbSB0YWtpbmcgc2l0ZSBzcGFjZSAqL1xuICBoZWlnaHQ6IDA7XG5cbiAgLyogcHJldmVudCBzcGVjaWFsIGNvbnRhaW5lciBjdXJzb3JzIGZyb20gbGVha2luZyBpbiovXG4gIGN1cnNvcjogZGVmYXVsdDtcbn1cblxuLiR7dWlkfV9oYXMtbW9kYWwtdmlzaWJsZSB7XG4gIC8qIG1vZGFsIGlzIG9wZW5lZC92aXNpYmxlLCBwcmV2ZW50IHNjcm9sbGluZyAqL1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uJHt1aWR9X2Nsb3NlOmhvdmVyLFxuLiR7dWlkfV9jbG9zZTpmb2N1cyB7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgYmFja2dyb3VuZDogIyR7dGhlbWVDb2xvcn07XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4uJHt1aWR9X21vZGFsLW92ZXJsYXkge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgei1pbmRleDogNTAwMDAwMDAwMDtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjcpO1xufVxuXG4uJHt1aWR9X21vZGFsLWNvbnRhaW5lciB7XG4gIC8qIGNlbnRlciB0aGUgbW9kYWwgY29udGVudCAqL1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuLiR7dWlkfV9tb2RhbCB7XG4gIHdpZHRoOiAke3dpZHRofTtcbiAgbWF4LXdpZHRoOiA1MDBweDtcbiAgaGVpZ2h0OiAke2hlaWdodH07XG4gIG1heC1oZWlnaHQ6IDEwMCU7XG4gIHotaW5kZXg6IDEwMDtcbiAgYmFja2dyb3VuZDogd2hpdGU7XG4gIGJvcmRlcjogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcblxuICAvKiBtb2RhbCBib3gtc2hhZG93ICovXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCA0cHggMjRweCByZ2JhKDAsMCwwLDAuNSk7XG4gIC1tb3otYm94LXNoYWRvdzogMCA0cHggMjRweCByZ2JhKDAsMCwwLDAuNSk7XG4gIGJveC1zaGFkb3c6IDAgNHB4IDI0cHggcmdiYSgwLDAsMCwwLjUpO1xuICAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogcGFkZGluZy1ib3g7XG4gIC1tb3otYmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcbiAgYmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcbn1cblxuLyogZGFyayB0aGVtZSAqL1xuLiR7dWlkfV9tb2RhbC5kYXJrIHtcbiAgYmFja2dyb3VuZDogIzEyMTIxMjtcbn1cblxuLiR7dWlkfV9jbG9zZWQge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4uJHt1aWR9X21vZGFsLWNvbnRlbnQge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XG59XG5cbi4ke3VpZH1fbW9kYWwgLmNsb3NlLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMTtcbiAgdG9wOiAxMHB4O1xuICByaWdodDogMjBweDtcbiAgYmFja2dyb3VuZDogYmxhY2s7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgcGFkZGluZzogNXB4IDEwcHg7XG4gIGZvbnQtc2l6ZTogMS4zcmVtO1xufVxuXG4uJHt1aWR9X2NvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLiR7dWlkfV9jb250YWluZXIgaWZyYW1lIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbiR7YWxsb3dGdWxsc2NyZWVuXG4gICAgPyBgXG4gICAgLyoqIHdoZW4gZGlzcGxheSBpcyBuYXJyb3dlciB0aGF0IDUwMHB4IChtb2JpbGUgZGV2aWNlKVxuICAgIG9wZW4gbW9kYWwgaW4gZnVsbCBzY3JlZW4gKi9cbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA1MDBweCkge1xuICAgICAgLiR7dWlkfV9tb2RhbCB7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDBweDtcbiAgICAgIH1cbiAgICB9YFxuICAgIDogJyd9XG5gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjRzl1Wlc1MGN5OXRiMlJoYkM5amMzTXZhVzVrWlhndWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzVFVGQlRTeERRVUZETEUxQlFVMHNUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkRja0lzUjBGQlJ5eEZRVU5JTEZWQlFWVXNSVUZEVml4TlFVRk5MRVZCUTA0c1MwRkJTeXhGUVVOTUxHVkJRV1VzUjBGUGFFSXNSVUZCUlN4RlFVRkZMRU5CUVVNN08yRkJSVThzUjBGQlJ6czdPenM3T3pzN096czdPenM3UjBGallpeEhRVUZIT3pzN096czdPenRIUVZGSUxFZEJRVWM3T3pzN08wZEJTMGdzUjBGQlJ6dEhRVU5JTEVkQlFVYzdPMmxDUVVWWExGVkJRVlU3T3pzN08wZEJTM2hDTEVkQlFVYzdPenM3T3pzN096czdSMEZWU0N4SFFVRkhPenM3T3pzN08wZEJUMGdzUjBGQlJ6dFhRVU5MTEV0QlFVczdPMWxCUlVvc1RVRkJUVHM3T3pzN096czdPenM3T3pzN096czdSMEZwUW1Zc1IwRkJSenM3T3p0SFFVbElMRWRCUVVjN096czdSMEZKU0N4SFFVRkhPenM3T3pzN096dEhRVkZJTEVkQlFVYzdPenM3T3pzN096czdPMGRCVjBnc1IwRkJSenM3T3pzN08wZEJUVWdzUjBGQlJ6czdPenM3UlVGTlNpeGxRVUZsTzBsQlEySXNRMEZCUXl4RFFVRkRPenM3TzFOQlNVY3NSMEZCUnpzN096czdUVUZMVGp0SlFVTkdMRU5CUVVNc1EwRkJReXhGUVVOT08wTkJRME1zUTBGQlF5SjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/modal/css/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/modal/html/index.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/components/modal/html/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getModalWrapper: function() { return /* binding */ getModalWrapper; }\n/* harmony export */ });\nconst getModalWrapper = (uid, theme) => `\n<div class=\"${uid}_modal-overlay ${uid}_modal-container\" id=\"${uid}_modal-overlay\"/>\n<div class=\"${uid}_modal ${theme}\" id=\"${uid}_modal\">\n    <div class=\"${uid}_modal-content\">\n        <div class=\"${uid}_container\"/>\n    </div>\n</div>\n`;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9tb2RhbC9odG1sL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUF1QixFQUFFLEVBQUUsQ0FBQztjQUMzRCxHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixHQUFHO2NBQ3BELEdBQUcsVUFBVSxLQUFLLFNBQVMsR0FBRztrQkFDMUIsR0FBRztzQkFDQyxHQUFHOzs7Q0FHeEIsQ0FBQyJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2NvbXBvbmVudHMvbW9kYWwvaHRtbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCxjQUFjLElBQUksaUJBQWlCLElBQUksd0JBQXdCLElBQUk7QUFDbkUsY0FBYyxJQUFJLFNBQVMsTUFBTSxRQUFRLElBQUk7QUFDN0Msa0JBQWtCLElBQUk7QUFDdEIsc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2NvbXBvbmVudHMvbW9kYWwvaHRtbC9pbmRleC5qcz9mZDRmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBnZXRNb2RhbFdyYXBwZXIgPSAodWlkLCB0aGVtZSkgPT4gYFxuPGRpdiBjbGFzcz1cIiR7dWlkfV9tb2RhbC1vdmVybGF5ICR7dWlkfV9tb2RhbC1jb250YWluZXJcIiBpZD1cIiR7dWlkfV9tb2RhbC1vdmVybGF5XCIvPlxuPGRpdiBjbGFzcz1cIiR7dWlkfV9tb2RhbCAke3RoZW1lfVwiIGlkPVwiJHt1aWR9X21vZGFsXCI+XG4gICAgPGRpdiBjbGFzcz1cIiR7dWlkfV9tb2RhbC1jb250ZW50XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3VpZH1fY29udGFpbmVyXCIvPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjRzl1Wlc1MGN5OXRiMlJoYkM5b2RHMXNMMmx1WkdWNExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCTEUxQlFVMHNRMEZCUXl4TlFVRk5MR1ZCUVdVc1IwRkJSeXhEUVVGRExFZEJRVmNzUlVGQlJTeExRVUYxUWl4RlFVRkZMRVZCUVVVc1EwRkJRenRqUVVNelJDeEhRVUZITEd0Q1FVRnJRaXhIUVVGSExIbENRVUY1UWl4SFFVRkhPMk5CUTNCRUxFZEJRVWNzVlVGQlZTeExRVUZMTEZOQlFWTXNSMEZCUnp0clFrRkRNVUlzUjBGQlJ6dHpRa0ZEUXl4SFFVRkhPenM3UTBGSGVFSXNRMEZCUXlKOSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/modal/html/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/index.js":
/*!***************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PluggyConnect: function() { return /* reexport safe */ _pluggy_connect__WEBPACK_IMPORTED_MODULE_0__.PluggyConnect; }\n/* harmony export */ });\n/* harmony import */ var _pluggy_connect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluggy-connect */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/pluggy-connect.js\");\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLGFBQWEsR0FJZCxNQUFNLGtCQUFrQixDQUFDIn0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEO0FBQ2xELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3BsdWdneS1jb25uZWN0LXNkay9kaXN0L21vZHVsZS9pbmRleC5qcz9mYmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFBsdWdneUNvbm5lY3QsIH0gZnJvbSAnLi9wbHVnZ3ktY29ubmVjdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YVc1a1pYZ3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc1QwRkJUeXhGUVVOTUxHRkJRV0VzUjBGSlpDeE5RVUZOTEd0Q1FVRnJRaXhEUVVGREluMD0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/pluggy-connect.js":
/*!************************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/pluggy-connect.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PluggyConnect: function() { return /* binding */ PluggyConnect; },\n/* harmony export */   initialize: function() { return /* binding */ initialize; }\n/* harmony export */ });\n/* harmony import */ var zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zoid/dist/zoid.frameworks.frame */ \"(app-pages-browser)/../node_modules/zoid/dist/zoid.frameworks.frame.js\");\n/* harmony import */ var zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_loader_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/loader/css */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/css/index.js\");\n/* harmony import */ var _components_loader_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/loader/html */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/loader/html/index.js\");\n/* harmony import */ var _components_modal_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/modal/css */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/modal/css/index.js\");\n/* harmony import */ var _components_modal_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/modal/html */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/components/modal/html/index.js\");\n/* harmony import */ var _utils_cordova__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/cordova */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/cordova.js\");\n/* harmony import */ var _utils_oauth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/oauth */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/oauth.js\");\n/* harmony import */ var _utils_once__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/once */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/once.js\");\n/* harmony import */ var _utils_props__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/props */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/props.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/version.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n// the URL where the widget component is being hosted\nconst CONNECT_PRODUCTION_URL = 'https://connect.pluggy.ai';\nlet zoidComponentInstance;\n// reference to the container uid, generated once it's rendered\nlet pluggyConnectContainerUid;\n/**\n * Helper to wrap container class names with current container UID\n * @param className\n */\nfunction containerCssClassName(className) {\n    return `${pluggyConnectContainerUid}_${className}`;\n}\n/**\n * Method to be executed from both the child and parent components, to execute the\n * handshake between both so the parent can render the child.\n *\n * @returns a singleton ZoidComponent reference, that will take care of\n * wrapping and rendering the actual ZoidComponentInstance (this\n * should be instantiated only once per page/context).\n */\nfunction initialize() {\n    if (!zoidComponentInstance) {\n        zoidComponentInstance = (0,zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__.create)({\n            // The html tag used to render the component\n            tag: 'pluggy-connect-widget',\n            // The url of the page that will show in the iframe or popup, when someone includes the component on their site\n            url: ({ props }) => {\n                const { url: urlByProp = CONNECT_PRODUCTION_URL } = props;\n                return urlByProp;\n            },\n            dimensions: {\n                width: '320px',\n                height: '568px',\n            },\n            props: {\n                connectToken: {\n                    type: 'string',\n                },\n                url: {\n                    type: 'string',\n                    required: false,\n                },\n                includeSandbox: {\n                    type: 'boolean',\n                    required: false,\n                },\n                allowConnectInBackground: {\n                    type: 'boolean',\n                    required: false,\n                },\n                allowFullscreen: {\n                    type: 'boolean',\n                    required: false,\n                },\n                updateItem: {\n                    type: 'string',\n                    required: false,\n                },\n                connectorTypes: {\n                    type: 'array',\n                    required: false,\n                },\n                connectorIds: {\n                    type: 'array',\n                    required: false,\n                },\n                countries: {\n                    type: 'array',\n                    required: false,\n                },\n                selectedConnectorId: {\n                    type: 'number',\n                    required: false,\n                },\n                language: {\n                    type: 'string',\n                    required: false,\n                },\n                theme: {\n                    type: 'string',\n                    required: false,\n                },\n                moveSecurityData: {\n                    type: 'string',\n                    required: false,\n                },\n                products: {\n                    type: 'array',\n                    required: false,\n                },\n                sdkVersion: {\n                    type: 'array',\n                    required: false,\n                    default: () => (0,_version__WEBPACK_IMPORTED_MODULE_9__.getSdkVersion)(),\n                },\n                _runningInCordova: {\n                    type: 'boolean',\n                    required: false,\n                    default: () => (0,_utils_cordova__WEBPACK_IMPORTED_MODULE_5__.isRunningInCordova)(),\n                },\n                onSuccessProp: {\n                    type: 'function',\n                    required: false,\n                },\n                onErrorProp: {\n                    type: 'function',\n                    required: false,\n                },\n                onOpenProp: {\n                    type: 'function',\n                    required: false,\n                },\n                onHideProp: {\n                    type: 'function',\n                    required: false,\n                },\n                onCloseProp: {\n                    type: 'function',\n                    required: false,\n                },\n                onEventProp: {\n                    type: 'function',\n                    required: false,\n                },\n            },\n            attributes: {\n                iframe: {\n                    scrolling: 'no',\n                    title: 'Pluggy',\n                },\n                popup: {\n                    scrolling: 'no',\n                    title: 'Pluggy',\n                },\n            },\n            prerenderTemplate({ doc, props }) {\n                const htmlNew = doc.createElement('html');\n                htmlNew.innerHTML = (0,_components_loader_html__WEBPACK_IMPORTED_MODULE_2__.loaderComponentHtml)({\n                    nonce: props.cspNonce,\n                });\n                return htmlNew;\n            },\n            containerTemplate({ doc, dimensions: { height, width }, close, uid, frame, prerenderFrame, event, props, }) {\n                if (!prerenderFrame || !frame) {\n                    throw new Error('Unexpected state: prerenderFrame or frame not defined');\n                }\n                // set container uid global reference\n                pluggyConnectContainerUid = uid;\n                const container = doc.createElement('div');\n                const connectTheme = props.theme || 'light';\n                container.id = uid;\n                container.innerHTML = (0,_components_modal_html__WEBPACK_IMPORTED_MODULE_4__.getModalWrapper)(uid, connectTheme);\n                const frameContainer = container.querySelector(`.${uid}_container`);\n                if (!frameContainer) {\n                    throw new Error('Unexpected state: not found frame container');\n                }\n                const visibleClassName = containerCssClassName('visible');\n                const invisibleClassName = containerCssClassName('invisible');\n                const prerenderFrameClassName = containerCssClassName('prerender-frame');\n                frameContainer.appendChild(frame);\n                frameContainer.appendChild(prerenderFrame);\n                // Add styles\n                const style = doc.createElement('style');\n                // if allowFullscreen is not defined, default to true\n                const allowFullscreenOrDefault = props.allowFullscreen !== undefined ? props.allowFullscreen : true;\n                style.innerHTML = [\n                    (0,_components_modal_css__WEBPACK_IMPORTED_MODULE_3__.getCSS)({\n                        uid,\n                        themeColor: 'fafafa',\n                        height,\n                        width,\n                        allowFullscreen: allowFullscreenOrDefault,\n                    }),\n                    (0,_components_loader_css__WEBPACK_IMPORTED_MODULE_1__.getContainerCss)({ uid }),\n                ].join('\\n');\n                container.appendChild(style);\n                prerenderFrame.classList.add(prerenderFrameClassName);\n                prerenderFrame.classList.add(visibleClassName);\n                frame.classList.add(invisibleClassName);\n                event.on(zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__.EVENT.RENDERED, () => {\n                    // hide prerender frame, display content frame\n                    prerenderFrame.classList.remove(visibleClassName);\n                    prerenderFrame.classList.add(invisibleClassName);\n                    frame.classList.remove(invisibleClassName);\n                    frame.classList.add(visibleClassName);\n                });\n                // Remove scrolling from document body when modal is open (ie. visible)\n                const modalVisibleClassName = containerCssClassName('has-modal-visible');\n                event.on(zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__.EVENT.DISPLAY, () => {\n                    // modal displayed, add visible class & call onOpen callback\n                    document.body.classList.add(modalVisibleClassName);\n                    const { onOpenProp } = props;\n                    onOpenProp === null || onOpenProp === void 0 ? void 0 : onOpenProp();\n                });\n                // Wrap onCloseProp to be called only once, per component instance, which is\n                // what we want to allow.\n                // This \"hack\" is necessary because Zoid may trigger 2 times EVENT.CLOSE event,\n                // for example when removing the container element from DOM and when explicitly\n                // calling close() handler at the same time.\n                // Each time a new container/component is rendered, the props are re-created from scratch,\n                // so this will work for all cases.\n                const onClosePropWrapper = props.onCloseProp\n                    ? (0,_utils_once__WEBPACK_IMPORTED_MODULE_7__.once)(props.onCloseProp)\n                    : null;\n                event.on(zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__.EVENT.CLOSE, () => {\n                    // modal closed, remove visible class & call onClose callback\n                    // Note: this callback may be called 2 times in some cases due to Zoid logic,\n                    // for example when unmounting container component AND calling close() explicitly.\n                    document.body.classList.remove(modalVisibleClassName);\n                    onClosePropWrapper === null || onClosePropWrapper === void 0 ? void 0 : onClosePropWrapper();\n                });\n                // receive message from iframe\n                window.addEventListener('message', (event) => {\n                    const { origin, data } = event;\n                    const { url: connectWebappUrl = 'https://connect.pluggy.ai', } = props;\n                    if (origin !== connectWebappUrl) {\n                        // origin not matching, comming from another place -> ignore message\n                        return;\n                    }\n                    let pluggyConnectMessage;\n                    try {\n                        pluggyConnectMessage = JSON.parse(data);\n                    }\n                    catch (_a) {\n                        // could not parse, data is not a valid JSON string\n                        return;\n                    }\n                    if (pluggyConnectMessage.type === 'OAUTH_OPEN' &&\n                        (0,_utils_cordova__WEBPACK_IMPORTED_MODULE_5__.isRunningInCordova)()) {\n                        const { message: oauthUrl } = pluggyConnectMessage;\n                        // in the case of pluggy-connect running in Cordova mobile native environment\n                        // we must handle the Oauth popup opening manually by explicitly managing a new iframe window\n                        (0,_utils_oauth__WEBPACK_IMPORTED_MODULE_6__.openOauthUrlInCordovaBrowser)(oauthUrl, (payload) => { var _a; return (_a = frame.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(payload, '*'); });\n                        return;\n                    }\n                    if (pluggyConnectMessage.type === 'LINK_OPEN' &&\n                        (0,_utils_cordova__WEBPACK_IMPORTED_MODULE_5__.isRunningInCordova)()) {\n                        const { message: externalUrl } = pluggyConnectMessage;\n                        // in the case of pluggy-connect running in Cordova mobile native environment,\n                        // open the link specifically in the system browser,\n                        // so the main app frame is not blocked, and the user can go back to the app easily\n                        (0,_utils_cordova__WEBPACK_IMPORTED_MODULE_5__.openInCordovaInAppBrowser)(externalUrl, '_system');\n                        return;\n                    }\n                    if (pluggyConnectMessage.type === 'CONTINUE_IN_BACKGROUND') {\n                        // hide pluggy-connect, we remove the 'has-modal-visible' class to restore the scroll\n                        document.body.classList.remove(modalVisibleClassName);\n                        return;\n                    }\n                }, false);\n                // Register modal close() on 'Escape' key button press\n                document.addEventListener('keydown', function escapeKeyCloseHandler(event) {\n                    if (event.key !== 'Escape') {\n                        return;\n                    }\n                    // escape key -> close (and remove 'keydown' listener)\n                    close();\n                    document.removeEventListener('keydown', escapeKeyCloseHandler);\n                });\n                return container;\n            },\n        });\n    }\n    return zoidComponentInstance;\n}\nclass PluggyConnect {\n    constructor(props) {\n        this.zoidComponent = initialize();\n        // extend component props with current wrapper props\n        const extendedProps = Object.assign(Object.assign({}, props), { sdkVersion: (0,_version__WEBPACK_IMPORTED_MODULE_9__.getSdkVersion)() });\n        // adapt props to avoid collision with Zoid component props\n        // assign to private variable for reusability by React wrapper\n        this.componentPropsExtendedAdapted = (0,_utils_props__WEBPACK_IMPORTED_MODULE_8__.adaptPluggyConnectProps)(extendedProps);\n    }\n    /**\n     * Render the component using the specified component props,\n     * as a modal with an iframe, appended to the page body (or the DOM uppermost element).\n     *\n     * @param containerElement - parent element where component should be rendered at. If not specified, will render at body root element.\n     * @returns promise that resolves when rendered successfully, or throws if failed.\n     */\n    init(containerElement) {\n        const container = containerElement ||\n            (document.getElementsByTagName('body') ||\n                document.getElementsByTagName('html') ||\n                document.getElementsByTagName('div'))[0];\n        // initialize zoid componentInstance\n        this.componentInstance = this.zoidComponent(this.componentPropsExtendedAdapted);\n        return this.componentInstance.render(container).catch((error) => {\n            console.error(`Failed to render <PluggyConnect /> component`, error);\n            throw error;\n        });\n    }\n    /**\n     * Manually cleanup the component.\n     * This is not recommended, you should create the component once\n     * and re-render it as needed each new time to save resources.\n     */\n    destroy() {\n        zoidComponentInstance = undefined;\n        return (0,zoid_dist_zoid_frameworks_frame__WEBPACK_IMPORTED_MODULE_0__.destroy)();\n    }\n    /**\n     * If the component is minimized, re-open it.\n     * @retruns promise that resolves when re-opened successfully, or throws if failed.\n     */\n    show() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.componentInstance) {\n                throw new Error('Failed to show <PluggyConnect /> component: component not initialized');\n            }\n            try {\n                // open wrapper modal\n                yield this.componentInstance.show();\n                // add modal visible class\n                const modalVisibleClassName = containerCssClassName('has-modal-visible');\n                document.body.classList.add(modalVisibleClassName);\n            }\n            catch (error) {\n                console.error(`Failed to show <PluggyConnect /> component`, error);\n                throw error;\n            }\n        });\n    }\n    /**\n     * Minimize the component.\n     * Useful if you want to hide Connect widget after credentials have been submitted,\n     * and you want to just continue connecting in background while still listening to\n     * other callback events.\n     */\n    hide() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.componentInstance) {\n                throw new Error('Failed to hide <PluggyConnect /> component: component not initialized');\n            }\n            try {\n                // hide wrapper modal\n                yield this.componentInstance.hide();\n                // remove modal visible class\n                const modalVisibleClassName = containerCssClassName('has-modal-visible');\n                document.body.classList.remove(modalVisibleClassName);\n            }\n            catch (error) {\n                console.error(`Failed to hide <PluggyConnect /> component`, error);\n                throw error;\n            }\n        });\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (PluggyConnect);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2d5LWNvbm5lY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGx1Z2d5LWNvbm5lY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUNMLE1BQU0sRUFDTixPQUFPLEVBQ1AsS0FBSyxHQUdOLE1BQU0saUNBQWlDLENBQUM7QUFFekMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzFELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQy9ELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUVMLHVCQUF1QixHQUN4QixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBc0YxQyxxREFBcUQ7QUFDckQsTUFBTSxzQkFBc0IsR0FBRywyQkFBMkIsQ0FBQztBQU0zRCxJQUFJLHFCQUE2RCxDQUFDO0FBRWxFLCtEQUErRDtBQUMvRCxJQUFJLHlCQUE2QyxDQUFDO0FBRWxEOzs7R0FHRztBQUNILFNBQVMscUJBQXFCLENBQUMsU0FBaUI7SUFDOUMsT0FBTyxHQUFHLHlCQUF5QixJQUFJLFNBQVMsRUFBRSxDQUFDO0FBQ3JELENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLFVBQVU7SUFDeEIsSUFBSSxDQUFDLHFCQUFxQixFQUFFO1FBQzFCLHFCQUFxQixHQUFHLE1BQU0sQ0FBNEI7WUFDeEQsNENBQTRD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//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3BsdWdneS1jb25uZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDMEU7QUFDaEI7QUFDSztBQUNmO0FBQ1U7QUFDc0I7QUFDbkI7QUFDekI7QUFDcUI7QUFDZjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCLEdBQUcsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0NBQWdDLHVFQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHdCQUF3QiwwQ0FBMEM7QUFDbEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtEQUFlLGFBQWEsRUFBQztBQUM3QiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9wbHVnZ3ktY29ubmVjdC1zZGsvZGlzdC9tb2R1bGUvcGx1Z2d5LWNvbm5lY3QuanM/MTZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGNyZWF0ZSwgZGVzdHJveSwgRVZFTlQsIH0gZnJvbSAnem9pZC9kaXN0L3pvaWQuZnJhbWV3b3Jrcy5mcmFtZSc7XG5pbXBvcnQgeyBnZXRDb250YWluZXJDc3MgfSBmcm9tICcuL2NvbXBvbmVudHMvbG9hZGVyL2Nzcyc7XG5pbXBvcnQgeyBsb2FkZXJDb21wb25lbnRIdG1sIH0gZnJvbSAnLi9jb21wb25lbnRzL2xvYWRlci9odG1sJztcbmltcG9ydCB7IGdldENTUyB9IGZyb20gJy4vY29tcG9uZW50cy9tb2RhbC9jc3MnO1xuaW1wb3J0IHsgZ2V0TW9kYWxXcmFwcGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL21vZGFsL2h0bWwnO1xuaW1wb3J0IHsgaXNSdW5uaW5nSW5Db3Jkb3ZhLCBvcGVuSW5Db3Jkb3ZhSW5BcHBCcm93c2VyIH0gZnJvbSAnLi91dGlscy9jb3Jkb3ZhJztcbmltcG9ydCB7IG9wZW5PYXV0aFVybEluQ29yZG92YUJyb3dzZXIgfSBmcm9tICcuL3V0aWxzL29hdXRoJztcbmltcG9ydCB7IG9uY2UgfSBmcm9tICcuL3V0aWxzL29uY2UnO1xuaW1wb3J0IHsgYWRhcHRQbHVnZ3lDb25uZWN0UHJvcHMsIH0gZnJvbSAnLi91dGlscy9wcm9wcyc7XG5pbXBvcnQgeyBnZXRTZGtWZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbi8vIHRoZSBVUkwgd2hlcmUgdGhlIHdpZGdldCBjb21wb25lbnQgaXMgYmVpbmcgaG9zdGVkXG5jb25zdCBDT05ORUNUX1BST0RVQ1RJT05fVVJMID0gJ2h0dHBzOi8vY29ubmVjdC5wbHVnZ3kuYWknO1xubGV0IHpvaWRDb21wb25lbnRJbnN0YW5jZTtcbi8vIHJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIHVpZCwgZ2VuZXJhdGVkIG9uY2UgaXQncyByZW5kZXJlZFxubGV0IHBsdWdneUNvbm5lY3RDb250YWluZXJVaWQ7XG4vKipcbiAqIEhlbHBlciB0byB3cmFwIGNvbnRhaW5lciBjbGFzcyBuYW1lcyB3aXRoIGN1cnJlbnQgY29udGFpbmVyIFVJRFxuICogQHBhcmFtIGNsYXNzTmFtZVxuICovXG5mdW5jdGlvbiBjb250YWluZXJDc3NDbGFzc05hbWUoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGAke3BsdWdneUNvbm5lY3RDb250YWluZXJVaWR9XyR7Y2xhc3NOYW1lfWA7XG59XG4vKipcbiAqIE1ldGhvZCB0byBiZSBleGVjdXRlZCBmcm9tIGJvdGggdGhlIGNoaWxkIGFuZCBwYXJlbnQgY29tcG9uZW50cywgdG8gZXhlY3V0ZSB0aGVcbiAqIGhhbmRzaGFrZSBiZXR3ZWVuIGJvdGggc28gdGhlIHBhcmVudCBjYW4gcmVuZGVyIHRoZSBjaGlsZC5cbiAqXG4gKiBAcmV0dXJucyBhIHNpbmdsZXRvbiBab2lkQ29tcG9uZW50IHJlZmVyZW5jZSwgdGhhdCB3aWxsIHRha2UgY2FyZSBvZlxuICogd3JhcHBpbmcgYW5kIHJlbmRlcmluZyB0aGUgYWN0dWFsIFpvaWRDb21wb25lbnRJbnN0YW5jZSAodGhpc1xuICogc2hvdWxkIGJlIGluc3RhbnRpYXRlZCBvbmx5IG9uY2UgcGVyIHBhZ2UvY29udGV4dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghem9pZENvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgIHpvaWRDb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZSh7XG4gICAgICAgICAgICAvLyBUaGUgaHRtbCB0YWcgdXNlZCB0byByZW5kZXIgdGhlIGNvbXBvbmVudFxuICAgICAgICAgICAgdGFnOiAncGx1Z2d5LWNvbm5lY3Qtd2lkZ2V0JyxcbiAgICAgICAgICAgIC8vIFRoZSB1cmwgb2YgdGhlIHBhZ2UgdGhhdCB3aWxsIHNob3cgaW4gdGhlIGlmcmFtZSBvciBwb3B1cCwgd2hlbiBzb21lb25lIGluY2x1ZGVzIHRoZSBjb21wb25lbnQgb24gdGhlaXIgc2l0ZVxuICAgICAgICAgICAgdXJsOiAoeyBwcm9wcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IHVybEJ5UHJvcCA9IENPTk5FQ1RfUFJPRFVDVElPTl9VUkwgfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxCeVByb3A7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMzIwcHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzU2OHB4JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RUb2tlbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZVNhbmRib3g6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbGxvd0Nvbm5lY3RJbkJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbGxvd0Z1bGxzY3JlZW46IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JUeXBlczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JJZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY291bnRyaWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ29ubmVjdG9ySWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGVtZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW92ZVNlY3VyaXR5RGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvZHVjdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2RrVmVyc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICgpID0+IGdldFNka1ZlcnNpb24oKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9ydW5uaW5nSW5Db3Jkb3ZhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiBpc1J1bm5pbmdJbkNvcmRvdmEoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzc1Byb3A6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25FcnJvclByb3A6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25PcGVuUHJvcDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkhpZGVQcm9wOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xvc2VQcm9wOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRXZlbnRQcm9wOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBpZnJhbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsaW5nOiAnbm8nLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1BsdWdneScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3B1cDoge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxpbmc6ICdubycsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnUGx1Z2d5JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXJlbmRlclRlbXBsYXRlKHsgZG9jLCBwcm9wcyB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbE5ldyA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgICAgICAgICAgaHRtbE5ldy5pbm5lckhUTUwgPSBsb2FkZXJDb21wb25lbnRIdG1sKHtcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHByb3BzLmNzcE5vbmNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBodG1sTmV3O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRhaW5lclRlbXBsYXRlKHsgZG9jLCBkaW1lbnNpb25zOiB7IGhlaWdodCwgd2lkdGggfSwgY2xvc2UsIHVpZCwgZnJhbWUsIHByZXJlbmRlckZyYW1lLCBldmVudCwgcHJvcHMsIH0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXJlbmRlckZyYW1lIHx8ICFmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc3RhdGU6IHByZXJlbmRlckZyYW1lIG9yIGZyYW1lIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBjb250YWluZXIgdWlkIGdsb2JhbCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBwbHVnZ3lDb25uZWN0Q29udGFpbmVyVWlkID0gdWlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0VGhlbWUgPSBwcm9wcy50aGVtZSB8fCAnbGlnaHQnO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pZCA9IHVpZDtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gZ2V0TW9kYWxXcmFwcGVyKHVpZCwgY29ubmVjdFRoZW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHt1aWR9X2NvbnRhaW5lcmApO1xuICAgICAgICAgICAgICAgIGlmICghZnJhbWVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHN0YXRlOiBub3QgZm91bmQgZnJhbWUgY29udGFpbmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGVDbGFzc05hbWUgPSBjb250YWluZXJDc3NDbGFzc05hbWUoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZpc2libGVDbGFzc05hbWUgPSBjb250YWluZXJDc3NDbGFzc05hbWUoJ2ludmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXJlbmRlckZyYW1lQ2xhc3NOYW1lID0gY29udGFpbmVyQ3NzQ2xhc3NOYW1lKCdwcmVyZW5kZXItZnJhbWUnKTtcbiAgICAgICAgICAgICAgICBmcmFtZUNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICAgICAgZnJhbWVDb250YWluZXIuYXBwZW5kQ2hpbGQocHJlcmVuZGVyRnJhbWUpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBzdHlsZXNcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGFsbG93RnVsbHNjcmVlbiBpcyBub3QgZGVmaW5lZCwgZGVmYXVsdCB0byB0cnVlXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dGdWxsc2NyZWVuT3JEZWZhdWx0ID0gcHJvcHMuYWxsb3dGdWxsc2NyZWVuICE9PSB1bmRlZmluZWQgPyBwcm9wcy5hbGxvd0Z1bGxzY3JlZW4gOiB0cnVlO1xuICAgICAgICAgICAgICAgIHN0eWxlLmlubmVySFRNTCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q1NTKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lQ29sb3I6ICdmYWZhZmEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0Z1bGxzY3JlZW46IGFsbG93RnVsbHNjcmVlbk9yRGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnRhaW5lckNzcyh7IHVpZCB9KSxcbiAgICAgICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyRnJhbWUuY2xhc3NMaXN0LmFkZChwcmVyZW5kZXJGcmFtZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyRnJhbWUuY2xhc3NMaXN0LmFkZCh2aXNpYmxlQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICBmcmFtZS5jbGFzc0xpc3QuYWRkKGludmlzaWJsZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUkVOREVSRUQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZSBwcmVyZW5kZXIgZnJhbWUsIGRpc3BsYXkgY29udGVudCBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBwcmVyZW5kZXJGcmFtZS5jbGFzc0xpc3QucmVtb3ZlKHZpc2libGVDbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwcmVyZW5kZXJGcmFtZS5jbGFzc0xpc3QuYWRkKGludmlzaWJsZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmNsYXNzTGlzdC5yZW1vdmUoaW52aXNpYmxlQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuY2xhc3NMaXN0LmFkZCh2aXNpYmxlQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2Nyb2xsaW5nIGZyb20gZG9jdW1lbnQgYm9keSB3aGVuIG1vZGFsIGlzIG9wZW4gKGllLiB2aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGFsVmlzaWJsZUNsYXNzTmFtZSA9IGNvbnRhaW5lckNzc0NsYXNzTmFtZSgnaGFzLW1vZGFsLXZpc2libGUnKTtcbiAgICAgICAgICAgICAgICBldmVudC5vbihFVkVOVC5ESVNQTEFZLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGFsIGRpc3BsYXllZCwgYWRkIHZpc2libGUgY2xhc3MgJiBjYWxsIG9uT3BlbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQobW9kYWxWaXNpYmxlQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbk9wZW5Qcm9wIH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgb25PcGVuUHJvcCA9PT0gbnVsbCB8fCBvbk9wZW5Qcm9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk9wZW5Qcm9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCBvbkNsb3NlUHJvcCB0byBiZSBjYWxsZWQgb25seSBvbmNlLCBwZXIgY29tcG9uZW50IGluc3RhbmNlLCB3aGljaCBpc1xuICAgICAgICAgICAgICAgIC8vIHdoYXQgd2Ugd2FudCB0byBhbGxvdy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIFwiaGFja1wiIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIFpvaWQgbWF5IHRyaWdnZXIgMiB0aW1lcyBFVkVOVC5DTE9TRSBldmVudCxcbiAgICAgICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSB3aGVuIHJlbW92aW5nIHRoZSBjb250YWluZXIgZWxlbWVudCBmcm9tIERPTSBhbmQgd2hlbiBleHBsaWNpdGx5XG4gICAgICAgICAgICAgICAgLy8gY2FsbGluZyBjbG9zZSgpIGhhbmRsZXIgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgICAgICAgICAvLyBFYWNoIHRpbWUgYSBuZXcgY29udGFpbmVyL2NvbXBvbmVudCBpcyByZW5kZXJlZCwgdGhlIHByb3BzIGFyZSByZS1jcmVhdGVkIGZyb20gc2NyYXRjaCxcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGlzIHdpbGwgd29yayBmb3IgYWxsIGNhc2VzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2xvc2VQcm9wV3JhcHBlciA9IHByb3BzLm9uQ2xvc2VQcm9wXG4gICAgICAgICAgICAgICAgICAgID8gb25jZShwcm9wcy5vbkNsb3NlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULkNMT1NFLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGFsIGNsb3NlZCwgcmVtb3ZlIHZpc2libGUgY2xhc3MgJiBjYWxsIG9uQ2xvc2UgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogdGhpcyBjYWxsYmFjayBtYXkgYmUgY2FsbGVkIDIgdGltZXMgaW4gc29tZSBjYXNlcyBkdWUgdG8gWm9pZCBsb2dpYyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUgd2hlbiB1bm1vdW50aW5nIGNvbnRhaW5lciBjb21wb25lbnQgQU5EIGNhbGxpbmcgY2xvc2UoKSBleHBsaWNpdGx5LlxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUobW9kYWxWaXNpYmxlQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZVByb3BXcmFwcGVyID09PSBudWxsIHx8IG9uQ2xvc2VQcm9wV3JhcHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DbG9zZVByb3BXcmFwcGVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVjZWl2ZSBtZXNzYWdlIGZyb20gaWZyYW1lXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvcmlnaW4sIGRhdGEgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogY29ubmVjdFdlYmFwcFVybCA9ICdodHRwczovL2Nvbm5lY3QucGx1Z2d5LmFpJywgfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luICE9PSBjb25uZWN0V2ViYXBwVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW4gbm90IG1hdGNoaW5nLCBjb21taW5nIGZyb20gYW5vdGhlciBwbGFjZSAtPiBpZ25vcmUgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnZ3lDb25uZWN0TWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdneUNvbm5lY3RNZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIG5vdCBwYXJzZSwgZGF0YSBpcyBub3QgYSB2YWxpZCBKU09OIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnZ3lDb25uZWN0TWVzc2FnZS50eXBlID09PSAnT0FVVEhfT1BFTicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUnVubmluZ0luQ29yZG92YSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IG9hdXRoVXJsIH0gPSBwbHVnZ3lDb25uZWN0TWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIHBsdWdneS1jb25uZWN0IHJ1bm5pbmcgaW4gQ29yZG92YSBtb2JpbGUgbmF0aXZlIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IGhhbmRsZSB0aGUgT2F1dGggcG9wdXAgb3BlbmluZyBtYW51YWxseSBieSBleHBsaWNpdGx5IG1hbmFnaW5nIGEgbmV3IGlmcmFtZSB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5PYXV0aFVybEluQ29yZG92YUJyb3dzZXIob2F1dGhVcmwsIChwYXlsb2FkKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGZyYW1lLmNvbnRlbnRXaW5kb3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3N0TWVzc2FnZShwYXlsb2FkLCAnKicpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2d5Q29ubmVjdE1lc3NhZ2UudHlwZSA9PT0gJ0xJTktfT1BFTicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUnVubmluZ0luQ29yZG92YSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2U6IGV4dGVybmFsVXJsIH0gPSBwbHVnZ3lDb25uZWN0TWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIHBsdWdneS1jb25uZWN0IHJ1bm5pbmcgaW4gQ29yZG92YSBtb2JpbGUgbmF0aXZlIGVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlbiB0aGUgbGluayBzcGVjaWZpY2FsbHkgaW4gdGhlIHN5c3RlbSBicm93c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhlIG1haW4gYXBwIGZyYW1lIGlzIG5vdCBibG9ja2VkLCBhbmQgdGhlIHVzZXIgY2FuIGdvIGJhY2sgdG8gdGhlIGFwcCBlYXNpbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5JbkNvcmRvdmFJbkFwcEJyb3dzZXIoZXh0ZXJuYWxVcmwsICdfc3lzdGVtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdneUNvbm5lY3RNZXNzYWdlLnR5cGUgPT09ICdDT05USU5VRV9JTl9CQUNLR1JPVU5EJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlkZSBwbHVnZ3ktY29ubmVjdCwgd2UgcmVtb3ZlIHRoZSAnaGFzLW1vZGFsLXZpc2libGUnIGNsYXNzIHRvIHJlc3RvcmUgdGhlIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKG1vZGFsVmlzaWJsZUNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgbW9kYWwgY2xvc2UoKSBvbiAnRXNjYXBlJyBrZXkgYnV0dG9uIHByZXNzXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIGVzY2FwZUtleUNsb3NlSGFuZGxlcihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBrZXkgLT4gY2xvc2UgKGFuZCByZW1vdmUgJ2tleWRvd24nIGxpc3RlbmVyKVxuICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB6b2lkQ29tcG9uZW50SW5zdGFuY2U7XG59XG5leHBvcnQgY2xhc3MgUGx1Z2d5Q29ubmVjdCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy56b2lkQ29tcG9uZW50ID0gaW5pdGlhbGl6ZSgpO1xuICAgICAgICAvLyBleHRlbmQgY29tcG9uZW50IHByb3BzIHdpdGggY3VycmVudCB3cmFwcGVyIHByb3BzXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBzZGtWZXJzaW9uOiBnZXRTZGtWZXJzaW9uKCkgfSk7XG4gICAgICAgIC8vIGFkYXB0IHByb3BzIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIFpvaWQgY29tcG9uZW50IHByb3BzXG4gICAgICAgIC8vIGFzc2lnbiB0byBwcml2YXRlIHZhcmlhYmxlIGZvciByZXVzYWJpbGl0eSBieSBSZWFjdCB3cmFwcGVyXG4gICAgICAgIHRoaXMuY29tcG9uZW50UHJvcHNFeHRlbmRlZEFkYXB0ZWQgPSBhZGFwdFBsdWdneUNvbm5lY3RQcm9wcyhleHRlbmRlZFByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIHNwZWNpZmllZCBjb21wb25lbnQgcHJvcHMsXG4gICAgICogYXMgYSBtb2RhbCB3aXRoIGFuIGlmcmFtZSwgYXBwZW5kZWQgdG8gdGhlIHBhZ2UgYm9keSAob3IgdGhlIERPTSB1cHBlcm1vc3QgZWxlbWVudCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyRWxlbWVudCAtIHBhcmVudCBlbGVtZW50IHdoZXJlIGNvbXBvbmVudCBzaG91bGQgYmUgcmVuZGVyZWQgYXQuIElmIG5vdCBzcGVjaWZpZWQsIHdpbGwgcmVuZGVyIGF0IGJvZHkgcm9vdCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHJlbmRlcmVkIHN1Y2Nlc3NmdWxseSwgb3IgdGhyb3dzIGlmIGZhaWxlZC5cbiAgICAgKi9cbiAgICBpbml0KGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyRWxlbWVudCB8fFxuICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JykgfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpIHx8XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpKVswXTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB6b2lkIGNvbXBvbmVudEluc3RhbmNlXG4gICAgICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLnpvaWRDb21wb25lbnQodGhpcy5jb21wb25lbnRQcm9wc0V4dGVuZGVkQWRhcHRlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlLnJlbmRlcihjb250YWluZXIpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlbmRlciA8UGx1Z2d5Q29ubmVjdCAvPiBjb21wb25lbnRgLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGNsZWFudXAgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCwgeW91IHNob3VsZCBjcmVhdGUgdGhlIGNvbXBvbmVudCBvbmNlXG4gICAgICogYW5kIHJlLXJlbmRlciBpdCBhcyBuZWVkZWQgZWFjaCBuZXcgdGltZSB0byBzYXZlIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB6b2lkQ29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBkZXN0cm95KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBjb21wb25lbnQgaXMgbWluaW1pemVkLCByZS1vcGVuIGl0LlxuICAgICAqIEByZXRydW5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHJlLW9wZW5lZCBzdWNjZXNzZnVsbHksIG9yIHRocm93cyBpZiBmYWlsZWQuXG4gICAgICovXG4gICAgc2hvdygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNob3cgPFBsdWdneUNvbm5lY3QgLz4gY29tcG9uZW50OiBjb21wb25lbnQgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIG9wZW4gd3JhcHBlciBtb2RhbFxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29tcG9uZW50SW5zdGFuY2Uuc2hvdygpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBtb2RhbCB2aXNpYmxlIGNsYXNzXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kYWxWaXNpYmxlQ2xhc3NOYW1lID0gY29udGFpbmVyQ3NzQ2xhc3NOYW1lKCdoYXMtbW9kYWwtdmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChtb2RhbFZpc2libGVDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHNob3cgPFBsdWdneUNvbm5lY3QgLz4gY29tcG9uZW50YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWluaW1pemUgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gaGlkZSBDb25uZWN0IHdpZGdldCBhZnRlciBjcmVkZW50aWFscyBoYXZlIGJlZW4gc3VibWl0dGVkLFxuICAgICAqIGFuZCB5b3Ugd2FudCB0byBqdXN0IGNvbnRpbnVlIGNvbm5lY3RpbmcgaW4gYmFja2dyb3VuZCB3aGlsZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAgKiBvdGhlciBjYWxsYmFjayBldmVudHMuXG4gICAgICovXG4gICAgaGlkZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGhpZGUgPFBsdWdneUNvbm5lY3QgLz4gY29tcG9uZW50OiBjb21wb25lbnQgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGhpZGUgd3JhcHBlciBtb2RhbFxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29tcG9uZW50SW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBtb2RhbCB2aXNpYmxlIGNsYXNzXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kYWxWaXNpYmxlQ2xhc3NOYW1lID0gY29udGFpbmVyQ3NzQ2xhc3NOYW1lKCdoYXMtbW9kYWwtdmlzaWJsZScpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShtb2RhbFZpc2libGVDbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGhpZGUgPFBsdWdneUNvbm5lY3QgLz4gY29tcG9uZW50YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBQbHVnZ3lDb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0d4MVoyZDVMV052Ym01bFkzUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmNHeDFaMmQ1TFdOdmJtNWxZM1F1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3TzBGQlQwRXNUMEZCVHl4RlFVTk1MRTFCUVUwc1JVRkRUaXhQUVVGUExFVkJRMUFzUzBGQlN5eEhRVWRPTEUxQlFVMHNhVU5CUVdsRExFTkJRVU03UVVGRmVrTXNUMEZCVHl4RlFVRkZMR1ZCUVdVc1JVRkJSU3hOUVVGTkxIbENRVUY1UWl4RFFVRkRPMEZCUXpGRUxFOUJRVThzUlVGQlJTeHRRa0ZCYlVJc1JVRkJSU3hOUVVGTkxEQkNRVUV3UWl4RFFVRkRPMEZCUXk5RUxFOUJRVThzUlVGQlJTeE5RVUZOTEVWQlFVVXNUVUZCVFN4M1FrRkJkMElzUTBGQlF6dEJRVU5vUkN4UFFVRlBMRVZCUVVVc1pVRkJaU3hGUVVGRkxFMUJRVTBzZVVKQlFYbENMRU5CUVVNN1FVRkRNVVFzVDBGQlR5eEZRVUZGTEd0Q1FVRnJRaXhGUVVGRkxIbENRVUY1UWl4RlFVRkZMRTFCUVUwc2FVSkJRV2xDTEVOQlFVTTdRVUZEYUVZc1QwRkJUeXhGUVVGRkxEUkNRVUUwUWl4RlFVRkZMRTFCUVUwc1pVRkJaU3hEUVVGRE8wRkJRemRFTEU5QlFVOHNSVUZCUlN4SlFVRkpMRVZCUVVVc1RVRkJUU3hqUVVGakxFTkJRVU03UVVGRGNFTXNUMEZCVHl4RlFVVk1MSFZDUVVGMVFpeEhRVU40UWl4TlFVRk5MR1ZCUVdVc1EwRkJRenRCUVVOMlFpeFBRVUZQTEVWQlFVVXNZVUZCWVN4RlFVRkZMRTFCUVUwc1YwRkJWeXhEUVVGRE8wRkJjMFl4UXl4eFJFRkJjVVE3UVVGRGNrUXNUVUZCVFN4elFrRkJjMElzUjBGQlJ5d3lRa0ZCTWtJc1EwRkJRenRCUVUwelJDeEpRVUZKTEhGQ1FVRTJSQ3hEUVVGRE8wRkJSV3hGTEN0RVFVRXJSRHRCUVVNdlJDeEpRVUZKTEhsQ1FVRTJReXhEUVVGRE8wRkJSV3hFT3pzN1IwRkhSenRCUVVOSUxGTkJRVk1zY1VKQlFYRkNMRU5CUVVNc1UwRkJhVUk3U1VGRE9VTXNUMEZCVHl4SFFVRkhMSGxDUVVGNVFpeEpRVUZKTEZOQlFWTXNSVUZCUlN4RFFVRkRPMEZCUTNKRUxFTkJRVU03UVVGRlJEczdPenM3T3p0SFFVOUhPMEZCUTBnc1RVRkJUU3hWUVVGVkxGVkJRVlU3U1VGRGVFSXNTVUZCU1N4RFFVRkRMSEZDUVVGeFFpeEZRVUZGTzFGQlF6RkNMSEZDUVVGeFFpeEhRVUZITEUxQlFVMHNRMEZCTkVJN1dVRkRlRVFzTkVOQlFUUkRPMWxCUXpWRExFZEJRVWNzUlVGQlJTeDFRa0ZCZFVJN1dVRkZOVUlzSzBkQlFTdEhPMWxCUXk5SExFZEJRVWNzUlVGQlJTeERRVUZETEVWQlFVVXNTMEZCU3l4RlFVRnBReXhGUVVGRkxFVkJRVVU3WjBKQlEyaEVMRTFCUVUwc1JVRkJSU3hIUVVGSExFVkJRVVVzVTBGQlV5eEhRVUZITEhOQ1FVRnpRaXhGUVVGRkxFZEJRVWNzUzBGQlN5eERRVUZETzJkQ1FVTXhSQ3hQUVVGUExGTkJRVk1zUTBGQlF6dFpRVU51UWl4RFFVRkRPMWxCUlVRc1ZVRkJWU3hGUVVGRk8yZENRVU5XTEV0QlFVc3NSVUZCUlN4UFFVRlBPMmRDUVVOa0xFMUJRVTBzUlVGQlJTeFBRVUZQTzJGQlEyaENPMWxCUlVRc1MwRkJTeXhGUVVGRk8yZENRVU5NTEZsQlFWa3NSVUZCUlR0dlFrRkRXaXhKUVVGSkxFVkJRVVVzVVVGQlVUdHBRa0ZEWmp0blFrRkRSQ3hIUVVGSExFVkJRVVU3YjBKQlEwZ3NTVUZCU1N4RlFVRkZMRkZCUVZFN2IwSkJRMlFzVVVGQlVTeEZRVUZGTEV0QlFVczdhVUpCUTJoQ08yZENRVU5FTEdOQlFXTXNSVUZCUlR0dlFrRkRaQ3hKUVVGSkxFVkJRVVVzVTBGQlV6dHZRa0ZEWml4UlFVRlJMRVZCUVVVc1MwRkJTenRwUWtGRGFFSTdaMEpCUTBRc2QwSkJRWGRDTEVWQlFVVTdiMEpCUTNoQ0xFbEJRVWtzUlVGQlJTeFRRVUZUTzI5Q1FVTm1MRkZCUVZFc1JVRkJSU3hMUVVGTE8ybENRVU5vUWp0blFrRkRSQ3hsUVVGbExFVkJRVVU3YjBKQlEyWXNTVUZCU1N4RlFVRkZMRk5CUVZNN2IwSkJRMllzVVVGQlVTeEZRVUZGTEV0QlFVczdhVUpCUTJoQ08yZENRVU5FTEZWQlFWVXNSVUZCUlR0dlFrRkRWaXhKUVVGSkxFVkJRVVVzVVVGQlVUdHZRa0ZEWkN4UlFVRlJMRVZCUVVVc1MwRkJTenRwUWtGRGFFSTdaMEpCUTBRc1kwRkJZeXhGUVVGRk8yOUNRVU5rTEVsQlFVa3NSVUZCUlN4UFFVRlBPMjlDUVVOaUxGRkJRVkVzUlVGQlJTeExRVUZMTzJsQ1FVTm9RanRuUWtGRFJDeFpRVUZaTEVWQlFVVTdiMEpCUTFvc1NVRkJTU3hGUVVGRkxFOUJRVTg3YjBKQlEySXNVVUZCVVN4RlFVRkZMRXRCUVVzN2FVSkJRMmhDTzJkQ1FVTkVMRk5CUVZNc1JVRkJSVHR2UWtGRFZDeEpRVUZKTEVWQlFVVXNUMEZCVHp0dlFrRkRZaXhSUVVGUkxFVkJRVVVzUzBGQlN6dHBRa0ZEYUVJN1owSkJRMFFzYlVKQlFXMUNMRVZCUVVVN2IwSkJRMjVDTEVsQlFVa3NSVUZCUlN4UlFVRlJPMjlDUVVOa0xGRkJRVkVzUlVGQlJTeExRVUZMTzJsQ1FVTm9RanRuUWtGRFJDeFJRVUZSTEVWQlFVVTdiMEpCUTFJc1NVRkJTU3hGUVVGRkxGRkJRVkU3YjBKQlEyUXNVVUZCVVN4RlFVRkZMRXRCUVVzN2FVSkJRMmhDTzJkQ1FVTkVMRXRCUVVzc1JVRkJSVHR2UWtGRFRDeEpRVUZKTEVWQlFVVXNVVUZCVVR0dlFrRkRaQ3hSUVVGUkxFVkJRVVVzUzBGQlN6dHBRa0ZEYUVJN1owSkJRMFFzWjBKQlFXZENMRVZCUVVVN2IwSkJRMmhDTEVsQlFVa3NSVUZCUlN4UlFVRlJPMjlDUVVOa0xGRkJRVkVzUlVGQlJTeExRVUZMTzJsQ1FVTm9RanRuUWtGRFJDeFJRVUZSTEVWQlFVVTdiMEpCUTFJc1NVRkJTU3hGUVVGRkxFOUJRVTg3YjBKQlEySXNVVUZCVVN4RlFVRkZMRXRCUVVzN2FVSkJRMmhDTzJkQ1FVTkVMRlZCUVZVc1JVRkJSVHR2UWtGRFZpeEpRVUZKTEVWQlFVVXNUMEZCVHp0dlFrRkRZaXhSUVVGUkxFVkJRVVVzUzBGQlN6dHZRa0ZEWml4UFFVRlBMRVZCUVVVc1IwRkJSeXhGUVVGRkxFTkJRVU1zWVVGQllTeEZRVUZGTzJsQ1FVTXZRanRuUWtGRFJDeHBRa0ZCYVVJc1JVRkJSVHR2UWtGRGFrSXNTVUZCU1N4RlFVRkZMRk5CUVZNN2IwSkJRMllzVVVGQlVTeEZRVUZGTEV0QlFVczdiMEpCUTJZc1QwRkJUeXhGUVVGRkxFZEJRVWNzUlVGQlJTeERRVUZETEd0Q1FVRnJRaXhGUVVGRk8ybENRVU53UXp0blFrRkRSQ3hoUVVGaExFVkJRVVU3YjBKQlEySXNTVUZCU1N4RlFVRkZMRlZCUVZVN2IwSkJRMmhDTEZGQlFWRXNSVUZCUlN4TFFVRkxPMmxDUVVOb1FqdG5Ra0ZEUkN4WFFVRlhMRVZCUVVVN2IwSkJRMWdzU1VGQlNTeEZRVUZGTEZWQlFWVTdiMEpCUTJoQ0xGRkJRVkVzUlVGQlJTeExRVUZMTzJsQ1FVTm9RanRuUWtGRFJDeFZRVUZWTEVWQlFVVTdiMEpCUTFZc1NVRkJTU3hGUVVGRkxGVkJRVlU3YjBKQlEyaENMRkZCUVZFc1JVRkJSU3hMUVVGTE8ybENRVU5vUWp0blFrRkRSQ3hWUVVGVkxFVkJRVVU3YjBKQlExWXNTVUZCU1N4RlFVRkZMRlZCUVZVN2IwSkJRMmhDTEZGQlFWRXNSVUZCUlN4TFFVRkxPMmxDUVVOb1FqdG5Ra0ZEUkN4WFFVRlhMRVZCUVVVN2IwSkJRMWdzU1VGQlNTeEZRVUZGTEZWQlFWVTdiMEpCUTJoQ0xGRkJRVkVzUlVGQlJTeExRVUZMTzJsQ1FVTm9RanRuUWtGRFJDeFhRVUZYTEVWQlFVVTdiMEpCUTFnc1NVRkJTU3hGUVVGRkxGVkJRVlU3YjBKQlEyaENMRkZCUVZFc1JVRkJSU3hMUVVGTE8ybENRVU5vUWp0aFFVTkdPMWxCUlVRc1ZVRkJWU3hGUVVGRk8yZENRVU5XTEUxQlFVMHNSVUZCUlR0dlFrRkRUaXhUUVVGVExFVkJRVVVzU1VGQlNUdHZRa0ZEWml4TFFVRkxMRVZCUVVVc1VVRkJVVHRwUWtGRGFFSTdaMEpCUTBRc1MwRkJTeXhGUVVGRk8yOUNRVU5NTEZOQlFWTXNSVUZCUlN4SlFVRkpPMjlDUVVObUxFdEJRVXNzUlVGQlJTeFJRVUZSTzJsQ1FVTm9RanRoUVVOR08xbEJSVVFzYVVKQlFXbENMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTzJkQ1FVTTVRaXhOUVVGTkxFOUJRVThzUjBGQlJ5eEhRVUZITEVOQlFVTXNZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVU14UXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhIUVVGSExHMUNRVUZ0UWl4RFFVRkRPMjlDUVVOMFF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRMRkZCUVZFN2FVSkJRM1JDTEVOQlFVTXNRMEZCUXp0blFrRkZTQ3hQUVVGUExFOUJRVThzUTBGQlF6dFpRVU5xUWl4RFFVRkRPMWxCUlVRc2FVSkJRV2xDTEVOQlFVTXNSVUZEYUVJc1IwRkJSeXhGUVVOSUxGVkJRVlVzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVVc1JVRkROMElzUzBGQlN5eEZRVU5NTEVkQlFVY3NSVUZEU0N4TFFVRkxMRVZCUTB3c1kwRkJZeXhGUVVOa0xFdEJRVXNzUlVGRFRDeExRVUZMTEVkQlEwNDdaMEpCUTBNc1NVRkJTU3hEUVVGRExHTkJRV01zU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlR0dlFrRkROMElzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZEWWl4MVJFRkJkVVFzUTBGRGVFUXNRMEZCUXp0cFFrRkRTRHRuUWtGRlJDeHhRMEZCY1VNN1owSkJRM0pETEhsQ1FVRjVRaXhIUVVGSExFZEJRVWNzUTBGQlF6dG5Ra0ZGYUVNc1RVRkJUU3hUUVVGVExFZEJRVWNzUjBGQlJ5eERRVUZETEdGQlFXRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRuUWtGRE0wTXNUVUZCVFN4WlFVRlpMRWRCUVVjc1MwRkJTeXhEUVVGRExFdEJRVXNzU1VGQlNTeFBRVUZQTEVOQlFVTTdaMEpCUlRWRExGTkJRVk1zUTBGQlF5eEZRVUZGTEVkQlFVY3NSMEZCUnl4RFFVRkRPMmRDUVVOdVFpeFRRVUZUTEVOQlFVTXNVMEZCVXl4SFFVRkhMR1ZCUVdVc1EwRkJReXhIUVVGSExFVkJRVVVzV1VGQldTeERRVUZETEVOQlFVTTdaMEpCUlhwRUxFMUJRVTBzWTBGQll5eEhRVUZITEZOQlFWTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hIUVVGSExGbEJRVmtzUTBGQlF5eERRVUZETzJkQ1FVTndSU3hKUVVGSkxFTkJRVU1zWTBGQll5eEZRVUZGTzI5Q1FVTnVRaXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERaRFFVRTJReXhEUVVGRExFTkJRVU03YVVKQlEyaEZPMmRDUVVWRUxFMUJRVTBzWjBKQlFXZENMRWRCUVVjc2NVSkJRWEZDTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1owSkJRekZFTEUxQlFVMHNhMEpCUVd0Q0xFZEJRVWNzY1VKQlFYRkNMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03WjBKQlF6bEVMRTFCUVUwc2RVSkJRWFZDTEVkQlFVY3NjVUpCUVhGQ0xFTkJRMjVFTEdsQ1FVRnBRaXhEUVVOc1FpeERRVUZETzJkQ1FVVkdMR05CUVdNc1EwRkJReXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdaMEpCUTJ4RExHTkJRV01zUTBGQlF5eFhRVUZYTEVOQlFVTXNZMEZCWXl4RFFVRkRMRU5CUVVNN1owSkJSVE5ETEdGQlFXRTdaMEpCUTJJc1RVRkJUU3hMUVVGTExFZEJRVWNzUjBGQlJ5eERRVUZETEdGQlFXRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRuUWtGRmVrTXNjVVJCUVhGRU8yZENRVU55UkN4TlFVRk5MSGRDUVVGM1FpeEhRVU0xUWl4TFFVRkxMRU5CUVVNc1pVRkJaU3hMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVVnlSU3hMUVVGTExFTkJRVU1zVTBGQlV5eEhRVUZITzI5Q1FVTm9RaXhOUVVGTkxFTkJRVU03ZDBKQlEwd3NSMEZCUnp0M1FrRkRTQ3hWUVVGVkxFVkJRVVVzVVVGQlVUdDNRa0ZEY0VJc1RVRkJUVHQzUWtGRFRpeExRVUZMTzNkQ1FVTk1MR1ZCUVdVc1JVRkJSU3gzUWtGQmQwSTdjVUpCUXpGRExFTkJRVU03YjBKQlEwWXNaVUZCWlN4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFTkJRVU03YVVKQlEzcENMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTmlMRk5CUVZNc1EwRkJReXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdaMEpCUlRkQ0xHTkJRV01zUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMSFZDUVVGMVFpeERRVUZETEVOQlFVTTdaMEpCUTNSRUxHTkJRV01zUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMR2RDUVVGblFpeERRVUZETEVOQlFVTTdaMEpCUXk5RExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMR3RDUVVGclFpeERRVUZETEVOQlFVTTdaMEpCUlhoRExFdEJRVXNzUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExFVkJRVVU3YjBKQlF6VkNMRGhEUVVFNFF6dHZRa0ZET1VNc1kwRkJZeXhEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dHZRa0ZEYkVRc1kwRkJZeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF6dHZRa0ZGYWtRc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF6dHZRa0ZETTBNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlJVZ3NkVVZCUVhWRk8yZENRVU4yUlN4TlFVRk5MSEZDUVVGeFFpeEhRVUZITEhGQ1FVRnhRaXhEUVVOcVJDeHRRa0ZCYlVJc1EwRkRjRUlzUTBGQlF6dG5Ra0ZGUml4TFFVRkxMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVWQlFVVXNSMEZCUnl4RlFVRkZPMjlDUVVNelFpdzBSRUZCTkVRN2IwSkJRelZFTEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhEUVVGRE8yOUNRVU51UkN4TlFVRk5MRVZCUVVVc1ZVRkJWU3hGUVVGRkxFZEJRVWNzUzBGQlN5eERRVUZETzI5Q1FVTTNRaXhWUVVGVkxHRkJRVllzVlVGQlZTeDFRa0ZCVml4VlFVRlZMRWRCUVVzN1owSkJRMnBDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVWSUxEUkZRVUUwUlR0blFrRkROVVVzZVVKQlFYbENPMmRDUVVONlFpd3JSVUZCSzBVN1owSkJReTlGTEN0RlFVRXJSVHRuUWtGREwwVXNORU5CUVRSRE8yZENRVU0xUXl3d1JrRkJNRVk3WjBKQlF6RkdMRzFEUVVGdFF6dG5Ra0ZEYmtNc1RVRkJUU3hyUWtGQmEwSXNSMEZCUnl4TFFVRkxMRU5CUVVNc1YwRkJWenR2UWtGRE1VTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETzI5Q1FVTjZRaXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVVlVMRXRCUVVzc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NSVUZCUlN4SFFVRkhMRVZCUVVVN2IwSkJRM3BDTERaRVFVRTJSRHR2UWtGRE4wUXNOa1ZCUVRaRk8yOUNRVU0zUlN4clJrRkJhMFk3YjBKQlEyeEdMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eERRVUZETzI5Q1FVTjBSQ3hyUWtGQmEwSXNZVUZCYkVJc2EwSkJRV3RDTEhWQ1FVRnNRaXhyUWtGQmEwSXNSMEZCU3p0blFrRkRla0lzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUlVnc09FSkJRVGhDTzJkQ1FVTTVRaXhOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUTNKQ0xGTkJRVk1zUlVGRFZDeERRVUZETEV0QlFXMUNMRVZCUVVVc1JVRkJSVHR2UWtGRGRFSXNUVUZCVFN4RlFVRkZMRTFCUVUwc1JVRkJSU3hKUVVGSkxFVkJRVVVzUjBGQlJ5eExRVUZMTEVOQlFVTTdiMEpCUXk5Q0xFMUJRVTBzUlVGRFNpeEhRVUZITEVWQlFVVXNaMEpCUVdkQ0xFZEJRVWNzTWtKQlFUSkNMRWRCUTNCRUxFZEJRVWNzUzBGQlN5eERRVUZETzI5Q1FVVldMRWxCUVVrc1RVRkJUU3hMUVVGTExHZENRVUZuUWl4RlFVRkZPM2RDUVVNdlFpeHZSVUZCYjBVN2QwSkJRM0JGTEU5QlFVODdjVUpCUTFJN2IwSkJSVVFzU1VGQlNTeHZRa0ZCTUVNc1EwRkJRenR2UWtGREwwTXNTVUZCU1R0M1FrRkRSaXh2UWtGQmIwSXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQmVVSXNRMEZCUXp0eFFrRkRha1U3YjBKQlFVTXNWMEZCVFR0M1FrRkRUaXh0UkVGQmJVUTdkMEpCUTI1RUxFOUJRVTg3Y1VKQlExSTdiMEpCUlVRc1NVRkRSU3h2UWtGQmIwSXNRMEZCUXl4SlFVRkpMRXRCUVVzc1dVRkJXVHQzUWtGRE1VTXNhMEpCUVd0Q0xFVkJRVVVzUlVGRGNFSTdkMEpCUTBFc1RVRkJUU3hGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVWQlFVVXNSMEZCUnl4dlFrRkJiMElzUTBGQlF6dDNRa0ZEYmtRc05rVkJRVFpGTzNkQ1FVTTNSU3cyUmtGQk5rWTdkMEpCUXpkR0xEUkNRVUUwUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZGTEhkQ1FVTnFSQ3hMUVVGTExFTkJRVU1zWVVGQllTd3dRMEZCUlN4WFFVRlhMRU5CUVVNc1QwRkJUeXhGUVVGRkxFZEJRVWNzU1VGQlF5eERRVU12UXl4RFFVRkRPM2RDUVVWR0xFOUJRVTg3Y1VKQlExSTdiMEpCUlVRc1NVRkRSU3h2UWtGQmIwSXNRMEZCUXl4SlFVRkpMRXRCUVVzc1YwRkJWenQzUWtGRGVrTXNhMEpCUVd0Q0xFVkJRVVVzUlVGRGNFSTdkMEpCUTBFc1RVRkJUU3hGUVVGRkxFOUJRVThzUlVGQlJTeFhRVUZYTEVWQlFVVXNSMEZCUnl4dlFrRkJiMElzUTBGQlF6dDNRa0ZEZEVRc09FVkJRVGhGTzNkQ1FVTTVSU3h2UkVGQmIwUTdkMEpCUTNCRUxHMUdRVUZ0Ump0M1FrRkRia1lzZVVKQlFYbENMRU5CUVVNc1YwRkJWeXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzNkQ1FVTnNSQ3hQUVVGUE8zRkNRVU5TTzI5Q1FVVkVMRWxCUVVrc2IwSkJRVzlDTEVOQlFVTXNTVUZCU1N4TFFVRkxMSGRDUVVGM1FpeEZRVUZGTzNkQ1FVTXhSQ3h4UmtGQmNVWTdkMEpCUTNKR0xGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4RFFVRkRPM2RDUVVOMFJDeFBRVUZQTzNGQ1FVTlNPMmRDUVVOSUxFTkJRVU1zUlVGRFJDeExRVUZMTEVOQlEwNHNRMEZCUXp0blFrRkZSaXh6UkVGQmMwUTdaMEpCUTNSRUxGRkJRVkVzUTBGQlF5eG5Ra0ZCWjBJc1EwRkRka0lzVTBGQlV5eEZRVU5VTEZOQlFWTXNjVUpCUVhGQ0xFTkJRVU1zUzBGQlN6dHZRa0ZEYkVNc1NVRkJTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eExRVUZMTEZGQlFWRXNSVUZCUlR0M1FrRkRNVUlzVDBGQlR6dHhRa0ZEVWp0dlFrRkRSQ3h6UkVGQmMwUTdiMEpCUTNSRUxFdEJRVXNzUlVGQlJTeERRVUZETzI5Q1FVTlNMRkZCUVZFc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4VFFVRlRMRVZCUVVVc2NVSkJRWEZDTEVOQlFVTXNRMEZCUXp0blFrRkRha1VzUTBGQlF5eERRVU5HTEVOQlFVTTdaMEpCUlVZc1QwRkJUeXhUUVVGVExFTkJRVU03V1VGRGJrSXNRMEZCUXp0VFFVTkdMRU5CUVVNc1EwRkJRenRMUVVOS08wbEJSVVFzVDBGQlR5eHhRa0ZCY1VJc1EwRkJRenRCUVVNdlFpeERRVUZETzBGQlJVUXNUVUZCVFN4UFFVRlBMR0ZCUVdFN1NVRk5lRUlzV1VGQldTeExRVUY1UWp0UlFVTnVReXhKUVVGSkxFTkJRVU1zWVVGQllTeEhRVUZITEZWQlFWVXNSVUZCUlN4RFFVRkRPMUZCUld4RExHOUVRVUZ2UkR0UlFVTndSQ3hOUVVGTkxHRkJRV0VzYlVOQlEyUXNTMEZCU3l4TFFVTlNMRlZCUVZVc1JVRkJSU3hoUVVGaExFVkJRVVVzUjBGRE5VSXNRMEZCUXp0UlFVVkdMREpFUVVFeVJEdFJRVU16UkN3NFJFRkJPRVE3VVVGRE9VUXNTVUZCU1N4RFFVRkRMRFpDUVVFMlFpeEhRVUZITEhWQ1FVRjFRaXhEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzBsQlF6bEZMRU5CUVVNN1NVRkZSRHM3T3pzN08wOUJUVWM3U1VGRFNDeEpRVUZKTEVOQlFVTXNaMEpCUVRoQ08xRkJRMnBETEUxQlFVMHNVMEZCVXl4SFFVTmlMR2RDUVVGblFqdFpRVU5vUWl4RFFVRkRMRkZCUVZFc1EwRkJReXh2UWtGQmIwSXNRMEZCUXl4TlFVRk5MRU5CUVVNN1owSkJRM0JETEZGQlFWRXNRMEZCUXl4dlFrRkJiMElzUTBGQlF5eE5RVUZOTEVOQlFVTTdaMEpCUTNKRExGRkJRVkVzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlRkRExHOURRVUZ2UXp0UlFVTndReXhKUVVGSkxFTkJRVU1zYVVKQlFXbENMRWRCUVVjc1NVRkJTU3hEUVVGRExHRkJRV0VzUTBGRGVrTXNTVUZCU1N4RFFVRkRMRFpDUVVFMlFpeERRVU51UXl4RFFVRkRPMUZCUlVZc1QwRkJUeXhKUVVGSkxFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRXRCUVdNc1JVRkJSU3hGUVVGRk8xbEJRM1pGTEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc09FTkJRVGhETEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1dVRkRja1VzVFVGQlRTeExRVUZMTEVOQlFVTTdVVUZEWkN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGdzVDBGQlR6dFJRVU5NTEhGQ1FVRnhRaXhIUVVGSExGTkJRVk1zUTBGQlF6dFJRVU5zUXl4UFFVRlBMRTlCUVU4c1JVRkJSU3hEUVVGRE8wbEJRMjVDTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFJ5eEpRVUZKT3p0WlFVTlNMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zYVVKQlFXbENMRVZCUVVVN1owSkJRek5DTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUTJJc2RVVkJRWFZGTEVOQlEzaEZMRU5CUVVNN1lVRkRTRHRaUVVORUxFbEJRVWs3WjBKQlEwWXNjVUpCUVhGQ08yZENRVU55UWl4TlFVRk5MRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRuUWtGRGNFTXNNRUpCUVRCQ08yZENRVU14UWl4TlFVRk5MSEZDUVVGeFFpeEhRVUZITEhGQ1FVRnhRaXhEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRU5CUVVNN1owSkJRM3BGTEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhEUVVGRE8yRkJRM0JFTzFsQlFVTXNUMEZCVHl4TFFVRmpMRVZCUVVVN1owSkJRM1pDTEU5QlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc05FTkJRVFJETEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1owSkJRMjVGTEUxQlFVMHNTMEZCU3l4RFFVRkRPMkZCUTJJN1VVRkRTQ3hEUVVGRE8wdEJRVUU3U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5ITEVsQlFVazdPMWxCUTFJc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1JVRkJSVHRuUWtGRE0wSXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkRZaXgxUlVGQmRVVXNRMEZEZUVVc1EwRkJRenRoUVVOSU8xbEJSVVFzU1VGQlNUdG5Ra0ZEUml4eFFrRkJjVUk3WjBKQlEzSkNMRTFCUVUwc1NVRkJTU3hEUVVGRExHbENRVUZwUWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8yZENRVU53UXl3MlFrRkJOa0k3WjBKQlF6ZENMRTFCUVUwc2NVSkJRWEZDTEVkQlFVY3NjVUpCUVhGQ0xFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1EwRkJRenRuUWtGRGVrVXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEhGQ1FVRnhRaXhEUVVGRExFTkJRVU03WVVGRGRrUTdXVUZCUXl4UFFVRlBMRXRCUVdNc1JVRkJSVHRuUWtGRGRrSXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXcwUTBGQk5FTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRuUWtGRGJrVXNUVUZCVFN4TFFVRkxMRU5CUVVNN1lVRkRZanRSUVVOSUxFTkJRVU03UzBGQlFUdERRVU5HTzBGQlJVUXNaVUZCWlN4aFFVRmhMRU5CUVVNaWZRPT0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/pluggy-connect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/cordova.js":
/*!***********************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/utils/cordova.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isRunningInCordova: function() { return /* binding */ isRunningInCordova; },\n/* harmony export */   openInCordovaInAppBrowser: function() { return /* binding */ openInCordovaInAppBrowser; }\n/* harmony export */ });\nfunction isRunningInCordova() {\n    return typeof cordova !== 'undefined';\n}\nfunction openInCordovaInAppBrowser(url, target) {\n    if (!isRunningInCordova()) {\n        throw new Error('Not running in Cordova');\n    }\n    if (!cordova.InAppBrowser) {\n        console.error(\"Tried to open a link in cordova.InAppBrowser, but it's undefined! \" +\n            \"For the best experience, it's recommended to include plugin 'cordova-plugin-inappbrowser' in your build. \" +\n            'Falling back to window.open() instead. Url:', url);\n        window.open(url, target);\n        return null;\n    }\n    const inAppBrowserWindow = cordova.InAppBrowser.open(url, target);\n    // inAppBrowser is actually defined only with '_blank' target\n    return target === '_blank' ? inAppBrowserWindow : null;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29yZG92YS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9jb3Jkb3ZhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE1BQU0sVUFBVSxrQkFBa0I7SUFDaEMsT0FBTyxPQUFPLE9BQU8sS0FBSyxXQUFXLENBQUM7QUFDeEMsQ0FBQztBQUVELE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsR0FBVyxFQUNYLE1BQTRCO0lBRTVCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxFQUFFO1FBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztLQUMzQztJQUVELElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFO1FBQ3pCLE9BQU8sQ0FBQyxLQUFLLENBQ1gsb0VBQW9FO1lBQ2xFLDJHQUEyRztZQUMzRyw2Q0FBNkMsRUFDL0MsR0FBRyxDQUNKLENBQUM7UUFDRixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN6QixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFbEUsNkRBQTZEO0lBQzdELE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN6RCxDQUFDIn0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3V0aWxzL2NvcmRvdmEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy9wbHVnZ3ktY29ubmVjdC1zZGsvZGlzdC9tb2R1bGUvdXRpbHMvY29yZG92YS5qcz82M2VmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc1J1bm5pbmdJbkNvcmRvdmEoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb3Jkb3ZhICE9PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBvcGVuSW5Db3Jkb3ZhSW5BcHBCcm93c2VyKHVybCwgdGFyZ2V0KSB7XG4gICAgaWYgKCFpc1J1bm5pbmdJbkNvcmRvdmEoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBydW5uaW5nIGluIENvcmRvdmEnKTtcbiAgICB9XG4gICAgaWYgKCFjb3Jkb3ZhLkluQXBwQnJvd3Nlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVHJpZWQgdG8gb3BlbiBhIGxpbmsgaW4gY29yZG92YS5JbkFwcEJyb3dzZXIsIGJ1dCBpdCdzIHVuZGVmaW5lZCEgXCIgK1xuICAgICAgICAgICAgXCJGb3IgdGhlIGJlc3QgZXhwZXJpZW5jZSwgaXQncyByZWNvbW1lbmRlZCB0byBpbmNsdWRlIHBsdWdpbiAnY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyJyBpbiB5b3VyIGJ1aWxkLiBcIiArXG4gICAgICAgICAgICAnRmFsbGluZyBiYWNrIHRvIHdpbmRvdy5vcGVuKCkgaW5zdGVhZC4gVXJsOicsIHVybCk7XG4gICAgICAgIHdpbmRvdy5vcGVuKHVybCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGluQXBwQnJvd3NlcldpbmRvdyA9IGNvcmRvdmEuSW5BcHBCcm93c2VyLm9wZW4odXJsLCB0YXJnZXQpO1xuICAgIC8vIGluQXBwQnJvd3NlciBpcyBhY3R1YWxseSBkZWZpbmVkIG9ubHkgd2l0aCAnX2JsYW5rJyB0YXJnZXRcbiAgICByZXR1cm4gdGFyZ2V0ID09PSAnX2JsYW5rJyA/IGluQXBwQnJvd3NlcldpbmRvdyA6IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMjl5Wkc5MllTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OTFkR2xzY3k5amIzSmtiM1poTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lKQlFVVkJMRTFCUVUwc1ZVRkJWU3hyUWtGQmEwSTdTVUZEYUVNc1QwRkJUeXhQUVVGUExFOUJRVThzUzBGQlN5eFhRVUZYTEVOQlFVTTdRVUZEZUVNc1EwRkJRenRCUVVWRUxFMUJRVTBzVlVGQlZTeDVRa0ZCZVVJc1EwRkRka01zUjBGQlZ5eEZRVU5ZTEUxQlFUUkNPMGxCUlRWQ0xFbEJRVWtzUTBGQlF5eHJRa0ZCYTBJc1JVRkJSU3hGUVVGRk8xRkJRM3BDTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2QwSkJRWGRDTEVOQlFVTXNRMEZCUXp0TFFVTXpRenRKUVVWRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RlFVRkZPMUZCUTNwQ0xFOUJRVThzUTBGQlF5eExRVUZMTEVOQlExZ3NiMFZCUVc5Rk8xbEJRMnhGTERKSFFVRXlSenRaUVVNelJ5dzJRMEZCTmtNc1JVRkRMME1zUjBGQlJ5eERRVU5LTEVOQlFVTTdVVUZEUml4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhQUVVGUExFbEJRVWtzUTBGQlF6dExRVU5pTzBsQlJVUXNUVUZCVFN4clFrRkJhMElzUjBGQlJ5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdTVUZGYkVVc05rUkJRVFpFTzBsQlF6ZEVMRTlCUVU4c1RVRkJUU3hMUVVGTExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTjZSQ3hEUVVGREluMD0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/cordova.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/oauth.js":
/*!*********************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/utils/oauth.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   openOauthUrlInCordovaBrowser: function() { return /* binding */ openOauthUrlInCordovaBrowser; }\n/* harmony export */ });\n/* harmony import */ var _cordova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cordova */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/cordova.js\");\n\nfunction openOauthUrlInCordovaBrowser(url, onComplete) {\n    const inAppBrowserWindow = (0,_cordova__WEBPACK_IMPORTED_MODULE_0__.openInCordovaInAppBrowser)(url, '_blank');\n    // track oauth result in navigation URL\n    inAppBrowserWindow === null || inAppBrowserWindow === void 0 ? void 0 : inAppBrowserWindow.addEventListener('loadstop', (event) => {\n        const { url } = event;\n        const isPluggyOauthCallbackUrl = (url.startsWith('https://api.pluggy.ai/') ||\n            url.startsWith('https://api.pluggy.dev/') ||\n            url.startsWith('http://localhost:9090/')) &&\n            url.includes('/oauthCallback.html');\n        if (!isPluggyOauthCallbackUrl) {\n            // not oauth result URL, ignore\n            return;\n        }\n        const params = new URLSearchParams(url.split('?')[1]);\n        const oauthResult = Object.fromEntries(params.entries());\n        onComplete(oauthResult);\n        inAppBrowserWindow.close();\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2F1dGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvb2F1dGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRXRELE1BQU0sVUFBVSw0QkFBNEIsQ0FDMUMsR0FBVyxFQUNYLFVBQXVFO0lBRXZFLE1BQU0sa0JBQWtCLEdBQUcseUJBQXlCLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXBFLHVDQUF1QztJQUN2QyxrQkFBa0IsYUFBbEIsa0JBQWtCLHVCQUFsQixrQkFBa0IsQ0FBRSxnQkFBZ0IsQ0FDbEMsVUFBVSxFQUNWLENBQUMsS0FBd0IsRUFBRSxFQUFFO1FBQzNCLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUM7UUFFdEIsTUFBTSx3QkFBd0IsR0FDNUIsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLHdCQUF3QixDQUFDO1lBQ3ZDLEdBQUcsQ0FBQyxVQUFVLENBQUMseUJBQXlCLENBQUM7WUFDekMsR0FBRyxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1lBQzNDLEdBQUcsQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUV0QyxJQUFJLENBQUMsd0JBQXdCLEVBQUU7WUFDN0IsK0JBQStCO1lBQy9CLE9BQU87U0FDUjtRQUVELE1BQU0sTUFBTSxHQUFHLElBQUksZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0RCxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FFaEMsQ0FBQztRQUV4QixVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDeEIsa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDN0IsQ0FBQyxFQUNEO0FBQ0osQ0FBQyJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3V0aWxzL29hdXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNEO0FBQy9DO0FBQ1AsK0JBQStCLG1FQUF5QjtBQUN4RDtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3V0aWxzL29hdXRoLmpzPzM3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3BlbkluQ29yZG92YUluQXBwQnJvd3NlciB9IGZyb20gJy4vY29yZG92YSc7XG5leHBvcnQgZnVuY3Rpb24gb3Blbk9hdXRoVXJsSW5Db3Jkb3ZhQnJvd3Nlcih1cmwsIG9uQ29tcGxldGUpIHtcbiAgICBjb25zdCBpbkFwcEJyb3dzZXJXaW5kb3cgPSBvcGVuSW5Db3Jkb3ZhSW5BcHBCcm93c2VyKHVybCwgJ19ibGFuaycpO1xuICAgIC8vIHRyYWNrIG9hdXRoIHJlc3VsdCBpbiBuYXZpZ2F0aW9uIFVSTFxuICAgIGluQXBwQnJvd3NlcldpbmRvdyA9PT0gbnVsbCB8fCBpbkFwcEJyb3dzZXJXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluQXBwQnJvd3NlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RvcCcsIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHVybCB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGlzUGx1Z2d5T2F1dGhDYWxsYmFja1VybCA9ICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly9hcGkucGx1Z2d5LmFpLycpIHx8XG4gICAgICAgICAgICB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly9hcGkucGx1Z2d5LmRldi8nKSB8fFxuICAgICAgICAgICAgdXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly9sb2NhbGhvc3Q6OTA5MC8nKSkgJiZcbiAgICAgICAgICAgIHVybC5pbmNsdWRlcygnL29hdXRoQ2FsbGJhY2suaHRtbCcpO1xuICAgICAgICBpZiAoIWlzUGx1Z2d5T2F1dGhDYWxsYmFja1VybCkge1xuICAgICAgICAgICAgLy8gbm90IG9hdXRoIHJlc3VsdCBVUkwsIGlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLnNwbGl0KCc/JylbMV0pO1xuICAgICAgICBjb25zdCBvYXV0aFJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhwYXJhbXMuZW50cmllcygpKTtcbiAgICAgICAgb25Db21wbGV0ZShvYXV0aFJlc3VsdCk7XG4gICAgICAgIGluQXBwQnJvd3NlcldpbmRvdy5jbG9zZSgpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYjJGMWRHZ3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZkWFJwYkhNdmIyRjFkR2d1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWtGQlFVRXNUMEZCVHl4RlFVRkZMSGxDUVVGNVFpeEZRVUZGTEUxQlFVMHNWMEZCVnl4RFFVRkRPMEZCUlhSRUxFMUJRVTBzVlVGQlZTdzBRa0ZCTkVJc1EwRkRNVU1zUjBGQlZ5eEZRVU5ZTEZWQlFYVkZPMGxCUlhaRkxFMUJRVTBzYTBKQlFXdENMRWRCUVVjc2VVSkJRWGxDTEVOQlFVTXNSMEZCUnl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8wbEJSWEJGTEhWRFFVRjFRenRKUVVOMlF5eHJRa0ZCYTBJc1lVRkJiRUlzYTBKQlFXdENMSFZDUVVGc1FpeHJRa0ZCYTBJc1EwRkJSU3huUWtGQlowSXNRMEZEYkVNc1ZVRkJWU3hGUVVOV0xFTkJRVU1zUzBGQmQwSXNSVUZCUlN4RlFVRkZPMUZCUXpOQ0xFMUJRVTBzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4TFFVRkxMRU5CUVVNN1VVRkZkRUlzVFVGQlRTeDNRa0ZCZDBJc1IwRkROVUlzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMSGRDUVVGM1FpeERRVUZETzFsQlEzWkRMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zZVVKQlFYbENMRU5CUVVNN1dVRkRla01zUjBGQlJ5eERRVUZETEZWQlFWVXNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eERRVUZETzFsQlF6TkRMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVU1zY1VKQlFYRkNMRU5CUVVNc1EwRkJRenRSUVVWMFF5eEpRVUZKTEVOQlFVTXNkMEpCUVhkQ0xFVkJRVVU3V1VGRE4wSXNLMEpCUVN0Q08xbEJReTlDTEU5QlFVODdVMEZEVWp0UlFVVkVMRTFCUVUwc1RVRkJUU3hIUVVGSExFbEJRVWtzWlVGQlpTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVjBSQ3hOUVVGTkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGRmFFTXNRMEZCUXp0UlFVVjRRaXhWUVVGVkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZEZUVJc2EwSkJRV3RDTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1NVRkROMElzUTBGQlF5eEZRVU5FTzBGQlEwb3NRMEZCUXlKOSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/oauth.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/once.js":
/*!********************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/utils/once.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   once: function() { return /* binding */ once; }\n/* harmony export */ });\n/**\n * Ensure given function can be called only once.\n * Source: https://stackoverflow.com/a/58084026/6279385\n *\n * @param fn\n */\nfunction once(fn) {\n    let done = false;\n    return function (...args) {\n        if (done) {\n            return void 0;\n        }\n        done = true;\n        return fn.apply(this, args);\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9vbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLElBQUksQ0FDbEIsRUFBNkI7SUFFN0IsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDO0lBQ2pCLE9BQU8sVUFBbUIsR0FBRyxJQUFPO1FBQ2xDLElBQUksSUFBSSxFQUFFO1lBQ1IsT0FBTyxLQUFLLENBQUMsQ0FBQztTQUNmO1FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNaLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQyxDQUFDO0FBQ0osQ0FBQyJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3V0aWxzL29uY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3V0aWxzL29uY2UuanM/OGZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVuc3VyZSBnaXZlbiBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIG9ubHkgb25jZS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU4MDg0MDI2LzYyNzkzODVcbiAqXG4gKiBAcGFyYW0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liMjVqWlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5MWRHbHNjeTl2Ym1ObExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCT3pzN096dEhRVXRITzBGQlEwZ3NUVUZCVFN4VlFVRlZMRWxCUVVrc1EwRkRiRUlzUlVGQk5rSTdTVUZGTjBJc1NVRkJTU3hKUVVGSkxFZEJRVWNzUzBGQlN5eERRVUZETzBsQlEycENMRTlCUVU4c1ZVRkJiVUlzUjBGQlJ5eEpRVUZQTzFGQlEyeERMRWxCUVVrc1NVRkJTU3hGUVVGRk8xbEJRMUlzVDBGQlR5eExRVUZMTEVOQlFVTXNRMEZCUXp0VFFVTm1PMUZCUTBRc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dFJRVU5hTEU5QlFVOHNSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZET1VJc1EwRkJReXhEUVVGRE8wRkJRMG9zUTBGQlF5SjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/once.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/props.js":
/*!*********************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/utils/props.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adaptPluggyConnectProps: function() { return /* binding */ adaptPluggyConnectProps; },\n/* harmony export */   restorePluggyConnectProps: function() { return /* binding */ restorePluggyConnectProps; }\n/* harmony export */ });\n/**\n * Helper to transform user-provided props values, to our own\n * adapted props object.\n * This is necessary to avoid collision with Zoid component props.\n *\n * @param props\n */\nfunction adaptPluggyConnectProps(props) {\n    const { onError, onSuccess, onOpen, onClose, onEvent, onHide } = props;\n    // clone object as-is, to explicitly delete unwanted props later\n    const adaptedPropsBase = Object.assign({}, props);\n    // remove onXX props as some of them collide with Zoid props,\n    // assign them to different keys instead\n    delete adaptedPropsBase.onError;\n    delete adaptedPropsBase.onSuccess;\n    delete adaptedPropsBase.onOpen;\n    delete adaptedPropsBase.onClose;\n    delete adaptedPropsBase.onEvent;\n    delete adaptedPropsBase.onHide;\n    // build adapted props object,\n    // starting from props without the unneeded ones,\n    // adding the ones we need.\n    return Object.assign(Object.assign({}, adaptedPropsBase), { onErrorProp: onError, onSuccessProp: onSuccess, onOpenProp: onOpen, onCloseProp: onClose, onEventProp: onEvent, onHideProp: onHide });\n}\n/**\n * Helper to transform adapted props object, back into user-provided props\n * values.\n * This is necessary to avoid collision with Zoid component props.\n *\n * @param adaptedProps\n */\nfunction restorePluggyConnectProps(adaptedProps) {\n    const { onErrorProp, onSuccessProp, onOpenProp, onCloseProp, onEventProp, onHideProp, } = adaptedProps;\n    // build original props object,\n    // starting from props without the unneeded ones,\n    // adding the ones we need.\n    return Object.assign(Object.assign({}, adaptedProps), { onError: onErrorProp, onSuccess: onSuccessProp, onOpen: onOpenProp, onClose: onCloseProp, onEvent: onEventProp, onHide: onHideProp });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvcHJvcHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0JBOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSx1QkFBdUIsQ0FDckMsS0FBaUM7SUFFakMsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDO0lBRXZFLGdFQUFnRTtJQUNoRSxNQUFNLGdCQUFnQixxQkFDakIsS0FBSyxDQUNULENBQUM7SUFDRiw2REFBNkQ7SUFDN0Qsd0NBQXdDO0lBQ3hDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDO0lBQ2hDLE9BQU8sZ0JBQWdCLENBQUMsU0FBUyxDQUFDO0lBQ2xDLE9BQU8sZ0JBQWdCLENBQUMsTUFBTSxDQUFDO0lBQy9CLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDO0lBQ2hDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDO0lBQ2hDLE9BQU8sZ0JBQWdCLENBQUMsTUFBTSxDQUFDO0lBRS9CLDhCQUE4QjtJQUM5QixpREFBaUQ7SUFDakQsMkJBQTJCO0lBQzNCLHVDQUNLLGdCQUFnQixLQUNuQixXQUFXLEVBQUUsT0FBTyxFQUNwQixhQUFhLEVBQUUsU0FBUyxFQUN4QixVQUFVLEVBQUUsTUFBTSxFQUNsQixXQUFXLEVBQUUsT0FBTyxFQUNwQixXQUFXLEVBQUUsT0FBTyxFQUNwQixVQUFVLEVBQUUsTUFBTSxJQUNsQjtBQUNKLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUseUJBQXlCLENBQ3ZDLFlBQXVDO0lBRXZDLE1BQU0sRUFDSixXQUFXLEVBQ1gsYUFBYSxFQUNiLFVBQVUsRUFDVixXQUFXLEVBQ1gsV0FBVyxFQUNYLFVBQVUsR0FDWCxHQUFHLFlBQVksQ0FBQztJQUVqQiwrQkFBK0I7SUFDL0IsaURBQWlEO0lBQ2pELDJCQUEyQjtJQUMzQix1Q0FDSyxZQUFZLEtBQ2YsT0FBTyxFQUFFLFdBQVcsRUFDcEIsU0FBUyxFQUFFLGFBQWEsRUFDeEIsTUFBTSxFQUFFLFVBQVUsRUFDbEIsT0FBTyxFQUFFLFdBQVcsRUFDcEIsT0FBTyxFQUFFLFdBQVcsRUFDcEIsTUFBTSxFQUFFLFVBQVUsSUFDbEI7QUFDSixDQUFDIn0=//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3V0aWxzL3Byb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksdURBQXVEO0FBQ25FO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCLG9JQUFvSTtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGdGQUFnRjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CLG9JQUFvSTtBQUNoTTtBQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3BsdWdneS1jb25uZWN0LXNkay9kaXN0L21vZHVsZS91dGlscy9wcm9wcy5qcz9mZmUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVyIHRvIHRyYW5zZm9ybSB1c2VyLXByb3ZpZGVkIHByb3BzIHZhbHVlcywgdG8gb3VyIG93blxuICogYWRhcHRlZCBwcm9wcyBvYmplY3QuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBab2lkIGNvbXBvbmVudCBwcm9wcy5cbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkYXB0UGx1Z2d5Q29ubmVjdFByb3BzKHByb3BzKSB7XG4gICAgY29uc3QgeyBvbkVycm9yLCBvblN1Y2Nlc3MsIG9uT3Blbiwgb25DbG9zZSwgb25FdmVudCwgb25IaWRlIH0gPSBwcm9wcztcbiAgICAvLyBjbG9uZSBvYmplY3QgYXMtaXMsIHRvIGV4cGxpY2l0bHkgZGVsZXRlIHVud2FudGVkIHByb3BzIGxhdGVyXG4gICAgY29uc3QgYWRhcHRlZFByb3BzQmFzZSA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcbiAgICAvLyByZW1vdmUgb25YWCBwcm9wcyBhcyBzb21lIG9mIHRoZW0gY29sbGlkZSB3aXRoIFpvaWQgcHJvcHMsXG4gICAgLy8gYXNzaWduIHRoZW0gdG8gZGlmZmVyZW50IGtleXMgaW5zdGVhZFxuICAgIGRlbGV0ZSBhZGFwdGVkUHJvcHNCYXNlLm9uRXJyb3I7XG4gICAgZGVsZXRlIGFkYXB0ZWRQcm9wc0Jhc2Uub25TdWNjZXNzO1xuICAgIGRlbGV0ZSBhZGFwdGVkUHJvcHNCYXNlLm9uT3BlbjtcbiAgICBkZWxldGUgYWRhcHRlZFByb3BzQmFzZS5vbkNsb3NlO1xuICAgIGRlbGV0ZSBhZGFwdGVkUHJvcHNCYXNlLm9uRXZlbnQ7XG4gICAgZGVsZXRlIGFkYXB0ZWRQcm9wc0Jhc2Uub25IaWRlO1xuICAgIC8vIGJ1aWxkIGFkYXB0ZWQgcHJvcHMgb2JqZWN0LFxuICAgIC8vIHN0YXJ0aW5nIGZyb20gcHJvcHMgd2l0aG91dCB0aGUgdW5uZWVkZWQgb25lcyxcbiAgICAvLyBhZGRpbmcgdGhlIG9uZXMgd2UgbmVlZC5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGFwdGVkUHJvcHNCYXNlKSwgeyBvbkVycm9yUHJvcDogb25FcnJvciwgb25TdWNjZXNzUHJvcDogb25TdWNjZXNzLCBvbk9wZW5Qcm9wOiBvbk9wZW4sIG9uQ2xvc2VQcm9wOiBvbkNsb3NlLCBvbkV2ZW50UHJvcDogb25FdmVudCwgb25IaWRlUHJvcDogb25IaWRlIH0pO1xufVxuLyoqXG4gKiBIZWxwZXIgdG8gdHJhbnNmb3JtIGFkYXB0ZWQgcHJvcHMgb2JqZWN0LCBiYWNrIGludG8gdXNlci1wcm92aWRlZCBwcm9wc1xuICogdmFsdWVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggWm9pZCBjb21wb25lbnQgcHJvcHMuXG4gKlxuICogQHBhcmFtIGFkYXB0ZWRQcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVBsdWdneUNvbm5lY3RQcm9wcyhhZGFwdGVkUHJvcHMpIHtcbiAgICBjb25zdCB7IG9uRXJyb3JQcm9wLCBvblN1Y2Nlc3NQcm9wLCBvbk9wZW5Qcm9wLCBvbkNsb3NlUHJvcCwgb25FdmVudFByb3AsIG9uSGlkZVByb3AsIH0gPSBhZGFwdGVkUHJvcHM7XG4gICAgLy8gYnVpbGQgb3JpZ2luYWwgcHJvcHMgb2JqZWN0LFxuICAgIC8vIHN0YXJ0aW5nIGZyb20gcHJvcHMgd2l0aG91dCB0aGUgdW5uZWVkZWQgb25lcyxcbiAgICAvLyBhZGRpbmcgdGhlIG9uZXMgd2UgbmVlZC5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGFwdGVkUHJvcHMpLCB7IG9uRXJyb3I6IG9uRXJyb3JQcm9wLCBvblN1Y2Nlc3M6IG9uU3VjY2Vzc1Byb3AsIG9uT3Blbjogb25PcGVuUHJvcCwgb25DbG9zZTogb25DbG9zZVByb3AsIG9uRXZlbnQ6IG9uRXZlbnRQcm9wLCBvbkhpZGU6IG9uSGlkZVByb3AgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljSEp2Y0hNdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTl6Y21NdmRYUnBiSE12Y0hKdmNITXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJa0ZCYTBKQk96czdPenM3UjBGTlJ6dEJRVU5JTEUxQlFVMHNWVUZCVlN4MVFrRkJkVUlzUTBGRGNrTXNTMEZCYVVNN1NVRkZha01zVFVGQlRTeEZRVUZGTEU5QlFVOHNSVUZCUlN4VFFVRlRMRVZCUVVVc1RVRkJUU3hGUVVGRkxFOUJRVThzUlVGQlJTeFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRWRCUVVjc1MwRkJTeXhEUVVGRE8wbEJSWFpGTEdkRlFVRm5SVHRKUVVOb1JTeE5RVUZOTEdkQ1FVRm5RaXh4UWtGRGFrSXNTMEZCU3l4RFFVTlVMRU5CUVVNN1NVRkRSaXcyUkVGQk5rUTdTVUZETjBRc2QwTkJRWGRETzBsQlEzaERMRTlCUVU4c1owSkJRV2RDTEVOQlFVTXNUMEZCVHl4RFFVRkRPMGxCUTJoRExFOUJRVThzWjBKQlFXZENMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRMnhETEU5QlFVOHNaMEpCUVdkQ0xFTkJRVU1zVFVGQlRTeERRVUZETzBsQlF5OUNMRTlCUVU4c1owSkJRV2RDTEVOQlFVTXNUMEZCVHl4RFFVRkRPMGxCUTJoRExFOUJRVThzWjBKQlFXZENMRU5CUVVNc1QwRkJUeXhEUVVGRE8wbEJRMmhETEU5QlFVOHNaMEpCUVdkQ0xFTkJRVU1zVFVGQlRTeERRVUZETzBsQlJTOUNMRGhDUVVFNFFqdEpRVU01UWl4cFJFRkJhVVE3U1VGRGFrUXNNa0pCUVRKQ08wbEJRek5DTEhWRFFVTkxMR2RDUVVGblFpeExRVU51UWl4WFFVRlhMRVZCUVVVc1QwRkJUeXhGUVVOd1FpeGhRVUZoTEVWQlFVVXNVMEZCVXl4RlFVTjRRaXhWUVVGVkxFVkJRVVVzVFVGQlRTeEZRVU5zUWl4WFFVRlhMRVZCUVVVc1QwRkJUeXhGUVVOd1FpeFhRVUZYTEVWQlFVVXNUMEZCVHl4RlFVTndRaXhWUVVGVkxFVkJRVVVzVFVGQlRTeEpRVU5zUWp0QlFVTktMRU5CUVVNN1FVRkZSRHM3T3pzN08wZEJUVWM3UVVGRFNDeE5RVUZOTEZWQlFWVXNlVUpCUVhsQ0xFTkJRM1pETEZsQlFYVkRPMGxCUlhaRExFMUJRVTBzUlVGRFNpeFhRVUZYTEVWQlExZ3NZVUZCWVN4RlFVTmlMRlZCUVZVc1JVRkRWaXhYUVVGWExFVkJRMWdzVjBGQlZ5eEZRVU5ZTEZWQlFWVXNSMEZEV0N4SFFVRkhMRmxCUVZrc1EwRkJRenRKUVVWcVFpd3JRa0ZCSzBJN1NVRkRMMElzYVVSQlFXbEVPMGxCUTJwRUxESkNRVUV5UWp0SlFVTXpRaXgxUTBGRFN5eFpRVUZaTEV0QlEyWXNUMEZCVHl4RlFVRkZMRmRCUVZjc1JVRkRjRUlzVTBGQlV5eEZRVUZGTEdGQlFXRXNSVUZEZUVJc1RVRkJUU3hGUVVGRkxGVkJRVlVzUlVGRGJFSXNUMEZCVHl4RlFVRkZMRmRCUVZjc1JVRkRjRUlzVDBGQlR5eEZRVUZGTEZkQlFWY3NSVUZEY0VJc1RVRkJUU3hGUVVGRkxGVkJRVlVzU1VGRGJFSTdRVUZEU2l4RFFVRkRJbjA9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/utils/props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/version.js":
/*!*****************************************************************!*\
  !*** ../node_modules/pluggy-connect-sdk/dist/module/version.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSdkVersion: function() { return /* binding */ getSdkVersion; }\n/* harmony export */ });\n// set project version to global window object.\n// This value must be updated manually to the *next* version, each time a new PR is submitted.\n// TODO: think of a way to auto-update this value in the build/prepublish process\nwindow.__PLUGGY_CONNECT_SDK_VERSION = '2.7.0';\n// use NPM modules package names as references for easier referenceability\nconst REACT_PLUGGY_CONNECT_PACKAGE_NAME = 'react-pluggy-connect';\nconst PLUGGY_CONNECT_PACKAGE_NAME = 'pluggy-connect-sdk';\n/**\n * Retrieve SDK versions from global window object\n *\n * @returns sdkVersion {string[]} - array of current sdks versions strings\n */\nfunction getSdkVersion() {\n    const { __PLUGGY_CONNECT_SDK_VERSION, __REACT_PLUGGY_CONNECT_SDK_VERSION, } = window;\n    const sdkVersion = [];\n    if (__REACT_PLUGGY_CONNECT_SDK_VERSION) {\n        const reactPluggyConnectSdkversion = `${REACT_PLUGGY_CONNECT_PACKAGE_NAME}@${__REACT_PLUGGY_CONNECT_SDK_VERSION}`;\n        sdkVersion.push(reactPluggyConnectSdkversion);\n    }\n    const pluggyConnectSdkVersion = `${PLUGGY_CONNECT_PACKAGE_NAME}@${__PLUGGY_CONNECT_SDK_VERSION}`;\n    sdkVersion.push(pluggyConnectSdkVersion);\n    return sdkVersion;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92ZXJzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLCtDQUErQztBQUMvQyw4RkFBOEY7QUFDOUYsaUZBQWlGO0FBQ2pGLE1BQU0sQ0FBQyw0QkFBNEIsR0FBRyxPQUFPLENBQUM7QUFFOUMsMEVBQTBFO0FBQzFFLE1BQU0saUNBQWlDLEdBQUcsc0JBQXNCLENBQUM7QUFDakUsTUFBTSwyQkFBMkIsR0FBRyxvQkFBb0IsQ0FBQztBQUV6RDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGFBQWE7SUFDM0IsTUFBTSxFQUNKLDRCQUE0QixFQUM1QixrQ0FBa0MsR0FDbkMsR0FBRyxNQUFNLENBQUM7SUFFWCxNQUFNLFVBQVUsR0FBYSxFQUFFLENBQUM7SUFFaEMsSUFBSSxrQ0FBa0MsRUFBRTtRQUN0QyxNQUFNLDRCQUE0QixHQUFHLEdBQUcsaUNBQWlDLElBQUksa0NBQWtDLEVBQUUsQ0FBQztRQUNsSCxVQUFVLENBQUMsSUFBSSxDQUFDLDRCQUE0QixDQUFDLENBQUM7S0FDL0M7SUFFRCxNQUFNLHVCQUF1QixHQUFHLEdBQUcsMkJBQTJCLElBQUksNEJBQTRCLEVBQUUsQ0FBQztJQUNqRyxVQUFVLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7SUFFekMsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQyJ9//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvcGx1Z2d5LWNvbm5lY3Qtc2RrL2Rpc3QvbW9kdWxlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDTztBQUNQLFlBQVksb0VBQW9FO0FBQ2hGO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQWtDLEdBQUcsbUNBQW1DO0FBQ3hIO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCLEdBQUcsNkJBQTZCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3BsdWdneS1jb25uZWN0LXNkay9kaXN0L21vZHVsZS92ZXJzaW9uLmpzPzljYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2V0IHByb2plY3QgdmVyc2lvbiB0byBnbG9iYWwgd2luZG93IG9iamVjdC5cbi8vIFRoaXMgdmFsdWUgbXVzdCBiZSB1cGRhdGVkIG1hbnVhbGx5IHRvIHRoZSAqbmV4dCogdmVyc2lvbiwgZWFjaCB0aW1lIGEgbmV3IFBSIGlzIHN1Ym1pdHRlZC5cbi8vIFRPRE86IHRoaW5rIG9mIGEgd2F5IHRvIGF1dG8tdXBkYXRlIHRoaXMgdmFsdWUgaW4gdGhlIGJ1aWxkL3ByZXB1Ymxpc2ggcHJvY2Vzc1xud2luZG93Ll9fUExVR0dZX0NPTk5FQ1RfU0RLX1ZFUlNJT04gPSAnMi43LjAnO1xuLy8gdXNlIE5QTSBtb2R1bGVzIHBhY2thZ2UgbmFtZXMgYXMgcmVmZXJlbmNlcyBmb3IgZWFzaWVyIHJlZmVyZW5jZWFiaWxpdHlcbmNvbnN0IFJFQUNUX1BMVUdHWV9DT05ORUNUX1BBQ0tBR0VfTkFNRSA9ICdyZWFjdC1wbHVnZ3ktY29ubmVjdCc7XG5jb25zdCBQTFVHR1lfQ09OTkVDVF9QQUNLQUdFX05BTUUgPSAncGx1Z2d5LWNvbm5lY3Qtc2RrJztcbi8qKlxuICogUmV0cmlldmUgU0RLIHZlcnNpb25zIGZyb20gZ2xvYmFsIHdpbmRvdyBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyBzZGtWZXJzaW9uIHtzdHJpbmdbXX0gLSBhcnJheSBvZiBjdXJyZW50IHNka3MgdmVyc2lvbnMgc3RyaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2RrVmVyc2lvbigpIHtcbiAgICBjb25zdCB7IF9fUExVR0dZX0NPTk5FQ1RfU0RLX1ZFUlNJT04sIF9fUkVBQ1RfUExVR0dZX0NPTk5FQ1RfU0RLX1ZFUlNJT04sIH0gPSB3aW5kb3c7XG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IFtdO1xuICAgIGlmIChfX1JFQUNUX1BMVUdHWV9DT05ORUNUX1NES19WRVJTSU9OKSB7XG4gICAgICAgIGNvbnN0IHJlYWN0UGx1Z2d5Q29ubmVjdFNka3ZlcnNpb24gPSBgJHtSRUFDVF9QTFVHR1lfQ09OTkVDVF9QQUNLQUdFX05BTUV9QCR7X19SRUFDVF9QTFVHR1lfQ09OTkVDVF9TREtfVkVSU0lPTn1gO1xuICAgICAgICBzZGtWZXJzaW9uLnB1c2gocmVhY3RQbHVnZ3lDb25uZWN0U2RrdmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IHBsdWdneUNvbm5lY3RTZGtWZXJzaW9uID0gYCR7UExVR0dZX0NPTk5FQ1RfUEFDS0FHRV9OQU1FfUAke19fUExVR0dZX0NPTk5FQ1RfU0RLX1ZFUlNJT059YDtcbiAgICBzZGtWZXJzaW9uLnB1c2gocGx1Z2d5Q29ubmVjdFNka1ZlcnNpb24pO1xuICAgIHJldHVybiBzZGtWZXJzaW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZG1WeWMybHZiaTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OTJaWEp6YVc5dUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVTlCTEN0RFFVRXJRenRCUVVNdlF5dzRSa0ZCT0VZN1FVRkRPVVlzYVVaQlFXbEdPMEZCUTJwR0xFMUJRVTBzUTBGQlF5dzBRa0ZCTkVJc1IwRkJSeXhQUVVGUExFTkJRVU03UVVGRk9VTXNNRVZCUVRCRk8wRkJRekZGTEUxQlFVMHNhVU5CUVdsRExFZEJRVWNzYzBKQlFYTkNMRU5CUVVNN1FVRkRha1VzVFVGQlRTd3lRa0ZCTWtJc1IwRkJSeXh2UWtGQmIwSXNRMEZCUXp0QlFVVjZSRHM3T3p0SFFVbEhPMEZCUTBnc1RVRkJUU3hWUVVGVkxHRkJRV0U3U1VGRE0wSXNUVUZCVFN4RlFVTktMRFJDUVVFMFFpeEZRVU0xUWl4clEwRkJhME1zUjBGRGJrTXNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkZXQ3hOUVVGTkxGVkJRVlVzUjBGQllTeEZRVUZGTEVOQlFVTTdTVUZGYUVNc1NVRkJTU3hyUTBGQmEwTXNSVUZCUlR0UlFVTjBReXhOUVVGTkxEUkNRVUUwUWl4SFFVRkhMRWRCUVVjc2FVTkJRV2xETEVsQlFVa3NhME5CUVd0RExFVkJRVVVzUTBGQlF6dFJRVU5zU0N4VlFVRlZMRU5CUVVNc1NVRkJTU3hEUVVGRExEUkNRVUUwUWl4RFFVRkRMRU5CUVVNN1MwRkRMME03U1VGRlJDeE5RVUZOTEhWQ1FVRjFRaXhIUVVGSExFZEJRVWNzTWtKQlFUSkNMRWxCUVVrc05FSkJRVFJDTEVWQlFVVXNRMEZCUXp0SlFVTnFSeXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEhWQ1FVRjFRaXhEUVVGRExFTkJRVU03U1VGRmVrTXNUMEZCVHl4VlFVRlZMRU5CUVVNN1FVRkRjRUlzUTBGQlF5SjkiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/zoid/dist/zoid.frameworks.frame.js":
/*!**********************************************************!*\
  !*** ../node_modules/zoid/dist/zoid.frameworks.frame.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n!function(root, factory) {\n     true ? module.exports = factory() : 0;\n}(\"undefined\" != typeof self ? self : this, (function() {\n    return function(modules) {\n        var installedModules = {};\n        function __nested_webpack_require_403__(moduleId) {\n            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n            var module = installedModules[moduleId] = {\n                i: moduleId,\n                l: !1,\n                exports: {}\n            };\n            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_403__);\n            module.l = !0;\n            return module.exports;\n        }\n        __nested_webpack_require_403__.m = modules;\n        __nested_webpack_require_403__.c = installedModules;\n        __nested_webpack_require_403__.d = function(exports, name, getter) {\n            __nested_webpack_require_403__.o(exports, name) || Object.defineProperty(exports, name, {\n                enumerable: !0,\n                get: getter\n            });\n        };\n        __nested_webpack_require_403__.r = function(exports) {\n            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n                value: \"Module\"\n            });\n            Object.defineProperty(exports, \"__esModule\", {\n                value: !0\n            });\n        };\n        __nested_webpack_require_403__.t = function(value, mode) {\n            1 & mode && (value = __nested_webpack_require_403__(value));\n            if (8 & mode) return value;\n            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n            var ns = Object.create(null);\n            __nested_webpack_require_403__.r(ns);\n            Object.defineProperty(ns, \"default\", {\n                enumerable: !0,\n                value: value\n            });\n            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_403__.d(ns, key, function(key) {\n                return value[key];\n            }.bind(null, key));\n            return ns;\n        };\n        __nested_webpack_require_403__.n = function(module) {\n            var getter = module && module.__esModule ? function() {\n                return module.default;\n            } : function() {\n                return module;\n            };\n            __nested_webpack_require_403__.d(getter, \"a\", getter);\n            return getter;\n        };\n        __nested_webpack_require_403__.o = function(object, property) {\n            return {}.hasOwnProperty.call(object, property);\n        };\n        __nested_webpack_require_403__.p = \"\";\n        return __nested_webpack_require_403__(__nested_webpack_require_403__.s = 0);\n    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_2811__) {\n        \"use strict\";\n        __nested_webpack_require_2811__.r(__nested_webpack_exports__);\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"PopupOpenError\", (function() {\n            return dom_PopupOpenError;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"create\", (function() {\n            return create;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"destroy\", (function() {\n            return component_destroy;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"destroyComponents\", (function() {\n            return destroyComponents;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"destroyAll\", (function() {\n            return destroyAll;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"PROP_TYPE\", (function() {\n            return PROP_TYPE;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"PROP_SERIALIZATION\", (function() {\n            return PROP_SERIALIZATION;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"CONTEXT\", (function() {\n            return CONTEXT;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"EVENT\", (function() {\n            return EVENT;\n        }));\n        function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n        }\n        function _extends() {\n            return (_extends = Object.assign || function(target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n                    for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);\n                }\n                return target;\n            }).apply(this, arguments);\n        }\n        function utils_isPromise(item) {\n            try {\n                if (!item) return !1;\n                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n                var _toString = {}.toString;\n                if (_toString) {\n                    var name = _toString.call(item);\n                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n                }\n                if (\"function\" == typeof item.then) return !0;\n            } catch (err) {\n                return !1;\n            }\n            return !1;\n        }\n        var dispatchedErrors = [];\n        var possiblyUnhandledPromiseHandlers = [];\n        var activeCount = 0;\n        var flushPromise;\n        function flushActive() {\n            if (!activeCount && flushPromise) {\n                var promise = flushPromise;\n                flushPromise = null;\n                promise.resolve();\n            }\n        }\n        function startActive() {\n            activeCount += 1;\n        }\n        function endActive() {\n            activeCount -= 1;\n            flushActive();\n        }\n        var promise_ZalgoPromise = function() {\n            function ZalgoPromise(handler) {\n                var _this = this;\n                this.resolved = void 0;\n                this.rejected = void 0;\n                this.errorHandled = void 0;\n                this.value = void 0;\n                this.error = void 0;\n                this.handlers = void 0;\n                this.dispatching = void 0;\n                this.stack = void 0;\n                this.resolved = !1;\n                this.rejected = !1;\n                this.errorHandled = !1;\n                this.handlers = [];\n                if (handler) {\n                    var _result;\n                    var _error;\n                    var resolved = !1;\n                    var rejected = !1;\n                    var isAsync = !1;\n                    startActive();\n                    try {\n                        handler((function(res) {\n                            if (isAsync) _this.resolve(res); else {\n                                resolved = !0;\n                                _result = res;\n                            }\n                        }), (function(err) {\n                            if (isAsync) _this.reject(err); else {\n                                rejected = !0;\n                                _error = err;\n                            }\n                        }));\n                    } catch (err) {\n                        endActive();\n                        this.reject(err);\n                        return;\n                    }\n                    endActive();\n                    isAsync = !0;\n                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n                }\n            }\n            var _proto = ZalgoPromise.prototype;\n            _proto.resolve = function(result) {\n                if (this.resolved || this.rejected) return this;\n                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n                this.resolved = !0;\n                this.value = result;\n                this.dispatch();\n                return this;\n            };\n            _proto.reject = function(error) {\n                var _this2 = this;\n                if (this.resolved || this.rejected) return this;\n                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n                if (!error) {\n                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n                }\n                this.rejected = !0;\n                this.error = error;\n                this.errorHandled || setTimeout((function() {\n                    _this2.errorHandled || function(err, promise) {\n                        if (-1 === dispatchedErrors.indexOf(err)) {\n                            dispatchedErrors.push(err);\n                            setTimeout((function() {\n                                throw err;\n                            }), 1);\n                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n                        }\n                    }(error, _this2);\n                }), 1);\n                this.dispatch();\n                return this;\n            };\n            _proto.asyncReject = function(error) {\n                this.errorHandled = !0;\n                this.reject(error);\n                return this;\n            };\n            _proto.dispatch = function() {\n                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n                if (!this.dispatching && (resolved || rejected)) {\n                    this.dispatching = !0;\n                    startActive();\n                    var chain = function(firstPromise, secondPromise) {\n                        return firstPromise.then((function(res) {\n                            secondPromise.resolve(res);\n                        }), (function(err) {\n                            secondPromise.reject(err);\n                        }));\n                    };\n                    for (var i = 0; i < handlers.length; i++) {\n                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n                        var _result2 = void 0;\n                        if (resolved) try {\n                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n                        } catch (err) {\n                            promise.reject(err);\n                            continue;\n                        } else if (rejected) {\n                            if (!onError) {\n                                promise.reject(this.error);\n                                continue;\n                            }\n                            try {\n                                _result2 = onError(this.error);\n                            } catch (err) {\n                                promise.reject(err);\n                                continue;\n                            }\n                        }\n                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n                            _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error);\n                            _result2.errorHandled = !0;\n                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n                    }\n                    handlers.length = 0;\n                    this.dispatching = !1;\n                    endActive();\n                }\n            };\n            _proto.then = function(onSuccess, onError) {\n                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n                var promise = new ZalgoPromise;\n                this.handlers.push({\n                    promise: promise,\n                    onSuccess: onSuccess,\n                    onError: onError\n                });\n                this.errorHandled = !0;\n                this.dispatch();\n                return promise;\n            };\n            _proto.catch = function(onError) {\n                return this.then(void 0, onError);\n            };\n            _proto.finally = function(onFinally) {\n                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n                return this.then((function(result) {\n                    return ZalgoPromise.try(onFinally).then((function() {\n                        return result;\n                    }));\n                }), (function(err) {\n                    return ZalgoPromise.try(onFinally).then((function() {\n                        throw err;\n                    }));\n                }));\n            };\n            _proto.timeout = function(time, err) {\n                var _this3 = this;\n                if (this.resolved || this.rejected) return this;\n                var timeout = setTimeout((function() {\n                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n                }), time);\n                return this.then((function(result) {\n                    clearTimeout(timeout);\n                    return result;\n                }));\n            };\n            _proto.toPromise = function() {\n                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n                return Promise.resolve(this);\n            };\n            ZalgoPromise.resolve = function(value) {\n                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n                    return value.then(resolve, reject);\n                })) : (new ZalgoPromise).resolve(value);\n            };\n            ZalgoPromise.reject = function(error) {\n                return (new ZalgoPromise).reject(error);\n            };\n            ZalgoPromise.asyncReject = function(error) {\n                return (new ZalgoPromise).asyncReject(error);\n            };\n            ZalgoPromise.all = function(promises) {\n                var promise = new ZalgoPromise;\n                var count = promises.length;\n                var results = [];\n                if (!count) {\n                    promise.resolve(results);\n                    return promise;\n                }\n                var chain = function(i, firstPromise, secondPromise) {\n                    return firstPromise.then((function(res) {\n                        results[i] = res;\n                        0 == (count -= 1) && promise.resolve(results);\n                    }), (function(err) {\n                        secondPromise.reject(err);\n                    }));\n                };\n                for (var i = 0; i < promises.length; i++) {\n                    var prom = promises[i];\n                    if (prom instanceof ZalgoPromise) {\n                        if (prom.resolved) {\n                            results[i] = prom.value;\n                            count -= 1;\n                            continue;\n                        }\n                    } else if (!utils_isPromise(prom)) {\n                        results[i] = prom;\n                        count -= 1;\n                        continue;\n                    }\n                    chain(i, ZalgoPromise.resolve(prom), promise);\n                }\n                0 === count && promise.resolve(results);\n                return promise;\n            };\n            ZalgoPromise.hash = function(promises) {\n                var result = {};\n                var awaitPromises = [];\n                var _loop = function(key) {\n                    if (promises.hasOwnProperty(key)) {\n                        var value = promises[key];\n                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n                            result[key] = res;\n                        }))) : result[key] = value;\n                    }\n                };\n                for (var key in promises) _loop(key);\n                return ZalgoPromise.all(awaitPromises).then((function() {\n                    return result;\n                }));\n            };\n            ZalgoPromise.map = function(items, method) {\n                return ZalgoPromise.all(items.map(method));\n            };\n            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n                return function(handler) {\n                    possiblyUnhandledPromiseHandlers.push(handler);\n                    return {\n                        cancel: function() {\n                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n                        }\n                    };\n                }(handler);\n            };\n            ZalgoPromise.try = function(method, context, args) {\n                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n                var result;\n                startActive();\n                try {\n                    result = method.apply(context, args || []);\n                } catch (err) {\n                    endActive();\n                    return ZalgoPromise.reject(err);\n                }\n                endActive();\n                return ZalgoPromise.resolve(result);\n            };\n            ZalgoPromise.delay = function(_delay) {\n                return new ZalgoPromise((function(resolve) {\n                    setTimeout(resolve, _delay);\n                }));\n            };\n            ZalgoPromise.isPromise = function(value) {\n                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n            };\n            ZalgoPromise.flush = function() {\n                return function(Zalgo) {\n                    var promise = flushPromise = flushPromise || new Zalgo;\n                    flushActive();\n                    return promise;\n                }(ZalgoPromise);\n            };\n            return ZalgoPromise;\n        }();\n        function isRegex(item) {\n            return \"[object RegExp]\" === {}.toString.call(item);\n        }\n        var WINDOW_TYPE = {\n            IFRAME: \"iframe\",\n            POPUP: \"popup\"\n        };\n        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n        function isAboutProtocol(win) {\n            void 0 === win && (win = window);\n            return \"about:\" === win.location.protocol;\n        }\n        function utils_getParent(win) {\n            void 0 === win && (win = window);\n            if (win) try {\n                if (win.parent && win.parent !== win) return win.parent;\n            } catch (err) {}\n        }\n        function getOpener(win) {\n            void 0 === win && (win = window);\n            if (win && !utils_getParent(win)) try {\n                return win.opener;\n            } catch (err) {}\n        }\n        function canReadFromWindow(win) {\n            try {\n                return !0;\n            } catch (err) {}\n            return !1;\n        }\n        function getActualDomain(win) {\n            void 0 === win && (win = window);\n            var location = win.location;\n            if (!location) throw new Error(\"Can not read window location\");\n            var protocol = location.protocol;\n            if (!protocol) throw new Error(\"Can not read window protocol\");\n            if (\"file:\" === protocol) return \"file://\";\n            if (\"about:\" === protocol) {\n                var parent = utils_getParent(win);\n                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n            }\n            var host = location.host;\n            if (!host) throw new Error(\"Can not read window host\");\n            return protocol + \"//\" + host;\n        }\n        function getDomain(win) {\n            void 0 === win && (win = window);\n            var domain = getActualDomain(win);\n            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n        }\n        function isSameDomain(win) {\n            if (!function(win) {\n                try {\n                    if (win === window) return !0;\n                } catch (err) {}\n                try {\n                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n                    if (desc && !1 === desc.enumerable) return !1;\n                } catch (err) {}\n                try {\n                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n                } catch (err) {}\n                try {\n                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n                } catch (err) {}\n                return !1;\n            }(win)) return !1;\n            try {\n                if (win === window) return !0;\n                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n                if (getDomain(window) === getDomain(win)) return !0;\n            } catch (err) {}\n            return !1;\n        }\n        function assertSameDomain(win) {\n            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n            return win;\n        }\n        function isAncestorParent(parent, child) {\n            if (!parent || !child) return !1;\n            var childParent = utils_getParent(child);\n            return childParent ? childParent === parent : -1 !== function(win) {\n                var result = [];\n                try {\n                    for (;win.parent !== win; ) {\n                        result.push(win.parent);\n                        win = win.parent;\n                    }\n                } catch (err) {}\n                return result;\n            }(child).indexOf(parent);\n        }\n        function getFrames(win) {\n            var result = [];\n            var frames;\n            try {\n                frames = win.frames;\n            } catch (err) {\n                frames = win;\n            }\n            var len;\n            try {\n                len = frames.length;\n            } catch (err) {}\n            if (0 === len) return result;\n            if (len) {\n                for (var i = 0; i < len; i++) {\n                    var frame = void 0;\n                    try {\n                        frame = frames[i];\n                    } catch (err) {\n                        continue;\n                    }\n                    result.push(frame);\n                }\n                return result;\n            }\n            for (var _i = 0; _i < 100; _i++) {\n                var _frame = void 0;\n                try {\n                    _frame = frames[_i];\n                } catch (err) {\n                    return result;\n                }\n                if (!_frame) return result;\n                result.push(_frame);\n            }\n            return result;\n        }\n        function getAllChildFrames(win) {\n            var result = [];\n            for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n                var frame = _getFrames2[_i3];\n                result.push(frame);\n                for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n            }\n            return result;\n        }\n        function getTop(win) {\n            void 0 === win && (win = window);\n            try {\n                if (win.top) return win.top;\n            } catch (err) {}\n            if (utils_getParent(win) === win) return win;\n            try {\n                if (isAncestorParent(window, win) && window.top) return window.top;\n            } catch (err) {}\n            try {\n                if (isAncestorParent(win, window) && window.top) return window.top;\n            } catch (err) {}\n            for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {\n                var frame = _getAllChildFrames4[_i7];\n                try {\n                    if (frame.top) return frame.top;\n                } catch (err) {}\n                if (utils_getParent(frame) === frame) return frame;\n            }\n        }\n        function getAllFramesInWindow(win) {\n            var top = getTop(win);\n            if (!top) throw new Error(\"Can not determine top window\");\n            var result = [].concat(getAllChildFrames(top), [ top ]);\n            -1 === result.indexOf(win) && (result = [].concat(result, [ win ], getAllChildFrames(win)));\n            return result;\n        }\n        var iframeWindows = [];\n        var iframeFrames = [];\n        function isWindowClosed(win, allowMock) {\n            void 0 === allowMock && (allowMock = !0);\n            try {\n                if (win === window) return !1;\n            } catch (err) {\n                return !0;\n            }\n            try {\n                if (!win) return !0;\n            } catch (err) {\n                return !0;\n            }\n            try {\n                if (win.closed) return !0;\n            } catch (err) {\n                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n            }\n            if (allowMock && isSameDomain(win)) try {\n                if (win.mockclosed) return !0;\n            } catch (err) {}\n            try {\n                if (!win.parent || !win.top) return !0;\n            } catch (err) {}\n            var iframeIndex = function(collection, item) {\n                for (var i = 0; i < collection.length; i++) try {\n                    if (collection[i] === item) return i;\n                } catch (err) {}\n                return -1;\n            }(iframeWindows, win);\n            if (-1 !== iframeIndex) {\n                var frame = iframeFrames[iframeIndex];\n                if (frame && function(frame) {\n                    if (!frame.contentWindow) return !0;\n                    if (!frame.parentNode) return !0;\n                    var doc = frame.ownerDocument;\n                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n                        var parent = frame;\n                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n                    }\n                    return !1;\n                }(frame)) return !0;\n            }\n            return !1;\n        }\n        function getAncestor(win) {\n            void 0 === win && (win = window);\n            return getOpener(win = win || window) || utils_getParent(win) || void 0;\n        }\n        function anyMatch(collection1, collection2) {\n            for (var _i17 = 0; _i17 < collection1.length; _i17++) {\n                var item1 = collection1[_i17];\n                for (var _i19 = 0; _i19 < collection2.length; _i19++) if (item1 === collection2[_i19]) return !0;\n            }\n            return !1;\n        }\n        function getDistanceFromTop(win) {\n            void 0 === win && (win = window);\n            var distance = 0;\n            var parent = win;\n            for (;parent; ) (parent = utils_getParent(parent)) && (distance += 1);\n            return distance;\n        }\n        function isSameTopWindow(win1, win2) {\n            var top1 = getTop(win1) || win1;\n            var top2 = getTop(win2) || win2;\n            try {\n                if (top1 && top2) return top1 === top2;\n            } catch (err) {}\n            var allFrames1 = getAllFramesInWindow(win1);\n            var allFrames2 = getAllFramesInWindow(win2);\n            if (anyMatch(allFrames1, allFrames2)) return !0;\n            var opener1 = getOpener(top1);\n            var opener2 = getOpener(top2);\n            return opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2) || opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1), \n            !1;\n        }\n        function matchDomain(pattern, origin) {\n            if (\"string\" == typeof pattern) {\n                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n                if (isRegex(origin)) return !1;\n                if (Array.isArray(origin)) return !1;\n            }\n            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n                return matchDomain(subpattern, origin);\n            })));\n        }\n        function getDomainFromUrl(url) {\n            return url.match(/^(https?|mock|file):\\/\\//) ? url.split(\"/\").slice(0, 3).join(\"/\") : getDomain();\n        }\n        function onCloseWindow(win, callback, delay, maxtime) {\n            void 0 === delay && (delay = 1e3);\n            void 0 === maxtime && (maxtime = 1 / 0);\n            var timeout;\n            !function check() {\n                if (isWindowClosed(win)) {\n                    timeout && clearTimeout(timeout);\n                    return callback();\n                }\n                if (maxtime <= 0) clearTimeout(timeout); else {\n                    maxtime -= delay;\n                    timeout = setTimeout(check, delay);\n                }\n            }();\n            return {\n                cancel: function() {\n                    timeout && clearTimeout(timeout);\n                }\n            };\n        }\n        function isWindow(obj) {\n            try {\n                if (obj === window) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (window.Window && obj instanceof window.Window) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && obj.self === obj) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && obj.parent === obj) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && obj.top === obj) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n            } catch (err) {\n                return !0;\n            }\n            try {\n                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n            } catch (err) {}\n            return !1;\n        }\n        function closeWindow(win) {\n            try {\n                win.close();\n            } catch (err) {}\n        }\n        function util_safeIndexOf(collection, item) {\n            for (var i = 0; i < collection.length; i++) try {\n                if (collection[i] === item) return i;\n            } catch (err) {}\n            return -1;\n        }\n        var weakmap_CrossDomainSafeWeakMap = function() {\n            function CrossDomainSafeWeakMap() {\n                this.name = void 0;\n                this.weakmap = void 0;\n                this.keys = void 0;\n                this.values = void 0;\n                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n                if (function() {\n                    if (\"undefined\" == typeof WeakMap) return !1;\n                    if (void 0 === Object.freeze) return !1;\n                    try {\n                        var testWeakMap = new WeakMap;\n                        var testKey = {};\n                        Object.freeze(testKey);\n                        testWeakMap.set(testKey, \"__testvalue__\");\n                        return \"__testvalue__\" === testWeakMap.get(testKey);\n                    } catch (err) {\n                        return !1;\n                    }\n                }()) try {\n                    this.weakmap = new WeakMap;\n                } catch (err) {}\n                this.keys = [];\n                this.values = [];\n            }\n            var _proto = CrossDomainSafeWeakMap.prototype;\n            _proto._cleanupClosedWindows = function() {\n                var weakmap = this.weakmap;\n                var keys = this.keys;\n                for (var i = 0; i < keys.length; i++) {\n                    var value = keys[i];\n                    if (isWindow(value) && isWindowClosed(value)) {\n                        if (weakmap) try {\n                            weakmap.delete(value);\n                        } catch (err) {}\n                        keys.splice(i, 1);\n                        this.values.splice(i, 1);\n                        i -= 1;\n                    }\n                }\n            };\n            _proto.isSafeToReadWrite = function(key) {\n                return !isWindow(key);\n            };\n            _proto.set = function(key, value) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    weakmap.set(key, value);\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var name = this.name;\n                    var entry = key[name];\n                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n                        value: [ key, value ],\n                        writable: !0\n                    });\n                    return;\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                var keys = this.keys;\n                var values = this.values;\n                var index = util_safeIndexOf(keys, key);\n                if (-1 === index) {\n                    keys.push(key);\n                    values.push(value);\n                } else values[index] = value;\n            };\n            _proto.get = function(key) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    if (weakmap.has(key)) return weakmap.get(key);\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var entry = key[this.name];\n                    return entry && entry[0] === key ? entry[1] : void 0;\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                var index = util_safeIndexOf(this.keys, key);\n                if (-1 !== index) return this.values[index];\n            };\n            _proto.delete = function(key) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    weakmap.delete(key);\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var entry = key[this.name];\n                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                var keys = this.keys;\n                var index = util_safeIndexOf(keys, key);\n                if (-1 !== index) {\n                    keys.splice(index, 1);\n                    this.values.splice(index, 1);\n                }\n            };\n            _proto.has = function(key) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    if (weakmap.has(key)) return !0;\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var entry = key[this.name];\n                    return !(!entry || entry[0] !== key);\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                return -1 !== util_safeIndexOf(this.keys, key);\n            };\n            _proto.getOrSet = function(key, getter) {\n                if (this.has(key)) return this.get(key);\n                var value = getter();\n                this.set(key, value);\n                return value;\n            };\n            return CrossDomainSafeWeakMap;\n        }();\n        function _getPrototypeOf(o) {\n            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {\n                return o.__proto__ || Object.getPrototypeOf(o);\n            })(o);\n        }\n        function _setPrototypeOf(o, p) {\n            return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {\n                o.__proto__ = p;\n                return o;\n            })(o, p);\n        }\n        function _isNativeReflectConstruct() {\n            if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n            if (Reflect.construct.sham) return !1;\n            if (\"function\" == typeof Proxy) return !0;\n            try {\n                Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));\n                return !0;\n            } catch (e) {\n                return !1;\n            }\n        }\n        function construct_construct(Parent, args, Class) {\n            return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {\n                var a = [ null ];\n                a.push.apply(a, args);\n                var instance = new (Function.bind.apply(Parent, a));\n                Class && _setPrototypeOf(instance, Class.prototype);\n                return instance;\n            }).apply(null, arguments);\n        }\n        function wrapNativeSuper_wrapNativeSuper(Class) {\n            var _cache = \"function\" == typeof Map ? new Map : void 0;\n            return (wrapNativeSuper_wrapNativeSuper = function(Class) {\n                if (null === Class || !(fn = Class, -1 !== Function.toString.call(fn).indexOf(\"[native code]\"))) return Class;\n                var fn;\n                if (\"function\" != typeof Class) throw new TypeError(\"Super expression must either be null or a function\");\n                if (void 0 !== _cache) {\n                    if (_cache.has(Class)) return _cache.get(Class);\n                    _cache.set(Class, Wrapper);\n                }\n                function Wrapper() {\n                    return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);\n                }\n                Wrapper.prototype = Object.create(Class.prototype, {\n                    constructor: {\n                        value: Wrapper,\n                        enumerable: !1,\n                        writable: !0,\n                        configurable: !0\n                    }\n                });\n                return _setPrototypeOf(Wrapper, Class);\n            })(Class);\n        }\n        function getFunctionName(fn) {\n            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n        }\n        function setFunctionName(fn, name) {\n            try {\n                delete fn.name;\n                fn.name = name;\n            } catch (err) {}\n            fn.__name__ = fn.displayName = name;\n            return fn;\n        }\n        function base64encode(str) {\n            if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n                return String.fromCharCode(parseInt(p1, 16));\n            })));\n            if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\");\n            throw new Error(\"Can not find window.btoa or Buffer\");\n        }\n        function uniqueID() {\n            var chars = \"0123456789abcdef\";\n            return \"xxxxxxxxxx\".replace(/./g, (function() {\n                return chars.charAt(Math.floor(Math.random() * chars.length));\n            })) + \"_\" + base64encode((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n        }\n        var objectIDs;\n        function serializeArgs(args) {\n            try {\n                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n                        var uid = objectIDs.get(obj);\n                        if (!uid) {\n                            uid = typeof obj + \":\" + uniqueID();\n                            objectIDs.set(obj, uid);\n                        }\n                        return uid;\n                    }(val) + \"]\" : val;\n                }));\n            } catch (err) {\n                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n            }\n        }\n        function getEmptyObject() {\n            return {};\n        }\n        var memoizeGlobalIndex = 0;\n        var memoizeGlobalIndexValidFrom = 0;\n        function memoize(method, options) {\n            void 0 === options && (options = {});\n            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n            var simpleCache;\n            var thisCache;\n            var memoizeIndex = memoizeGlobalIndex;\n            memoizeGlobalIndex += 1;\n            var memoizedFunction = function() {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n                    simpleCache = null;\n                    thisCache = null;\n                    memoizeIndex = memoizeGlobalIndex;\n                    memoizeGlobalIndex += 1;\n                }\n                var cache;\n                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n                var cacheKey = serializeArgs(args);\n                var cacheResult = cache[cacheKey];\n                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n                    delete cache[cacheKey];\n                    cacheResult = null;\n                }\n                if (cacheResult) return cacheResult.value;\n                var time = Date.now();\n                var value = method.apply(this, arguments);\n                cache[cacheKey] = {\n                    time: time,\n                    value: value\n                };\n                return value;\n            };\n            memoizedFunction.reset = function() {\n                simpleCache = null;\n                thisCache = null;\n            };\n            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n        }\n        memoize.clear = function() {\n            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n        };\n        function memoizePromise(method) {\n            var cache = {};\n            function memoizedPromiseFunction() {\n                var _arguments = arguments, _this = this;\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n                var key = serializeArgs(args);\n                if (cache.hasOwnProperty(key)) return cache[key];\n                cache[key] = promise_ZalgoPromise.try((function() {\n                    return method.apply(_this, _arguments);\n                })).finally((function() {\n                    delete cache[key];\n                }));\n                return cache[key];\n            }\n            memoizedPromiseFunction.reset = function() {\n                cache = {};\n            };\n            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n        }\n        function inlineMemoize(method, logic, args) {\n            void 0 === args && (args = []);\n            var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};\n            var key = serializeArgs(args);\n            return cache.hasOwnProperty(key) ? cache[key] : cache[key] = logic.apply(void 0, args);\n        }\n        function src_util_noop() {}\n        function once(method) {\n            var called = !1;\n            return setFunctionName((function() {\n                if (!called) {\n                    called = !0;\n                    return method.apply(this, arguments);\n                }\n            }), getFunctionName(method) + \"::once\");\n        }\n        function stringifyError(err, level) {\n            void 0 === level && (level = 1);\n            if (level >= 3) return \"stringifyError stack overflow\";\n            try {\n                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n                if (\"string\" == typeof err) return err;\n                if (err instanceof Error) {\n                    var stack = err && err.stack;\n                    var message = err && err.message;\n                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n                    if (stack) return stack;\n                    if (message) return message;\n                }\n                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n            } catch (newErr) {\n                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n            }\n        }\n        function stringify(item) {\n            return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n        }\n        function extend(obj, source) {\n            if (!source) return obj;\n            if (Object.assign) return Object.assign(obj, source);\n            for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);\n            return obj;\n        }\n        memoize((function(obj) {\n            if (Object.values) return Object.values(obj);\n            var result = [];\n            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n            return result;\n        }));\n        function identity(item) {\n            return item;\n        }\n        function safeInterval(method, time) {\n            var timeout;\n            !function loop() {\n                timeout = setTimeout((function() {\n                    method();\n                    loop();\n                }), time);\n            }();\n            return {\n                cancel: function() {\n                    clearTimeout(timeout);\n                }\n            };\n        }\n        function defineLazyProp(obj, key, getter) {\n            if (Array.isArray(obj)) {\n                if (\"number\" != typeof key) throw new TypeError(\"Array key must be number\");\n            } else if (\"object\" == typeof obj && null !== obj && \"string\" != typeof key) throw new TypeError(\"Object key must be string\");\n            Object.defineProperty(obj, key, {\n                configurable: !0,\n                enumerable: !0,\n                get: function() {\n                    delete obj[key];\n                    var value = getter();\n                    obj[key] = value;\n                    return value;\n                },\n                set: function(value) {\n                    delete obj[key];\n                    obj[key] = value;\n                }\n            });\n        }\n        function arrayFrom(item) {\n            return [].slice.call(item);\n        }\n        function isObjectObject(obj) {\n            return \"object\" == typeof (item = obj) && null !== item && \"[object Object]\" === {}.toString.call(obj);\n            var item;\n        }\n        function isPlainObject(obj) {\n            if (!isObjectObject(obj)) return !1;\n            var constructor = obj.constructor;\n            if (\"function\" != typeof constructor) return !1;\n            var prototype = constructor.prototype;\n            return !!isObjectObject(prototype) && !!prototype.hasOwnProperty(\"isPrototypeOf\");\n        }\n        function replaceObject(item, replacer, fullKey) {\n            void 0 === fullKey && (fullKey = \"\");\n            if (Array.isArray(item)) {\n                var length = item.length;\n                var result = [];\n                var _loop2 = function(i) {\n                    defineLazyProp(result, i, (function() {\n                        var itemKey = fullKey ? fullKey + \".\" + i : \"\" + i;\n                        var child = replacer(item[i], i, itemKey);\n                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));\n                        return child;\n                    }));\n                };\n                for (var i = 0; i < length; i++) _loop2(i);\n                return result;\n            }\n            if (isPlainObject(item)) {\n                var _result = {};\n                var _loop3 = function(key) {\n                    if (!item.hasOwnProperty(key)) return \"continue\";\n                    defineLazyProp(_result, key, (function() {\n                        var itemKey = fullKey ? fullKey + \".\" + key : \"\" + key;\n                        var child = replacer(item[key], key, itemKey);\n                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));\n                        return child;\n                    }));\n                };\n                for (var key in item) _loop3(key);\n                return _result;\n            }\n            throw new Error(\"Pass an object or array\");\n        }\n        function isDefined(value) {\n            return null != value;\n        }\n        function util_isRegex(item) {\n            return \"[object RegExp]\" === {}.toString.call(item);\n        }\n        function util_getOrSet(obj, key, getter) {\n            if (obj.hasOwnProperty(key)) return obj[key];\n            var val = getter();\n            obj[key] = val;\n            return val;\n        }\n        function cleanup(obj) {\n            var tasks = [];\n            var cleaned = !1;\n            var cleanErr;\n            return {\n                set: function(name, item) {\n                    if (!cleaned) {\n                        obj[name] = item;\n                        this.register((function() {\n                            delete obj[name];\n                        }));\n                    }\n                    return item;\n                },\n                register: function(method) {\n                    cleaned ? method(cleanErr) : tasks.push(once((function() {\n                        return method(cleanErr);\n                    })));\n                },\n                all: function(err) {\n                    cleanErr = err;\n                    var results = [];\n                    cleaned = !0;\n                    for (;tasks.length; ) {\n                        var task = tasks.shift();\n                        results.push(task());\n                    }\n                    return promise_ZalgoPromise.all(results).then(src_util_noop);\n                }\n            };\n        }\n        function assertExists(name, thing) {\n            if (null == thing) throw new Error(\"Expected \" + name + \" to be present\");\n            return thing;\n        }\n        var util_ExtendableError = function(_Error) {\n            _inheritsLoose(ExtendableError, _Error);\n            function ExtendableError(message) {\n                var _this6;\n                (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;\n                \"function\" == typeof Error.captureStackTrace ? Error.captureStackTrace(function(self) {\n                    if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                    return self;\n                }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;\n                return _this6;\n            }\n            return ExtendableError;\n        }(wrapNativeSuper_wrapNativeSuper(Error));\n        function isDocumentReady() {\n            return Boolean(document.body) && \"complete\" === document.readyState;\n        }\n        function isDocumentInteractive() {\n            return Boolean(document.body) && \"interactive\" === document.readyState;\n        }\n        function urlEncode(str) {\n            return str.replace(/\\?/g, \"%3F\").replace(/&/g, \"%26\").replace(/#/g, \"%23\").replace(/\\+/g, \"%2B\");\n        }\n        memoize((function() {\n            return new promise_ZalgoPromise((function(resolve) {\n                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n                var interval = setInterval((function() {\n                    if (isDocumentReady() || isDocumentInteractive()) {\n                        clearInterval(interval);\n                        return resolve();\n                    }\n                }), 10);\n            }));\n        }));\n        function parseQuery(queryString) {\n            return inlineMemoize(parseQuery, (function() {\n                var params = {};\n                if (!queryString) return params;\n                if (-1 === queryString.indexOf(\"=\")) return params;\n                for (var _i2 = 0, _queryString$split2 = queryString.split(\"&\"); _i2 < _queryString$split2.length; _i2++) {\n                    var pair = _queryString$split2[_i2];\n                    (pair = pair.split(\"=\"))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));\n                }\n                return params;\n            }), [ queryString ]);\n        }\n        function extendQuery(originalQuery, props) {\n            void 0 === props && (props = {});\n            return props && Object.keys(props).length ? function(obj) {\n                void 0 === obj && (obj = {});\n                return Object.keys(obj).filter((function(key) {\n                    return \"string\" == typeof obj[key];\n                })).map((function(key) {\n                    return urlEncode(key) + \"=\" + urlEncode(obj[key]);\n                })).join(\"&\");\n            }(_extends({}, parseQuery(originalQuery), props)) : originalQuery;\n        }\n        function appendChild(container, child) {\n            container.appendChild(child);\n        }\n        function isElement(element) {\n            return element instanceof window.Element || null !== element && \"object\" == typeof element && 1 === element.nodeType && \"object\" == typeof element.style && \"object\" == typeof element.ownerDocument;\n        }\n        function getElementSafe(id, doc) {\n            void 0 === doc && (doc = document);\n            return isElement(id) ? id : \"string\" == typeof id ? doc.querySelector(id) : void 0;\n        }\n        function elementReady(id) {\n            return new promise_ZalgoPromise((function(resolve, reject) {\n                var name = stringify(id);\n                var el = getElementSafe(id);\n                if (el) return resolve(el);\n                if (isDocumentReady()) return reject(new Error(\"Document is ready and element \" + name + \" does not exist\"));\n                var interval = setInterval((function() {\n                    if (el = getElementSafe(id)) {\n                        clearInterval(interval);\n                        return resolve(el);\n                    }\n                    if (isDocumentReady()) {\n                        clearInterval(interval);\n                        return reject(new Error(\"Document is ready and element \" + name + \" does not exist\"));\n                    }\n                }), 10);\n            }));\n        }\n        var dom_PopupOpenError = function(_ExtendableError) {\n            _inheritsLoose(PopupOpenError, _ExtendableError);\n            function PopupOpenError() {\n                return _ExtendableError.apply(this, arguments) || this;\n            }\n            return PopupOpenError;\n        }(util_ExtendableError);\n        var awaitFrameLoadPromises;\n        function awaitFrameLoad(frame) {\n            if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new weakmap_CrossDomainSafeWeakMap).has(frame)) {\n                var _promise = awaitFrameLoadPromises.get(frame);\n                if (_promise) return _promise;\n            }\n            var promise = new promise_ZalgoPromise((function(resolve, reject) {\n                frame.addEventListener(\"load\", (function() {\n                    !function(frame) {\n                        !function() {\n                            for (var i = 0; i < iframeWindows.length; i++) {\n                                var closed = !1;\n                                try {\n                                    closed = iframeWindows[i].closed;\n                                } catch (err) {}\n                                if (closed) {\n                                    iframeFrames.splice(i, 1);\n                                    iframeWindows.splice(i, 1);\n                                }\n                            }\n                        }();\n                        if (frame && frame.contentWindow) try {\n                            iframeWindows.push(frame.contentWindow);\n                            iframeFrames.push(frame);\n                        } catch (err) {}\n                    }(frame);\n                    resolve(frame);\n                }));\n                frame.addEventListener(\"error\", (function(err) {\n                    frame.contentWindow ? resolve(frame) : reject(err);\n                }));\n            }));\n            awaitFrameLoadPromises.set(frame, promise);\n            return promise;\n        }\n        function awaitFrameWindow(frame) {\n            return awaitFrameLoad(frame).then((function(loadedFrame) {\n                if (!loadedFrame.contentWindow) throw new Error(\"Could not find window in iframe\");\n                return loadedFrame.contentWindow;\n            }));\n        }\n        function dom_iframe(options, container) {\n            void 0 === options && (options = {});\n            var style = options.style || {};\n            var frame = function(tag, options, container) {\n                void 0 === tag && (tag = \"div\");\n                void 0 === options && (options = {});\n                tag = tag.toLowerCase();\n                var element = document.createElement(tag);\n                options.style && extend(element.style, options.style);\n                options.class && (element.className = options.class.join(\" \"));\n                options.id && element.setAttribute(\"id\", options.id);\n                if (options.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options.attributes); _i10 < _Object$keys2.length; _i10++) {\n                    var key = _Object$keys2[_i10];\n                    element.setAttribute(key, options.attributes[key]);\n                }\n                options.styleSheet && function(el, styleText, doc) {\n                    void 0 === doc && (doc = window.document);\n                    el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));\n                }(element, options.styleSheet);\n                if (options.html) {\n                    if (\"iframe\" === tag) throw new Error(\"Iframe html can not be written unless container provided and iframe in DOM\");\n                    element.innerHTML = options.html;\n                }\n                return element;\n            }(\"iframe\", {\n                attributes: _extends({\n                    allowTransparency: \"true\"\n                }, options.attributes || {}),\n                style: _extends({\n                    backgroundColor: \"transparent\",\n                    border: \"none\"\n                }, style),\n                html: options.html,\n                class: options.class\n            });\n            var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);\n            frame.hasAttribute(\"id\") || frame.setAttribute(\"id\", uniqueID());\n            awaitFrameLoad(frame);\n            container && function(id, doc) {\n                void 0 === doc && (doc = document);\n                var element = getElementSafe(id, doc);\n                if (element) return element;\n                throw new Error(\"Can not find element: \" + stringify(id));\n            }(container).appendChild(frame);\n            (options.url || isIE) && frame.setAttribute(\"src\", options.url || \"about:blank\");\n            return frame;\n        }\n        function addEventListener(obj, event, handler) {\n            obj.addEventListener(event, handler);\n            return {\n                cancel: function() {\n                    obj.removeEventListener(event, handler);\n                }\n            };\n        }\n        function showElement(element) {\n            element.style.setProperty(\"display\", \"\");\n        }\n        function hideElement(element) {\n            element.style.setProperty(\"display\", \"none\", \"important\");\n        }\n        function destroyElement(element) {\n            element && element.parentNode && element.parentNode.removeChild(element);\n        }\n        function isElementClosed(el) {\n            return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));\n        }\n        function onResize(el, handler, _temp) {\n            var _ref2 = void 0 === _temp ? {} : _temp, _ref2$width = _ref2.width, width = void 0 === _ref2$width || _ref2$width, _ref2$height = _ref2.height, height = void 0 === _ref2$height || _ref2$height, _ref2$interval = _ref2.interval, interval = void 0 === _ref2$interval ? 100 : _ref2$interval, _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win;\n            var currentWidth = el.offsetWidth;\n            var currentHeight = el.offsetHeight;\n            var canceled = !1;\n            handler({\n                width: currentWidth,\n                height: currentHeight\n            });\n            var check = function() {\n                if (!canceled && function(el) {\n                    return Boolean(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n                }(el)) {\n                    var newWidth = el.offsetWidth;\n                    var newHeight = el.offsetHeight;\n                    (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({\n                        width: newWidth,\n                        height: newHeight\n                    });\n                    currentWidth = newWidth;\n                    currentHeight = newHeight;\n                }\n            };\n            var observer;\n            var timeout;\n            win.addEventListener(\"resize\", check);\n            if (void 0 !== win.ResizeObserver) {\n                (observer = new win.ResizeObserver(check)).observe(el);\n                timeout = safeInterval(check, 10 * interval);\n            } else if (void 0 !== win.MutationObserver) {\n                (observer = new win.MutationObserver(check)).observe(el, {\n                    attributes: !0,\n                    childList: !0,\n                    subtree: !0,\n                    characterData: !1\n                });\n                timeout = safeInterval(check, 10 * interval);\n            } else timeout = safeInterval(check, interval);\n            return {\n                cancel: function() {\n                    canceled = !0;\n                    observer.disconnect();\n                    window.removeEventListener(\"resize\", check);\n                    timeout.cancel();\n                }\n            };\n        }\n        function isShadowElement(element) {\n            for (;element.parentNode; ) element = element.parentNode;\n            return \"[object ShadowRoot]\" === element.toString();\n        }\n        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n        var getCurrentScript = memoize((function() {\n            if (currentScript) return currentScript;\n            if (currentScript = function() {\n                try {\n                    var stack = function() {\n                        try {\n                            throw new Error(\"_\");\n                        } catch (err) {\n                            return err.stack || \"\";\n                        }\n                    }();\n                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n                    var scriptLocation = stackDetails && stackDetails[1];\n                    if (!scriptLocation) return;\n                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n                        var script = _Array$prototype$slic2[_i22];\n                        if (script.src && script.src === scriptLocation) return script;\n                    }\n                } catch (err) {}\n            }()) return currentScript;\n            throw new Error(\"Can not determine current script\");\n        }));\n        var currentUID = uniqueID();\n        memoize((function() {\n            var script;\n            try {\n                script = getCurrentScript();\n            } catch (err) {\n                return currentUID;\n            }\n            var uid = script.getAttribute(\"data-uid\");\n            if (uid && \"string\" == typeof uid) return uid;\n            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n            uid = uniqueID();\n            script.setAttribute(\"data-uid-auto\", uid);\n            return uid;\n        }));\n        function toPx(val) {\n            return function(val) {\n                if (\"number\" == typeof val) return val;\n                var match = val.match(/^([0-9]+)(px|%)$/);\n                if (!match) throw new Error(\"Could not match css value from \" + val);\n                return parseInt(match[1], 10);\n            }(val) + \"px\";\n        }\n        function toCSS(val) {\n            return \"number\" == typeof val ? toPx(val) : \"string\" == typeof (str = val) && /^[0-9]+%$/.test(str) ? val : toPx(val);\n            var str;\n        }\n        function global_getGlobal(win) {\n            void 0 === win && (win = window);\n            var globalKey = \"__post_robot_10_0_42__\";\n            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n        }\n        var getObj = function() {\n            return {};\n        };\n        function globalStore(key, defStore) {\n            void 0 === key && (key = \"store\");\n            void 0 === defStore && (defStore = getObj);\n            return util_getOrSet(global_getGlobal(), key, (function() {\n                var store = defStore();\n                return {\n                    has: function(storeKey) {\n                        return store.hasOwnProperty(storeKey);\n                    },\n                    get: function(storeKey, defVal) {\n                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n                    },\n                    set: function(storeKey, val) {\n                        store[storeKey] = val;\n                        return val;\n                    },\n                    del: function(storeKey) {\n                        delete store[storeKey];\n                    },\n                    getOrSet: function(storeKey, getter) {\n                        return util_getOrSet(store, storeKey, getter);\n                    },\n                    reset: function() {\n                        store = defStore();\n                    },\n                    keys: function() {\n                        return Object.keys(store);\n                    }\n                };\n            }));\n        }\n        var WildCard = function() {};\n        function getWildcard() {\n            var global = global_getGlobal();\n            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n            return global.WINDOW_WILDCARD;\n        }\n        function windowStore(key, defStore) {\n            void 0 === key && (key = \"store\");\n            void 0 === defStore && (defStore = getObj);\n            return globalStore(\"windowStore\").getOrSet(key, (function() {\n                var winStore = new weakmap_CrossDomainSafeWeakMap;\n                var getStore = function(win) {\n                    return winStore.getOrSet(win, defStore);\n                };\n                return {\n                    has: function(win) {\n                        return getStore(win).hasOwnProperty(key);\n                    },\n                    get: function(win, defVal) {\n                        var store = getStore(win);\n                        return store.hasOwnProperty(key) ? store[key] : defVal;\n                    },\n                    set: function(win, val) {\n                        getStore(win)[key] = val;\n                        return val;\n                    },\n                    del: function(win) {\n                        delete getStore(win)[key];\n                    },\n                    getOrSet: function(win, getter) {\n                        return util_getOrSet(getStore(win), key, getter);\n                    }\n                };\n            }));\n        }\n        function getInstanceID() {\n            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n        }\n        function resolveHelloPromise(win, _ref) {\n            var domain = _ref.domain;\n            var helloPromises = windowStore(\"helloPromises\");\n            var existingPromise = helloPromises.get(win);\n            existingPromise && existingPromise.resolve({\n                domain: domain\n            });\n            var newPromise = promise_ZalgoPromise.resolve({\n                domain: domain\n            });\n            helloPromises.set(win, newPromise);\n            return newPromise;\n        }\n        function sayHello(win, _ref4) {\n            return (0, _ref4.send)(win, \"postrobot_hello\", {\n                instanceID: getInstanceID()\n            }, {\n                domain: \"*\",\n                timeout: -1\n            }).then((function(_ref5) {\n                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n                resolveHelloPromise(win, {\n                    domain: origin\n                });\n                return {\n                    win: win,\n                    domain: origin,\n                    instanceID: instanceID\n                };\n            }));\n        }\n        function getWindowInstanceID(win, _ref6) {\n            var send = _ref6.send;\n            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n                return sayHello(win, {\n                    send: send\n                }).then((function(_ref7) {\n                    return _ref7.instanceID;\n                }));\n            }));\n        }\n        function markWindowKnown(win) {\n            windowStore(\"knownWindows\").set(win, !0);\n        }\n        function isSerializedType(item) {\n            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n        }\n        function determineType(val) {\n            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n        }\n        function serializeType(type, val) {\n            return {\n                __type__: type,\n                __val__: val\n            };\n        }\n        var _SERIALIZER;\n        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n            return serializeType(\"error\", {\n                message: _ref.message,\n                stack: _ref.stack,\n                code: _ref.code,\n                data: _ref.data\n            });\n        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n            return serializeType(\"regex\", val.source);\n        }, _SERIALIZER.date = function(val) {\n            return serializeType(\"date\", val.toJSON());\n        }, _SERIALIZER.array = function(val) {\n            return val;\n        }, _SERIALIZER.object = function(val) {\n            return val;\n        }, _SERIALIZER.string = function(val) {\n            return val;\n        }, _SERIALIZER.number = function(val) {\n            return val;\n        }, _SERIALIZER.boolean = function(val) {\n            return val;\n        }, _SERIALIZER.null = function(val) {\n            return val;\n        }, _SERIALIZER);\n        var defaultSerializers = {};\n        var _DESERIALIZER;\n        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n        }, _DESERIALIZER.error = function(_ref2) {\n            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n            var error = new Error(_ref2.message);\n            error.code = code;\n            data && (error.data = data);\n            error.stack = stack + \"\\n\\n\" + error.stack;\n            return error;\n        }, _DESERIALIZER.promise = function() {\n            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n        }, _DESERIALIZER.regex = function(val) {\n            return new RegExp(val);\n        }, _DESERIALIZER.date = function(val) {\n            return new Date(val);\n        }, _DESERIALIZER.array = function(val) {\n            return val;\n        }, _DESERIALIZER.object = function(val) {\n            return val;\n        }, _DESERIALIZER.string = function(val) {\n            return val;\n        }, _DESERIALIZER.number = function(val) {\n            return val;\n        }, _DESERIALIZER.boolean = function(val) {\n            return val;\n        }, _DESERIALIZER.null = function(val) {\n            return val;\n        }, _DESERIALIZER);\n        var defaultDeserializers = {};\n        new promise_ZalgoPromise((function(resolve) {\n            if (window.document && window.document.body) return resolve(window.document.body);\n            var interval = setInterval((function() {\n                if (window.document && window.document.body) {\n                    clearInterval(interval);\n                    return resolve(window.document.body);\n                }\n            }), 10);\n        }));\n        function cleanupProxyWindows() {\n            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n                var id = _idToProxyWindow$keys2[_i2];\n                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n            }\n        }\n        function getSerializedWindow(winPromise, _ref) {\n            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n            var windowNamePromise = winPromise.then((function(win) {\n                if (isSameDomain(win)) return assertSameDomain(win).name;\n            }));\n            var windowTypePromise = winPromise.then((function(window) {\n                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n                return getOpener(window) ? WINDOW_TYPE.POPUP : WINDOW_TYPE.IFRAME;\n            }));\n            windowNamePromise.catch(src_util_noop);\n            windowTypePromise.catch(src_util_noop);\n            return {\n                id: id,\n                getType: function() {\n                    return windowTypePromise;\n                },\n                getInstanceID: memoizePromise((function() {\n                    return winPromise.then((function(win) {\n                        return getWindowInstanceID(win, {\n                            send: send\n                        });\n                    }));\n                })),\n                close: function() {\n                    return winPromise.then(closeWindow);\n                },\n                getName: function() {\n                    return winPromise.then((function(win) {\n                        if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n                    }));\n                },\n                focus: function() {\n                    return winPromise.then((function(win) {\n                        win.focus();\n                    }));\n                },\n                isClosed: function() {\n                    return winPromise.then((function(win) {\n                        return isWindowClosed(win);\n                    }));\n                },\n                setLocation: function(href) {\n                    return winPromise.then((function(win) {\n                        var domain = window.location.protocol + \"//\" + window.location.host;\n                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n                        if (isSameDomain(win)) try {\n                            if (win.location && \"function\" == typeof win.location.replace) {\n                                win.location.replace(href);\n                                return;\n                            }\n                        } catch (err) {}\n                        win.location = href;\n                    }));\n                },\n                setName: function(name) {\n                    return winPromise.then((function(win) {\n                        var sameDomain = isSameDomain(win);\n                        var frame = function(win) {\n                            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n                            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n                                var frame = _document$querySelect2[_i21];\n                                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n                            }\n                        }(win);\n                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n                        assertSameDomain(win).name = name;\n                        frame && frame.setAttribute(\"name\", name);\n                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n                    }));\n                }\n            };\n        }\n        var window_ProxyWindow = function() {\n            function ProxyWindow(_ref2) {\n                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n                this.id = void 0;\n                this.isProxyWindow = !0;\n                this.serializedWindow = void 0;\n                this.actualWindow = void 0;\n                this.actualWindowPromise = void 0;\n                this.send = void 0;\n                this.name = void 0;\n                this.actualWindowPromise = new promise_ZalgoPromise;\n                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n                    send: send\n                });\n                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n                win && this.setWindow(win, {\n                    send: send\n                });\n            }\n            var _proto = ProxyWindow.prototype;\n            _proto.getID = function() {\n                return this.serializedWindow.id;\n            };\n            _proto.getType = function() {\n                return this.serializedWindow.getType();\n            };\n            _proto.isPopup = function() {\n                return this.getType().then((function(type) {\n                    return type === WINDOW_TYPE.POPUP;\n                }));\n            };\n            _proto.setLocation = function(href) {\n                var _this = this;\n                return this.serializedWindow.setLocation(href).then((function() {\n                    return _this;\n                }));\n            };\n            _proto.getName = function() {\n                return this.serializedWindow.getName();\n            };\n            _proto.setName = function(name) {\n                var _this2 = this;\n                return this.serializedWindow.setName(name).then((function() {\n                    return _this2;\n                }));\n            };\n            _proto.close = function() {\n                var _this3 = this;\n                return this.serializedWindow.close().then((function() {\n                    return _this3;\n                }));\n            };\n            _proto.focus = function() {\n                var _this4 = this;\n                var isPopupPromise = this.isPopup();\n                var getNamePromise = this.getName();\n                var reopenPromise = promise_ZalgoPromise.hash({\n                    isPopup: isPopupPromise,\n                    name: getNamePromise\n                }).then((function(_ref3) {\n                    var name = _ref3.name;\n                    _ref3.isPopup && name && window.open(\"\", name);\n                }));\n                var focusPromise = this.serializedWindow.focus();\n                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n                    return _this4;\n                }));\n            };\n            _proto.isClosed = function() {\n                return this.serializedWindow.isClosed();\n            };\n            _proto.getWindow = function() {\n                return this.actualWindow;\n            };\n            _proto.setWindow = function(win, _ref4) {\n                var send = _ref4.send;\n                this.actualWindow = win;\n                this.actualWindowPromise.resolve(this.actualWindow);\n                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n                    send: send,\n                    id: this.getID()\n                });\n                windowStore(\"winToProxyWindow\").set(win, this);\n            };\n            _proto.awaitWindow = function() {\n                return this.actualWindowPromise;\n            };\n            _proto.matchWindow = function(win, _ref5) {\n                var _this5 = this;\n                var send = _ref5.send;\n                return promise_ZalgoPromise.try((function() {\n                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n                        proxyInstanceID: _this5.getInstanceID(),\n                        knownWindowInstanceID: getWindowInstanceID(win, {\n                            send: send\n                        })\n                    }).then((function(_ref6) {\n                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n                        match && _this5.setWindow(win, {\n                            send: send\n                        });\n                        return match;\n                    }));\n                }));\n            };\n            _proto.unwrap = function() {\n                return this.actualWindow || this;\n            };\n            _proto.getInstanceID = function() {\n                return this.serializedWindow.getInstanceID();\n            };\n            _proto.shouldClean = function() {\n                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n            };\n            _proto.serialize = function() {\n                return this.serializedWindow;\n            };\n            ProxyWindow.unwrap = function(win) {\n                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n            };\n            ProxyWindow.serialize = function(win, _ref7) {\n                var send = _ref7.send;\n                cleanupProxyWindows();\n                return ProxyWindow.toProxyWindow(win, {\n                    send: send\n                }).serialize();\n            };\n            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n                var send = _ref8.send;\n                cleanupProxyWindows();\n                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n                    serializedWindow: serializedWindow,\n                    send: send\n                });\n            };\n            ProxyWindow.isProxyWindow = function(obj) {\n                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n            };\n            ProxyWindow.toProxyWindow = function(win, _ref9) {\n                var send = _ref9.send;\n                cleanupProxyWindows();\n                if (ProxyWindow.isProxyWindow(win)) return win;\n                var actualWindow = win;\n                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n                    win: actualWindow,\n                    send: send\n                });\n            };\n            return ProxyWindow;\n        }();\n        function addMethod(id, val, name, source, domain) {\n            var methodStore = windowStore(\"methodStore\");\n            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n                val: val,\n                name: name,\n                domain: domain,\n                source: source\n            }); else {\n                proxyWindowMethods.del(id);\n                methodStore.getOrSet(source, (function() {\n                    return {};\n                }))[id] = {\n                    domain: domain,\n                    name: name,\n                    val: val,\n                    source: source\n                };\n            }\n        }\n        function lookupMethod(source, id) {\n            var methodStore = windowStore(\"methodStore\");\n            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n            return methodStore.getOrSet(source, (function() {\n                return {};\n            }))[id] || proxyWindowMethods.get(id);\n        }\n        function function_serializeFunction(destination, domain, val, key, _ref3) {\n            on = (_ref = {\n                on: _ref3.on,\n                send: _ref3.send\n            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n                return on(\"postrobot_method\", {\n                    domain: \"*\"\n                }, (function(_ref2) {\n                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n                    var id = data.id, name = data.name;\n                    var meth = lookupMethod(source, id);\n                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n                    return promise_ZalgoPromise.try((function() {\n                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n                            send: send\n                        }).then((function(match) {\n                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n                        }));\n                    })).then((function() {\n                        return val.apply({\n                            source: source,\n                            origin: origin\n                        }, data.args);\n                    }), (function(err) {\n                        return promise_ZalgoPromise.try((function() {\n                            if (val.onError) return val.onError(err);\n                        })).then((function() {\n                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n                                void 0 === args && (args = []);\n                                return arrayFrom(args).map((function(arg) {\n                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n                                })).join(\", \");\n                            }(data.args) + \") failed\\n\\n\" + err.stack);\n                            throw err;\n                        }));\n                    })).then((function(result) {\n                        return {\n                            result: result,\n                            id: id,\n                            name: name\n                        };\n                    }));\n                }));\n            }));\n            var _ref, on, send;\n            var id = val.__id__ || uniqueID();\n            destination = window_ProxyWindow.unwrap(destination);\n            var name = val.__name__ || val.name || key;\n            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n            if (window_ProxyWindow.isProxyWindow(destination)) {\n                addMethod(id, val, name, destination, domain);\n                destination.awaitWindow().then((function(win) {\n                    addMethod(id, val, name, win, domain);\n                }));\n            } else addMethod(id, val, name, destination, domain);\n            return serializeType(\"cross_domain_function\", {\n                id: id,\n                name: name\n            });\n        }\n        function serializeMessage(destination, domain, obj, _ref) {\n            var _serialize;\n            var on = _ref.on, send = _ref.send;\n            return function(obj, serializers) {\n                void 0 === serializers && (serializers = defaultSerializers);\n                var result = JSON.stringify(obj, (function(key) {\n                    var val = this[key];\n                    if (isSerializedType(this)) return val;\n                    var type = determineType(val);\n                    if (!type) return val;\n                    var serializer = serializers[type] || SERIALIZER[type];\n                    return serializer ? serializer(val, key) : val;\n                }));\n                return void 0 === result ? \"undefined\" : result;\n            }(obj, ((_serialize = {}).promise = function(val, key) {\n                return function(destination, domain, val, key, _ref) {\n                    return serializeType(\"cross_domain_zalgo_promise\", {\n                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n                            return val.then(resolve, reject);\n                        }), key, {\n                            on: _ref.on,\n                            send: _ref.send\n                        })\n                    });\n                }(destination, domain, val, key, {\n                    on: on,\n                    send: send\n                });\n            }, _serialize.function = function(val, key) {\n                return function_serializeFunction(destination, domain, val, key, {\n                    on: on,\n                    send: send\n                });\n            }, _serialize.object = function(val) {\n                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n                    send: send\n                })) : val;\n            }, _serialize));\n        }\n        function deserializeMessage(source, origin, message, _ref2) {\n            var _deserialize;\n            var send = _ref2.send;\n            return function(str, deserializers) {\n                void 0 === deserializers && (deserializers = defaultDeserializers);\n                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n                    if (isSerializedType(this)) return val;\n                    var type;\n                    var value;\n                    if (isSerializedType(val)) {\n                        type = val.__type__;\n                        value = val.__val__;\n                    } else {\n                        type = determineType(val);\n                        value = val;\n                    }\n                    if (!type) return value;\n                    var deserializer = deserializers[type] || DESERIALIZER[type];\n                    return deserializer ? deserializer(value, key) : value;\n                }));\n            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n                return function(source, origin, _ref2) {\n                    return new promise_ZalgoPromise(_ref2.then);\n                }(0, 0, serializedPromise);\n            }, _deserialize.cross_domain_function = function(serializedFunction) {\n                return function(source, origin, _ref4, _ref5) {\n                    var id = _ref4.id, name = _ref4.name;\n                    var send = _ref5.send;\n                    var getDeserializedFunction = function(opts) {\n                        void 0 === opts && (opts = {});\n                        function crossDomainFunctionWrapper() {\n                            var _arguments = arguments;\n                            return window_ProxyWindow.toProxyWindow(source, {\n                                send: send\n                            }).awaitWindow().then((function(win) {\n                                var meth = lookupMethod(win, id);\n                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n                                    source: window,\n                                    origin: getDomain()\n                                }, _arguments);\n                                var _args = [].slice.call(_arguments);\n                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n                                    id: id,\n                                    name: name,\n                                    args: _args\n                                }, {\n                                    domain: origin,\n                                    fireAndForget: !0\n                                }) : send(win, \"postrobot_method\", {\n                                    id: id,\n                                    name: name,\n                                    args: _args\n                                }, {\n                                    domain: origin,\n                                    fireAndForget: !1\n                                }).then((function(res) {\n                                    return res.data.result;\n                                }));\n                            })).catch((function(err) {\n                                throw err;\n                            }));\n                        }\n                        crossDomainFunctionWrapper.__name__ = name;\n                        crossDomainFunctionWrapper.__origin__ = origin;\n                        crossDomainFunctionWrapper.__source__ = source;\n                        crossDomainFunctionWrapper.__id__ = id;\n                        crossDomainFunctionWrapper.origin = origin;\n                        return crossDomainFunctionWrapper;\n                    };\n                    var crossDomainFunctionWrapper = getDeserializedFunction();\n                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n                        fireAndForget: !0\n                    });\n                    return crossDomainFunctionWrapper;\n                }(source, origin, serializedFunction, {\n                    send: send\n                });\n            }, _deserialize.cross_domain_window = function(serializedWindow) {\n                return window_ProxyWindow.deserialize(serializedWindow, {\n                    send: send\n                });\n            }, _deserialize));\n        }\n        var SEND_MESSAGE_STRATEGIES = {};\n        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n            win.postMessage(serializedMessage, domain);\n        };\n        SEND_MESSAGE_STRATEGIES.postrobot_global = function(win, serializedMessage) {\n            if (!function(win) {\n                return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;\n            }(window).match(/MSIE|rv:11|trident|edge\\/12|edge\\/13/i)) throw new Error(\"Global messaging not needed for browser\");\n            if (!isSameDomain(win)) throw new Error(\"Post message through global disabled between different domain windows\");\n            if (!1 !== isSameTopWindow(window, win)) throw new Error(\"Can only use global to communicate between two different windows, not between frames\");\n            var foreignGlobal = global_getGlobal(win);\n            if (!foreignGlobal) throw new Error(\"Can not find postRobot global on foreign window\");\n            foreignGlobal.receiveMessage({\n                source: window,\n                origin: getDomain(),\n                data: serializedMessage\n            });\n        };\n        function send_sendMessage(win, domain, message, _ref2) {\n            var on = _ref2.on, send = _ref2.send;\n            return promise_ZalgoPromise.try((function() {\n                var domainBuffer = windowStore().getOrSet(win, (function() {\n                    return {};\n                }));\n                domainBuffer.buffer = domainBuffer.buffer || [];\n                domainBuffer.buffer.push(message);\n                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_42__ = domainBuffer.buffer || [], \n                    _ref), {\n                        on: on,\n                        send: send\n                    });\n                    var _ref;\n                    delete domainBuffer.buffer;\n                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n                    var errors = [];\n                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n                        var strategyName = strategies[_i2];\n                        try {\n                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n                        } catch (err) {\n                            errors.push(err);\n                        }\n                    }\n                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n                        return i + \". \" + stringifyError(err);\n                    })).join(\"\\n\\n\"));\n                }));\n                return domainBuffer.flush.then((function() {\n                    delete domainBuffer.flush;\n                }));\n            })).then(src_util_noop);\n        }\n        function getResponseListener(hash) {\n            return globalStore(\"responseListeners\").get(hash);\n        }\n        function deleteResponseListener(hash) {\n            globalStore(\"responseListeners\").del(hash);\n        }\n        function isResponseListenerErrored(hash) {\n            return globalStore(\"erroredResponseListeners\").has(hash);\n        }\n        function getRequestListener(_ref) {\n            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n            var requestListeners = windowStore(\"requestListeners\");\n            \"*\" === win && (win = null);\n            \"*\" === domain && (domain = null);\n            if (!name) throw new Error(\"Name required to get request listener\");\n            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n                var winQualifier = _ref3[_i4];\n                if (winQualifier) {\n                    var nameListeners = requestListeners.get(winQualifier);\n                    if (nameListeners) {\n                        var domainListeners = nameListeners[name];\n                        if (domainListeners) {\n                            if (domain && \"string\" == typeof domain) {\n                                if (domainListeners[domain]) return domainListeners[domain];\n                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n                                }\n                            }\n                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n                        }\n                    }\n                }\n            }\n        }\n        function handleRequest(source, origin, message, _ref) {\n            var on = _ref.on, send = _ref.send;\n            var options = getRequestListener({\n                name: message.name,\n                win: source,\n                domain: origin\n            });\n            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n            function sendResponse(ack, data, error) {\n                return promise_ZalgoPromise.flush().then((function() {\n                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n                        return send_sendMessage(source, origin, {\n                            id: uniqueID(),\n                            origin: getDomain(window),\n                            type: \"postrobot_message_response\",\n                            hash: message.hash,\n                            name: message.name,\n                            ack: ack,\n                            data: data,\n                            error: error\n                        }, {\n                            on: on,\n                            send: send\n                        });\n                    } catch (err) {\n                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n                    }\n                }));\n            }\n            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n                if (!message.fireAndForget && !isWindowClosed(source)) try {\n                    return send_sendMessage(source, origin, {\n                        id: uniqueID(),\n                        origin: getDomain(window),\n                        type: \"postrobot_message_ack\",\n                        hash: message.hash,\n                        name: message.name\n                    }, {\n                        on: on,\n                        send: send\n                    });\n                } catch (err) {\n                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n                }\n            })), promise_ZalgoPromise.try((function() {\n                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n                if (!matchDomain(options.domain, origin)) throw new Error(\"Request origin \" + origin + \" does not match domain \" + options.domain.toString());\n                return options.handler({\n                    source: source,\n                    origin: origin,\n                    data: message.data\n                });\n            })).then((function(data) {\n                return sendResponse(\"success\", data);\n            }), (function(error) {\n                return sendResponse(\"error\", null, error);\n            })) ]).then(src_util_noop).catch((function(err) {\n                if (options && options.handleError) return options.handleError(err);\n                throw err;\n            }));\n        }\n        function handleAck(source, origin, message) {\n            if (!isResponseListenerErrored(message.hash)) {\n                var options = getResponseListener(message.hash);\n                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n                try {\n                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n                } catch (err) {\n                    options.promise.reject(err);\n                }\n                options.ack = !0;\n            }\n        }\n        function handleResponse(source, origin, message) {\n            if (!isResponseListenerErrored(message.hash)) {\n                var options = getResponseListener(message.hash);\n                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() : pattern.toString()));\n                var pattern;\n                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n                deleteResponseListener(message.hash);\n                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n                    source: source,\n                    origin: origin,\n                    data: message.data\n                });\n            }\n        }\n        function receive_receiveMessage(event, _ref2) {\n            var on = _ref2.on, send = _ref2.send;\n            var receivedMessages = globalStore(\"receivedMessages\");\n            try {\n                if (!window || window.closed || !event.source) return;\n            } catch (err) {\n                return;\n            }\n            var source = event.source, origin = event.origin;\n            var messages = function(message, source, origin, _ref) {\n                var on = _ref.on, send = _ref.send;\n                var parsedMessage;\n                try {\n                    parsedMessage = deserializeMessage(source, origin, message, {\n                        on: on,\n                        send: send\n                    });\n                } catch (err) {\n                    return;\n                }\n                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n                    var parseMessages = parsedMessage.__post_robot_10_0_42__;\n                    if (Array.isArray(parseMessages)) return parseMessages;\n                }\n            }(event.data, source, origin, {\n                on: on,\n                send: send\n            });\n            if (messages) {\n                markWindowKnown(source);\n                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n                    var message = messages[_i2];\n                    if (receivedMessages.has(message.id)) return;\n                    receivedMessages.set(message.id, !0);\n                    if (isWindowClosed(source) && !message.fireAndForget) return;\n                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n                    try {\n                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n                            on: on,\n                            send: send\n                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n                    } catch (err) {\n                        setTimeout((function() {\n                            throw err;\n                        }), 0);\n                    }\n                }\n            }\n        }\n        function on_on(name, options, handler) {\n            if (!name) throw new Error(\"Expected name\");\n            if (\"function\" == typeof (options = options || {})) {\n                handler = options;\n                options = {};\n            }\n            if (!handler) throw new Error(\"Expected handler\");\n            (options = options || {}).name = name;\n            options.handler = handler || options.handler;\n            var win = options.window;\n            var domain = options.domain;\n            var requestListener = function addRequestListener(_ref4, listener) {\n                var name = _ref4.name, win = _ref4.win, domain = _ref4.domain;\n                var requestListeners = windowStore(\"requestListeners\");\n                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n                if (Array.isArray(win)) {\n                    var listenersCollection = [];\n                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n                        name: name,\n                        domain: domain,\n                        win: _win2[_i8]\n                    }, listener));\n                    return {\n                        cancel: function() {\n                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n                        }\n                    };\n                }\n                if (Array.isArray(domain)) {\n                    var _listenersCollection = [];\n                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n                        name: name,\n                        win: win,\n                        domain: _domain2[_i12]\n                    }, listener));\n                    return {\n                        cancel: function() {\n                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n                        }\n                    };\n                }\n                var existingListener = getRequestListener({\n                    name: name,\n                    win: win,\n                    domain: domain\n                });\n                win && \"*\" !== win || (win = getWildcard());\n                domain = domain || \"*\";\n                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n                var nameListeners = requestListeners.getOrSet(win, (function() {\n                    return {};\n                }));\n                var domainListeners = util_getOrSet(nameListeners, name, (function() {\n                    return {};\n                }));\n                var strDomain = domain.toString();\n                var regexListeners;\n                var regexListener;\n                util_isRegex(domain) ? (regexListeners = util_getOrSet(domainListeners, \"__domain_regex__\", (function() {\n                    return [];\n                }))).push(regexListener = {\n                    regex: domain,\n                    listener: listener\n                }) : domainListeners[strDomain] = listener;\n                return {\n                    cancel: function() {\n                        delete domainListeners[strDomain];\n                        if (regexListener) {\n                            regexListeners.splice(regexListeners.indexOf(regexListener, 1));\n                            regexListeners.length || delete domainListeners.__domain_regex__;\n                        }\n                        Object.keys(domainListeners).length || delete nameListeners[name];\n                        win && !Object.keys(nameListeners).length && requestListeners.del(win);\n                    }\n                };\n            }({\n                name: name,\n                win: win,\n                domain: domain\n            }, {\n                handler: options.handler,\n                handleError: options.errorHandler || function(err) {\n                    throw err;\n                },\n                window: win,\n                domain: domain || \"*\",\n                name: name\n            });\n            return {\n                cancel: function() {\n                    requestListener.cancel();\n                }\n            };\n        }\n        var send_send = function send(win, name, data, options) {\n            var domainMatcher = (options = options || {}).domain || \"*\";\n            var responseTimeout = options.timeout || -1;\n            var childTimeout = options.timeout || 5e3;\n            var fireAndForget = options.fireAndForget || !1;\n            return promise_ZalgoPromise.try((function() {\n                !function(name, win, domain) {\n                    if (!name) throw new Error(\"Expected name\");\n                    if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n                    if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n                }(name, win, domainMatcher);\n                if (function(parent, child) {\n                    var actualParent = getAncestor(child);\n                    if (actualParent) return actualParent === parent;\n                    if (child === parent) return !1;\n                    if (getTop(child) === child) return !1;\n                    for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n                    return !1;\n                }(window, win)) return function(win, timeout, name) {\n                    void 0 === timeout && (timeout = 5e3);\n                    void 0 === name && (name = \"Window\");\n                    var promise = function(win) {\n                        return windowStore(\"helloPromises\").getOrSet(win, (function() {\n                            return new promise_ZalgoPromise;\n                        }));\n                    }(win);\n                    -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n                    return promise;\n                }(win, childTimeout);\n            })).then((function(_temp) {\n                return function(win, targetDomain, actualDomain, _ref) {\n                    var send = _ref.send;\n                    return promise_ZalgoPromise.try((function() {\n                        return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n                            return actualDomain || sayHello(win, {\n                                send: send\n                            }).then((function(_ref2) {\n                                return _ref2.domain;\n                            }));\n                        })).then((function(normalizedDomain) {\n                            if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n                            return normalizedDomain;\n                        }));\n                    }));\n                }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n                    send: send\n                });\n            })).then((function(targetDomain) {\n                var domain = targetDomain;\n                var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n                var promise = new promise_ZalgoPromise;\n                var hash = name + \"_\" + uniqueID();\n                if (!fireAndForget) {\n                    var responseListener = {\n                        name: name,\n                        win: win,\n                        domain: domain,\n                        promise: promise\n                    };\n                    !function(hash, listener) {\n                        globalStore(\"responseListeners\").set(hash, listener);\n                    }(hash, responseListener);\n                    var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n                        return [];\n                    }));\n                    reqPromises.push(promise);\n                    promise.catch((function() {\n                        !function(hash) {\n                            globalStore(\"erroredResponseListeners\").set(hash, !0);\n                        }(hash);\n                        deleteResponseListener(hash);\n                    }));\n                    var totalAckTimeout = function(win) {\n                        return windowStore(\"knownWindows\").get(win, !1);\n                    }(win) ? 1e4 : 2e3;\n                    var totalResTimeout = responseTimeout;\n                    var ackTimeout = totalAckTimeout;\n                    var resTimeout = totalResTimeout;\n                    var interval = safeInterval((function() {\n                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n                        ackTimeout = Math.max(ackTimeout - 500, 0);\n                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n                        return responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout ? promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : void 0 : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n                    }), 500);\n                    promise.finally((function() {\n                        interval.cancel();\n                        reqPromises.splice(reqPromises.indexOf(promise, 1));\n                    })).catch(src_util_noop);\n                }\n                return send_sendMessage(win, domain, {\n                    id: uniqueID(),\n                    origin: getDomain(window),\n                    type: \"postrobot_message_request\",\n                    hash: hash,\n                    name: name,\n                    data: data,\n                    fireAndForget: fireAndForget\n                }, {\n                    on: on_on,\n                    send: send\n                }).then((function() {\n                    return fireAndForget ? promise.resolve() : promise;\n                }), (function(err) {\n                    throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n                }));\n            }));\n        };\n        function setup_serializeMessage(destination, domain, obj) {\n            return serializeMessage(destination, domain, obj, {\n                on: on_on,\n                send: send_send\n            });\n        }\n        function setup_deserializeMessage(source, origin, message) {\n            return deserializeMessage(source, origin, message, {\n                on: on_on,\n                send: send_send\n            });\n        }\n        function setup_toProxyWindow(win) {\n            return window_ProxyWindow.toProxyWindow(win, {\n                send: send_send\n            });\n        }\n        function lib_global_getGlobal(win) {\n            void 0 === win && (win = window);\n            if (!isSameDomain(win)) throw new Error(\"Can not get global for window on different domain\");\n            win.__zoid_9_0_63__ || (win.__zoid_9_0_63__ = {});\n            return win.__zoid_9_0_63__;\n        }\n        function getProxyObject(obj) {\n            return {\n                get: function() {\n                    var _this = this;\n                    return promise_ZalgoPromise.try((function() {\n                        if (_this.source && _this.source !== window) throw new Error(\"Can not call get on proxy object from a remote window\");\n                        return obj;\n                    }));\n                }\n            };\n        }\n        var PROP_TYPE = {\n            STRING: \"string\",\n            OBJECT: \"object\",\n            FUNCTION: \"function\",\n            BOOLEAN: \"boolean\",\n            NUMBER: \"number\",\n            ARRAY: \"array\"\n        };\n        var PROP_SERIALIZATION = {\n            JSON: \"json\",\n            DOTIFY: \"dotify\",\n            BASE64: \"base64\"\n        };\n        var CONTEXT = WINDOW_TYPE;\n        var EVENT = {\n            RENDER: \"zoid-render\",\n            RENDERED: \"zoid-rendered\",\n            DISPLAY: \"zoid-display\",\n            ERROR: \"zoid-error\",\n            CLOSE: \"zoid-close\",\n            DESTROY: \"zoid-destroy\",\n            PROPS: \"zoid-props\",\n            RESIZE: \"zoid-resize\",\n            FOCUS: \"zoid-focus\"\n        };\n        function normalizeChildProp(propsDef, props, key, value, helpers) {\n            if (!propsDef.hasOwnProperty(key)) return value;\n            var prop = propsDef[key];\n            return \"function\" == typeof prop.childDecorate ? prop.childDecorate({\n                value: value,\n                uid: helpers.uid,\n                close: helpers.close,\n                focus: helpers.focus,\n                onError: helpers.onError,\n                onProps: helpers.onProps,\n                resize: helpers.resize,\n                getParent: helpers.getParent,\n                getParentDomain: helpers.getParentDomain,\n                show: helpers.show,\n                hide: helpers.hide\n            }) : value;\n        }\n        function parseChildWindowName(windowName) {\n            return inlineMemoize(parseChildWindowName, (function() {\n                if (!windowName) throw new Error(\"No window name\");\n                var _windowName$split = windowName.split(\"__\"), zoidcomp = _windowName$split[1], name = _windowName$split[2], encodedPayload = _windowName$split[3];\n                if (\"zoid\" !== zoidcomp) throw new Error(\"Window not rendered by zoid - got \" + zoidcomp);\n                if (!name) throw new Error(\"Expected component name\");\n                if (!encodedPayload) throw new Error(\"Expected encoded payload\");\n                try {\n                    return JSON.parse(function(str) {\n                        if (\"function\" == typeof atob) return decodeURIComponent([].map.call(atob(str), (function(c) {\n                            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                        })).join(\"\"));\n                        if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"base64\").toString(\"utf8\");\n                        throw new Error(\"Can not find window.atob or Buffer\");\n                    }(encodedPayload));\n                } catch (err) {\n                    throw new Error(\"Can not decode window name payload: \" + encodedPayload + \": \" + stringifyError(err));\n                }\n            }), [ windowName ]);\n        }\n        function getChildPayload() {\n            try {\n                return parseChildWindowName(window.name);\n            } catch (err) {}\n        }\n        function child_focus() {\n            return promise_ZalgoPromise.try((function() {\n                window.focus();\n            }));\n        }\n        function child_destroy() {\n            return promise_ZalgoPromise.try((function() {\n                window.close();\n            }));\n        }\n        function props_getQueryParam(prop, key, value) {\n            return promise_ZalgoPromise.try((function() {\n                return \"function\" == typeof prop.queryParam ? prop.queryParam({\n                    value: value\n                }) : \"string\" == typeof prop.queryParam ? prop.queryParam : key;\n            }));\n        }\n        function getQueryValue(prop, key, value) {\n            return promise_ZalgoPromise.try((function() {\n                return \"function\" == typeof prop.queryValue && isDefined(value) ? prop.queryValue({\n                    value: value\n                }) : value;\n            }));\n        }\n        function parentComponent(options, overrides, parentWin) {\n            void 0 === overrides && (overrides = {});\n            void 0 === parentWin && (parentWin = window);\n            var propsDef = options.propsDef, containerTemplate = options.containerTemplate, prerenderTemplate = options.prerenderTemplate, tag = options.tag, name = options.name, attributes = options.attributes, dimensions = options.dimensions, autoResize = options.autoResize, url = options.url, domainMatch = options.domain;\n            var initPromise = new promise_ZalgoPromise;\n            var handledErrors = [];\n            var clean = cleanup();\n            var state = {};\n            var internalState = {\n                visible: !0\n            };\n            var event = overrides.event ? overrides.event : (triggered = {}, handlers = {}, \n            {\n                on: function(eventName, handler) {\n                    var handlerList = handlers[eventName] = handlers[eventName] || [];\n                    handlerList.push(handler);\n                    var cancelled = !1;\n                    return {\n                        cancel: function() {\n                            if (!cancelled) {\n                                cancelled = !0;\n                                handlerList.splice(handlerList.indexOf(handler), 1);\n                            }\n                        }\n                    };\n                },\n                once: function(eventName, handler) {\n                    var listener = this.on(eventName, (function() {\n                        listener.cancel();\n                        handler();\n                    }));\n                    return listener;\n                },\n                trigger: function(eventName) {\n                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];\n                    var handlerList = handlers[eventName];\n                    var promises = [];\n                    if (handlerList) {\n                        var _loop = function(_i2) {\n                            var handler = handlerList[_i2];\n                            promises.push(promise_ZalgoPromise.try((function() {\n                                return handler.apply(void 0, args);\n                            })));\n                        };\n                        for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop(_i2);\n                    }\n                    return promise_ZalgoPromise.all(promises).then(src_util_noop);\n                },\n                triggerOnce: function(eventName) {\n                    if (triggered[eventName]) return promise_ZalgoPromise.resolve();\n                    triggered[eventName] = !0;\n                    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];\n                    return this.trigger.apply(this, [ eventName ].concat(args));\n                },\n                reset: function() {\n                    handlers = {};\n                }\n            });\n            var triggered, handlers;\n            var props = overrides.props ? overrides.props : {};\n            var currentProxyWin;\n            var currentProxyContainer;\n            var childComponent;\n            var onErrorOverride = overrides.onError;\n            var getProxyContainerOverride = overrides.getProxyContainer;\n            var showOverride = overrides.show;\n            var hideOverride = overrides.hide;\n            var closeOverride = overrides.close;\n            var renderContainerOverride = overrides.renderContainer;\n            var getProxyWindowOverride = overrides.getProxyWindow;\n            var setProxyWinOverride = overrides.setProxyWin;\n            var openFrameOverride = overrides.openFrame;\n            var openPrerenderFrameOverride = overrides.openPrerenderFrame;\n            var prerenderOverride = overrides.prerender;\n            var openOverride = overrides.open;\n            var openPrerenderOverride = overrides.openPrerender;\n            var watchForUnloadOverride = overrides.watchForUnload;\n            var getInternalStateOverride = overrides.getInternalState;\n            var setInternalStateOverride = overrides.setInternalState;\n            var getPropsForChild = function(domain) {\n                var result = {};\n                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {\n                    var key = _Object$keys2[_i2];\n                    var prop = propsDef[key];\n                    prop && !1 === prop.sendToChild || prop && prop.sameDomain && !matchDomain(domain, getDomain(window)) || (result[key] = props[key]);\n                }\n                return promise_ZalgoPromise.hash(result);\n            };\n            var getInternalState = function() {\n                return promise_ZalgoPromise.try((function() {\n                    return getInternalStateOverride ? getInternalStateOverride() : internalState;\n                }));\n            };\n            var setInternalState = function(newInternalState) {\n                return promise_ZalgoPromise.try((function() {\n                    return setInternalStateOverride ? setInternalStateOverride(newInternalState) : internalState = _extends({}, internalState, newInternalState);\n                }));\n            };\n            var getProxyWindow = function() {\n                return getProxyWindowOverride ? getProxyWindowOverride() : promise_ZalgoPromise.try((function() {\n                    var windowProp = props.window;\n                    if (windowProp) {\n                        var _proxyWin = setup_toProxyWindow(windowProp);\n                        clean.register((function() {\n                            return windowProp.close();\n                        }));\n                        return _proxyWin;\n                    }\n                    return new window_ProxyWindow({\n                        send: send_send\n                    });\n                }));\n            };\n            var getProxyContainer = function(container) {\n                return getProxyContainerOverride ? getProxyContainerOverride(container) : promise_ZalgoPromise.try((function() {\n                    return elementReady(container);\n                })).then((function(containerElement) {\n                    isShadowElement(containerElement) && (containerElement = function(element) {\n                        var shadowHost = function(element) {\n                            var shadowRoot = function(element) {\n                                for (;element.parentNode; ) element = element.parentNode;\n                                if (isShadowElement(element)) return element;\n                            }(element);\n                            if (shadowRoot.host) return shadowRoot.host;\n                        }(element);\n                        if (!shadowHost) throw new Error(\"Element is not in shadow dom\");\n                        if (isShadowElement(shadowHost)) throw new Error(\"Host element is also in shadow dom\");\n                        var slotName = \"shadow-slot-\" + uniqueID();\n                        var slot = document.createElement(\"slot\");\n                        slot.setAttribute(\"name\", slotName);\n                        element.appendChild(slot);\n                        var slotProvider = document.createElement(\"div\");\n                        slotProvider.setAttribute(\"slot\", slotName);\n                        shadowHost.appendChild(slotProvider);\n                        return slotProvider;\n                    }(containerElement));\n                    return getProxyObject(containerElement);\n                }));\n            };\n            var setProxyWin = function(proxyWin) {\n                return setProxyWinOverride ? setProxyWinOverride(proxyWin) : promise_ZalgoPromise.try((function() {\n                    currentProxyWin = proxyWin;\n                }));\n            };\n            var show = function() {\n                return showOverride ? showOverride() : promise_ZalgoPromise.hash({\n                    setState: setInternalState({\n                        visible: !0\n                    }),\n                    showElement: currentProxyContainer ? currentProxyContainer.get().then(showElement) : null\n                }).then(src_util_noop);\n            };\n            var hide = function() {\n                return hideOverride ? hideOverride() : promise_ZalgoPromise.hash({\n                    setState: setInternalState({\n                        visible: !1\n                    }),\n                    showElement: currentProxyContainer ? currentProxyContainer.get().then(hideElement) : null\n                }).then(src_util_noop);\n            };\n            var getUrl = function() {\n                return \"function\" == typeof url ? url({\n                    props: props\n                }) : url;\n            };\n            var getAttributes = function() {\n                return \"function\" == typeof attributes ? attributes({\n                    props: props\n                }) : attributes;\n            };\n            var getChildDomain = function() {\n                return domainMatch && \"string\" == typeof domainMatch ? domainMatch : getDomainFromUrl(getUrl());\n            };\n            var getDomainMatcher = function() {\n                return domainMatch && util_isRegex(domainMatch) ? domainMatch : getChildDomain();\n            };\n            var openFrame = function(context, _ref) {\n                var windowName = _ref.windowName;\n                return openFrameOverride ? openFrameOverride(context, {\n                    windowName: windowName\n                }) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({\n                        attributes: _extends({\n                            name: windowName,\n                            title: name\n                        }, getAttributes().iframe)\n                    }));\n                }));\n            };\n            var openPrerenderFrame = function(context) {\n                return openPrerenderFrameOverride ? openPrerenderFrameOverride(context) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({\n                        attributes: _extends({\n                            name: \"__zoid_prerender_frame__\" + name + \"_\" + uniqueID() + \"__\",\n                            title: \"prerender__\" + name\n                        }, getAttributes().iframe)\n                    }));\n                }));\n            };\n            var openPrerender = function(context, proxyWin, proxyPrerenderFrame) {\n                return openPrerenderOverride ? openPrerenderOverride(context, proxyWin, proxyPrerenderFrame) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) {\n                        if (!proxyPrerenderFrame) throw new Error(\"Expected proxy frame to be passed\");\n                        return proxyPrerenderFrame.get().then((function(prerenderFrame) {\n                            clean.register((function() {\n                                return destroyElement(prerenderFrame);\n                            }));\n                            return awaitFrameWindow(prerenderFrame).then((function(prerenderFrameWindow) {\n                                return assertSameDomain(prerenderFrameWindow);\n                            })).then((function(win) {\n                                return setup_toProxyWindow(win);\n                            }));\n                        }));\n                    }\n                    throw new Error(\"No render context available for \" + context);\n                }));\n            };\n            var focus = function() {\n                return promise_ZalgoPromise.try((function() {\n                    if (currentProxyWin) return promise_ZalgoPromise.all([ event.trigger(EVENT.FOCUS), currentProxyWin.focus() ]).then(src_util_noop);\n                }));\n            };\n            var getWindowRef = function(target, domain, uid, context) {\n                if (domain === getDomain(window)) {\n                    var global = lib_global_getGlobal(window);\n                    global.windows = global.windows || {};\n                    global.windows[uid] = window;\n                    clean.register((function() {\n                        delete global.windows[uid];\n                    }));\n                    return {\n                        type: \"global\",\n                        uid: uid\n                    };\n                }\n                return context === CONTEXT.POPUP ? {\n                    type: \"opener\"\n                } : {\n                    type: \"parent\",\n                    distance: getDistanceFromTop(window)\n                };\n            };\n            var initChild = function(childExports) {\n                return promise_ZalgoPromise.try((function() {\n                    childComponent = childExports;\n                    initPromise.resolve();\n                    clean.register((function() {\n                        return childExports.close.fireAndForget().catch(src_util_noop);\n                    }));\n                }));\n            };\n            var resize = function(_ref2) {\n                var width = _ref2.width, height = _ref2.height;\n                return promise_ZalgoPromise.try((function() {\n                    event.trigger(EVENT.RESIZE, {\n                        width: width,\n                        height: height\n                    });\n                }));\n            };\n            var destroy = function(err) {\n                return promise_ZalgoPromise.try((function() {\n                    return event.trigger(EVENT.DESTROY);\n                })).catch(src_util_noop).then((function() {\n                    return clean.all(err);\n                })).then((function() {\n                    initPromise.asyncReject(err || new Error(\"Component destroyed\"));\n                }));\n            };\n            var close = memoize((function(err) {\n                return promise_ZalgoPromise.try((function() {\n                    if (closeOverride) {\n                        if (isWindowClosed(closeOverride.__source__)) return;\n                        return closeOverride();\n                    }\n                    return promise_ZalgoPromise.try((function() {\n                        return event.trigger(EVENT.CLOSE);\n                    })).then((function() {\n                        return destroy(err || new Error(\"Component closed\"));\n                    }));\n                }));\n            }));\n            var open = function(context, _ref3) {\n                var proxyWin = _ref3.proxyWin, proxyFrame = _ref3.proxyFrame;\n                return openOverride ? openOverride(context, {\n                    proxyWin: proxyWin,\n                    proxyFrame: proxyFrame,\n                    windowName: _ref3.windowName\n                }) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) {\n                        if (!proxyFrame) throw new Error(\"Expected proxy frame to be passed\");\n                        return proxyFrame.get().then((function(frame) {\n                            return awaitFrameWindow(frame).then((function(win) {\n                                clean.register((function() {\n                                    return destroyElement(frame);\n                                }));\n                                clean.register((function() {\n                                    return function(win) {\n                                        for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n                                    }(win);\n                                }));\n                                return win;\n                            }));\n                        }));\n                    }\n                    throw new Error(\"No render context available for \" + context);\n                })).then((function(win) {\n                    proxyWin.setWindow(win, {\n                        send: send_send\n                    });\n                    return proxyWin;\n                }));\n            };\n            var watchForUnload = function() {\n                return promise_ZalgoPromise.try((function() {\n                    var unloadWindowListener = addEventListener(window, \"unload\", once((function() {\n                        destroy(new Error(\"Window navigated away\"));\n                    })));\n                    var closeParentWindowListener = onCloseWindow(parentWin, destroy, 3e3);\n                    clean.register(closeParentWindowListener.cancel);\n                    clean.register(unloadWindowListener.cancel);\n                    if (watchForUnloadOverride) return watchForUnloadOverride();\n                }));\n            };\n            var checkWindowClose = function(proxyWin) {\n                var closed = !1;\n                return proxyWin.isClosed().then((function(isClosed) {\n                    if (isClosed) {\n                        closed = !0;\n                        return close(new Error(\"Detected component window close\"));\n                    }\n                    return promise_ZalgoPromise.delay(200).then((function() {\n                        return proxyWin.isClosed();\n                    })).then((function(secondIsClosed) {\n                        if (secondIsClosed) {\n                            closed = !0;\n                            return close(new Error(\"Detected component window close\"));\n                        }\n                    }));\n                })).then((function() {\n                    return closed;\n                }));\n            };\n            var onError = function(err) {\n                return onErrorOverride ? onErrorOverride(err) : promise_ZalgoPromise.try((function() {\n                    if (-1 === handledErrors.indexOf(err)) {\n                        handledErrors.push(err);\n                        initPromise.asyncReject(err);\n                        return event.trigger(EVENT.ERROR, err);\n                    }\n                }));\n            };\n            initChild.onError = onError;\n            var renderTemplate = function(renderer, _ref6) {\n                return renderer({\n                    container: _ref6.container,\n                    context: _ref6.context,\n                    uid: _ref6.uid,\n                    doc: _ref6.doc,\n                    frame: _ref6.frame,\n                    prerenderFrame: _ref6.prerenderFrame,\n                    focus: focus,\n                    close: close,\n                    state: state,\n                    props: props,\n                    tag: tag,\n                    dimensions: dimensions,\n                    event: event\n                });\n            };\n            var prerender = function(proxyPrerenderWin, _ref7) {\n                var context = _ref7.context, uid = _ref7.uid;\n                return prerenderOverride ? prerenderOverride(proxyPrerenderWin, {\n                    context: context,\n                    uid: uid\n                }) : promise_ZalgoPromise.try((function() {\n                    if (prerenderTemplate) {\n                        var prerenderWindow = proxyPrerenderWin.getWindow();\n                        if (prerenderWindow && isSameDomain(prerenderWindow) && function(win) {\n                            try {\n                                if (!win.location.href) return !0;\n                                if (\"about:blank\" === win.location.href) return !0;\n                            } catch (err) {}\n                            return !1;\n                        }(prerenderWindow)) {\n                            var doc = (prerenderWindow = assertSameDomain(prerenderWindow)).document;\n                            var el = renderTemplate(prerenderTemplate, {\n                                context: context,\n                                uid: uid,\n                                doc: doc\n                            });\n                            if (el) {\n                                if (el.ownerDocument !== doc) throw new Error(\"Expected prerender template to have been created with document from child window\");\n                                !function(win, el) {\n                                    var tag = el.tagName.toLowerCase();\n                                    if (\"html\" !== tag) throw new Error(\"Expected element to be html, got \" + tag);\n                                    var documentElement = win.document.documentElement;\n                                    for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);\n                                    for (var _i8 = 0, _arrayFrom4 = arrayFrom(el.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);\n                                }(prerenderWindow, el);\n                                var _autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, _autoResize$element = autoResize.element, element = void 0 === _autoResize$element ? \"body\" : _autoResize$element;\n                                if ((element = getElementSafe(element, doc)) && (width || height)) {\n                                    var prerenderResizeListener = onResize(element, (function(_ref8) {\n                                        resize({\n                                            width: width ? _ref8.width : void 0,\n                                            height: height ? _ref8.height : void 0\n                                        });\n                                    }), {\n                                        width: width,\n                                        height: height,\n                                        win: prerenderWindow\n                                    });\n                                    event.on(EVENT.RENDERED, prerenderResizeListener.cancel);\n                                }\n                            }\n                        }\n                    }\n                }));\n            };\n            var renderContainer = function(proxyContainer, _ref9) {\n                var proxyFrame = _ref9.proxyFrame, proxyPrerenderFrame = _ref9.proxyPrerenderFrame, context = _ref9.context, uid = _ref9.uid;\n                return renderContainerOverride ? renderContainerOverride(proxyContainer, {\n                    proxyFrame: proxyFrame,\n                    proxyPrerenderFrame: proxyPrerenderFrame,\n                    context: context,\n                    uid: uid\n                }) : promise_ZalgoPromise.hash({\n                    container: proxyContainer.get(),\n                    frame: proxyFrame ? proxyFrame.get() : null,\n                    prerenderFrame: proxyPrerenderFrame ? proxyPrerenderFrame.get() : null,\n                    internalState: getInternalState()\n                }).then((function(_ref10) {\n                    var container = _ref10.container, visible = _ref10.internalState.visible;\n                    var innerContainer = renderTemplate(containerTemplate, {\n                        context: context,\n                        uid: uid,\n                        container: container,\n                        frame: _ref10.frame,\n                        prerenderFrame: _ref10.prerenderFrame,\n                        doc: document\n                    });\n                    if (innerContainer) {\n                        visible || hideElement(innerContainer);\n                        appendChild(container, innerContainer);\n                        var containerWatcher = function(element, handler) {\n                            handler = once(handler);\n                            var cancelled = !1;\n                            var mutationObservers = [];\n                            var interval;\n                            var sacrificialFrame;\n                            var sacrificialFrameWin;\n                            var cancel = function() {\n                                cancelled = !0;\n                                for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();\n                                interval && interval.cancel();\n                                sacrificialFrameWin && sacrificialFrameWin.removeEventListener(\"unload\", elementClosed);\n                                sacrificialFrame && destroyElement(sacrificialFrame);\n                            };\n                            var elementClosed = function() {\n                                if (!cancelled) {\n                                    handler();\n                                    cancel();\n                                }\n                            };\n                            if (isElementClosed(element)) {\n                                elementClosed();\n                                return {\n                                    cancel: cancel\n                                };\n                            }\n                            if (window.MutationObserver) {\n                                var mutationElement = element.parentElement;\n                                for (;mutationElement; ) {\n                                    var mutationObserver = new window.MutationObserver((function() {\n                                        isElementClosed(element) && elementClosed();\n                                    }));\n                                    mutationObserver.observe(mutationElement, {\n                                        childList: !0\n                                    });\n                                    mutationObservers.push(mutationObserver);\n                                    mutationElement = mutationElement.parentElement;\n                                }\n                            }\n                            (sacrificialFrame = document.createElement(\"iframe\")).setAttribute(\"name\", \"__detect_close_\" + uniqueID() + \"__\");\n                            sacrificialFrame.style.display = \"none\";\n                            awaitFrameWindow(sacrificialFrame).then((function(frameWin) {\n                                (sacrificialFrameWin = assertSameDomain(frameWin)).addEventListener(\"unload\", elementClosed);\n                            }));\n                            element.appendChild(sacrificialFrame);\n                            interval = safeInterval((function() {\n                                isElementClosed(element) && elementClosed();\n                            }), 1e3);\n                            return {\n                                cancel: cancel\n                            };\n                        }(innerContainer, (function() {\n                            return close(new Error(\"Detected container element removed from DOM\"));\n                        }));\n                        clean.register((function() {\n                            return containerWatcher.cancel();\n                        }));\n                        clean.register((function() {\n                            return destroyElement(innerContainer);\n                        }));\n                        return currentProxyContainer = getProxyObject(innerContainer);\n                    }\n                }));\n            };\n            var getHelpers = function() {\n                return {\n                    state: state,\n                    event: event,\n                    close: close,\n                    focus: focus,\n                    resize: resize,\n                    onError: onError,\n                    updateProps: updateProps,\n                    show: show,\n                    hide: hide\n                };\n            };\n            var setProps = function(newProps, isUpdate) {\n                void 0 === isUpdate && (isUpdate = !1);\n                var helpers = getHelpers();\n                !function(propsDef, props, inputProps, helpers, isUpdate) {\n                    void 0 === isUpdate && (isUpdate = !1);\n                    extend(props, inputProps = inputProps || {});\n                    var propNames = isUpdate ? [] : [].concat(Object.keys(propsDef));\n                    for (var _i2 = 0, _Object$keys2 = Object.keys(inputProps); _i2 < _Object$keys2.length; _i2++) {\n                        var key = _Object$keys2[_i2];\n                        -1 === propNames.indexOf(key) && propNames.push(key);\n                    }\n                    var aliases = [];\n                    var state = helpers.state, close = helpers.close, focus = helpers.focus, event = helpers.event, onError = helpers.onError;\n                    for (var _i4 = 0; _i4 < propNames.length; _i4++) {\n                        var _key = propNames[_i4];\n                        var propDef = propsDef[_key];\n                        var value = inputProps[_key];\n                        if (propDef) {\n                            var alias = propDef.alias;\n                            if (alias) {\n                                !isDefined(value) && isDefined(inputProps[alias]) && (value = inputProps[alias]);\n                                aliases.push(alias);\n                            }\n                            propDef.value && (value = propDef.value({\n                                props: props,\n                                state: state,\n                                close: close,\n                                focus: focus,\n                                event: event,\n                                onError: onError\n                            }));\n                            !isDefined(value) && propDef.default && (value = propDef.default({\n                                props: props,\n                                state: state,\n                                close: close,\n                                focus: focus,\n                                event: event,\n                                onError: onError\n                            }));\n                            if (isDefined(value) && (\"array\" === propDef.type ? !Array.isArray(value) : typeof value !== propDef.type)) throw new TypeError(\"Prop is not of type \" + propDef.type + \": \" + _key);\n                            props[_key] = value;\n                        }\n                    }\n                    for (var _i6 = 0; _i6 < aliases.length; _i6++) delete props[aliases[_i6]];\n                    for (var _i8 = 0, _Object$keys4 = Object.keys(props); _i8 < _Object$keys4.length; _i8++) {\n                        var _key2 = _Object$keys4[_i8];\n                        var _propDef = propsDef[_key2];\n                        var _value = props[_key2];\n                        _propDef && isDefined(_value) && _propDef.decorate && (props[_key2] = _propDef.decorate({\n                            value: _value,\n                            props: props,\n                            state: state,\n                            close: close,\n                            focus: focus,\n                            event: event,\n                            onError: onError\n                        }));\n                    }\n                    for (var _i10 = 0, _Object$keys6 = Object.keys(propsDef); _i10 < _Object$keys6.length; _i10++) {\n                        var _key3 = _Object$keys6[_i10];\n                        if (!1 !== propsDef[_key3].required && !isDefined(props[_key3])) throw new Error('Expected prop \"' + _key3 + '\" to be defined');\n                    }\n                }(propsDef, props, newProps, helpers, isUpdate);\n            };\n            var updateProps = function(newProps) {\n                setProps(newProps, !0);\n                return initPromise.then((function() {\n                    var child = childComponent;\n                    var proxyWin = currentProxyWin;\n                    if (child && proxyWin) return getPropsForChild(getDomainMatcher()).then((function(childProps) {\n                        return child.updateProps(childProps).catch((function(err) {\n                            return checkWindowClose(proxyWin).then((function(closed) {\n                                if (!closed) throw err;\n                            }));\n                        }));\n                    }));\n                }));\n            };\n            return {\n                init: function() {\n                    !function() {\n                        event.on(EVENT.RENDER, (function() {\n                            return props.onRender();\n                        }));\n                        event.on(EVENT.DISPLAY, (function() {\n                            return props.onDisplay();\n                        }));\n                        event.on(EVENT.RENDERED, (function() {\n                            return props.onRendered();\n                        }));\n                        event.on(EVENT.CLOSE, (function() {\n                            return props.onClose();\n                        }));\n                        event.on(EVENT.DESTROY, (function() {\n                            return props.onDestroy();\n                        }));\n                        event.on(EVENT.RESIZE, (function() {\n                            return props.onResize();\n                        }));\n                        event.on(EVENT.FOCUS, (function() {\n                            return props.onFocus();\n                        }));\n                        event.on(EVENT.PROPS, (function(newProps) {\n                            return props.onProps(newProps);\n                        }));\n                        event.on(EVENT.ERROR, (function(err) {\n                            return props && props.onError ? props.onError(err) : initPromise.reject(err).then((function() {\n                                setTimeout((function() {\n                                    throw err;\n                                }), 1);\n                            }));\n                        }));\n                        clean.register(event.reset);\n                    }();\n                },\n                render: function(target, container, context) {\n                    return promise_ZalgoPromise.try((function() {\n                        var uid = \"zoid-\" + tag + \"-\" + uniqueID();\n                        var domain = getDomainMatcher();\n                        var childDomain = getChildDomain();\n                        !function(target, domain, container) {\n                            if (target !== window) {\n                                if (!isSameTopWindow(window, target)) throw new Error(\"Can only renderTo an adjacent frame\");\n                                var origin = getDomain();\n                                if (!matchDomain(domain, origin) && !isSameDomain(target)) throw new Error(\"Can not render remotely to \" + domain.toString() + \" - can only render to \" + origin);\n                                if (container && \"string\" != typeof container) throw new Error(\"Container passed to renderTo must be a string selector, got \" + typeof container + \" }\");\n                            }\n                        }(target, domain, container);\n                        var delegatePromise = promise_ZalgoPromise.try((function() {\n                            if (target !== window) return function(context, target) {\n                                var delegateProps = {};\n                                for (var _i4 = 0, _Object$keys4 = Object.keys(props); _i4 < _Object$keys4.length; _i4++) {\n                                    var propName = _Object$keys4[_i4];\n                                    var propDef = propsDef[propName];\n                                    propDef && propDef.allowDelegate && (delegateProps[propName] = props[propName]);\n                                }\n                                var childOverridesPromise = send_send(target, \"zoid_delegate_\" + name, {\n                                    overrides: {\n                                        props: delegateProps,\n                                        event: event,\n                                        close: close,\n                                        onError: onError,\n                                        getInternalState: getInternalState,\n                                        setInternalState: setInternalState\n                                    }\n                                }).then((function(_ref11) {\n                                    var parentComp = _ref11.data.parent;\n                                    clean.register((function(err) {\n                                        if (!isWindowClosed(target)) return parentComp.destroy(err);\n                                    }));\n                                    return parentComp.getDelegateOverrides();\n                                })).catch((function(err) {\n                                    throw new Error(\"Unable to delegate rendering. Possibly the component is not loaded in the target window.\\n\\n\" + stringifyError(err));\n                                }));\n                                getProxyContainerOverride = function() {\n                                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.getProxyContainer.apply(childOverrides, args);\n                                    }));\n                                };\n                                renderContainerOverride = function() {\n                                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.renderContainer.apply(childOverrides, args);\n                                    }));\n                                };\n                                showOverride = function() {\n                                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.show.apply(childOverrides, args);\n                                    }));\n                                };\n                                hideOverride = function() {\n                                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.hide.apply(childOverrides, args);\n                                    }));\n                                };\n                                watchForUnloadOverride = function() {\n                                    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.watchForUnload.apply(childOverrides, args);\n                                    }));\n                                };\n                                if (context === CONTEXT.IFRAME) {\n                                    getProxyWindowOverride = function() {\n                                        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.getProxyWindow.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openFrameOverride = function() {\n                                        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.openFrame.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openPrerenderFrameOverride = function() {\n                                        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) args[_key8] = arguments[_key8];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.openPrerenderFrame.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    prerenderOverride = function() {\n                                        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) args[_key9] = arguments[_key9];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.prerender.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openOverride = function() {\n                                        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) args[_key10] = arguments[_key10];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.open.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openPrerenderOverride = function() {\n                                        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) args[_key11] = arguments[_key11];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.openPrerender.apply(childOverrides, args);\n                                        }));\n                                    };\n                                }\n                                return childOverridesPromise;\n                            }(context, target);\n                        }));\n                        var windowProp = props.window;\n                        var watchForUnloadPromise = watchForUnload();\n                        var buildUrlPromise = function(propsDef, props) {\n                            var params = {};\n                            var keys = Object.keys(props);\n                            return promise_ZalgoPromise.all(keys.map((function(key) {\n                                var prop = propsDef[key];\n                                if (prop) return promise_ZalgoPromise.resolve().then((function() {\n                                    var value = props[key];\n                                    if (value && prop.queryParam) return value;\n                                })).then((function(value) {\n                                    if (null != value) return promise_ZalgoPromise.all([ props_getQueryParam(prop, key, value), getQueryValue(prop, 0, value) ]).then((function(_ref) {\n                                        var queryParam = _ref[0], queryValue = _ref[1];\n                                        var result;\n                                        if (\"boolean\" == typeof queryValue) result = queryValue.toString(); else if (\"string\" == typeof queryValue) result = queryValue.toString(); else if (\"object\" == typeof queryValue && null !== queryValue) {\n                                            if (prop.serialization === PROP_SERIALIZATION.JSON) result = JSON.stringify(queryValue); else if (prop.serialization === PROP_SERIALIZATION.BASE64) result = btoa(JSON.stringify(queryValue)); else if (prop.serialization === PROP_SERIALIZATION.DOTIFY || !prop.serialization) {\n                                                result = function dotify(obj, prefix, newobj) {\n                                                    void 0 === prefix && (prefix = \"\");\n                                                    void 0 === newobj && (newobj = {});\n                                                    prefix = prefix ? prefix + \".\" : prefix;\n                                                    for (var key in obj) obj.hasOwnProperty(key) && null != obj[key] && \"function\" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every((function(val) {\n                                                        return \"object\" != typeof val;\n                                                    })) ? newobj[\"\" + prefix + key + \"[]\"] = obj[key].join(\",\") : obj[key] && \"object\" == typeof obj[key] ? newobj = dotify(obj[key], \"\" + prefix + key, newobj) : newobj[\"\" + prefix + key] = obj[key].toString());\n                                                    return newobj;\n                                                }(queryValue, key);\n                                                for (var _i12 = 0, _Object$keys8 = Object.keys(result); _i12 < _Object$keys8.length; _i12++) {\n                                                    var dotkey = _Object$keys8[_i12];\n                                                    params[dotkey] = result[dotkey];\n                                                }\n                                                return;\n                                            }\n                                        } else \"number\" == typeof queryValue && (result = queryValue.toString());\n                                        params[queryParam] = result;\n                                    }));\n                                }));\n                            }))).then((function() {\n                                return params;\n                            }));\n                        }(propsDef, props).then((function(query) {\n                            return function(url, options) {\n                                var query = options.query || {};\n                                var hash = options.hash || {};\n                                var originalUrl;\n                                var originalHash;\n                                var _url$split = url.split(\"#\");\n                                originalHash = _url$split[1];\n                                var _originalUrl$split = (originalUrl = _url$split[0]).split(\"?\");\n                                originalUrl = _originalUrl$split[0];\n                                var queryString = extendQuery(_originalUrl$split[1], query);\n                                var hashString = extendQuery(originalHash, hash);\n                                queryString && (originalUrl = originalUrl + \"?\" + queryString);\n                                hashString && (originalUrl = originalUrl + \"#\" + hashString);\n                                return originalUrl;\n                            }(function(url) {\n                                if (!(domain = getDomainFromUrl(url), 0 === domain.indexOf(\"mock:\"))) return url;\n                                var domain;\n                                throw new Error(\"Mock urls not supported out of test mode\");\n                            }(getUrl()), {\n                                query: query\n                            });\n                        }));\n                        var onRenderPromise = event.trigger(EVENT.RENDER);\n                        var getProxyContainerPromise = getProxyContainer(container);\n                        var getProxyWindowPromise = getProxyWindow();\n                        var buildWindowNamePromise = getProxyWindowPromise.then((function(proxyWin) {\n                            return function(_temp) {\n                                var _ref4 = void 0 === _temp ? {} : _temp, proxyWin = _ref4.proxyWin, childDomain = _ref4.childDomain, domain = _ref4.domain, context = (void 0 === _ref4.target && window, \n                                _ref4.context), uid = _ref4.uid;\n                                return function(proxyWin, childDomain, domain, uid) {\n                                    return getPropsForChild(domain).then((function(childProps) {\n                                        var value = setup_serializeMessage(proxyWin, domain, childProps);\n                                        var propRef = childDomain === getDomain() ? {\n                                            type: \"uid\",\n                                            uid: uid\n                                        } : {\n                                            type: \"raw\",\n                                            value: value\n                                        };\n                                        if (\"uid\" === propRef.type) {\n                                            var global = lib_global_getGlobal(window);\n                                            global.props = global.props || {};\n                                            global.props[uid] = value;\n                                            clean.register((function() {\n                                                delete global.props[uid];\n                                            }));\n                                        }\n                                        return propRef;\n                                    }));\n                                }(proxyWin, childDomain, domain, uid).then((function(propsRef) {\n                                    return {\n                                        uid: uid,\n                                        context: context,\n                                        tag: tag,\n                                        version: \"9_0_63\",\n                                        childDomain: childDomain,\n                                        parentDomain: getDomain(window),\n                                        parent: getWindowRef(0, childDomain, uid, context),\n                                        props: propsRef,\n                                        exports: setup_serializeMessage(proxyWin, domain, (win = proxyWin, {\n                                            init: initChild,\n                                            close: close,\n                                            checkClose: function() {\n                                                return checkWindowClose(win);\n                                            },\n                                            resize: resize,\n                                            onError: onError,\n                                            show: show,\n                                            hide: hide\n                                        }))\n                                    };\n                                    var win;\n                                }));\n                            }({\n                                proxyWin: (_ref5 = {\n                                    proxyWin: proxyWin,\n                                    childDomain: childDomain,\n                                    domain: domain,\n                                    target: target,\n                                    context: context,\n                                    uid: uid\n                                }).proxyWin,\n                                childDomain: _ref5.childDomain,\n                                domain: _ref5.domain,\n                                target: _ref5.target,\n                                context: _ref5.context,\n                                uid: _ref5.uid\n                            }).then((function(childPayload) {\n                                return \"__zoid__\" + name + \"__\" + base64encode(JSON.stringify(childPayload)) + \"__\";\n                            }));\n                            var _ref5;\n                        }));\n                        var openFramePromise = buildWindowNamePromise.then((function(windowName) {\n                            return openFrame(context, {\n                                windowName: windowName\n                            });\n                        }));\n                        var openPrerenderFramePromise = openPrerenderFrame(context);\n                        var renderContainerPromise = promise_ZalgoPromise.hash({\n                            proxyContainer: getProxyContainerPromise,\n                            proxyFrame: openFramePromise,\n                            proxyPrerenderFrame: openPrerenderFramePromise\n                        }).then((function(_ref12) {\n                            return renderContainer(_ref12.proxyContainer, {\n                                context: context,\n                                uid: uid,\n                                proxyFrame: _ref12.proxyFrame,\n                                proxyPrerenderFrame: _ref12.proxyPrerenderFrame\n                            });\n                        })).then((function(proxyContainer) {\n                            return proxyContainer;\n                        }));\n                        var openPromise = promise_ZalgoPromise.hash({\n                            windowName: buildWindowNamePromise,\n                            proxyFrame: openFramePromise,\n                            proxyWin: getProxyWindowPromise\n                        }).then((function(_ref13) {\n                            var proxyWin = _ref13.proxyWin;\n                            return windowProp ? proxyWin : open(context, {\n                                windowName: _ref13.windowName,\n                                proxyWin: proxyWin,\n                                proxyFrame: _ref13.proxyFrame\n                            });\n                        }));\n                        var openPrerenderPromise = promise_ZalgoPromise.hash({\n                            proxyWin: openPromise,\n                            proxyPrerenderFrame: openPrerenderFramePromise\n                        }).then((function(_ref14) {\n                            return openPrerender(context, _ref14.proxyWin, _ref14.proxyPrerenderFrame);\n                        }));\n                        var setStatePromise = openPromise.then((function(proxyWin) {\n                            currentProxyWin = proxyWin;\n                            return setProxyWin(proxyWin);\n                        }));\n                        var prerenderPromise = promise_ZalgoPromise.hash({\n                            proxyPrerenderWin: openPrerenderPromise,\n                            state: setStatePromise\n                        }).then((function(_ref15) {\n                            return prerender(_ref15.proxyPrerenderWin, {\n                                context: context,\n                                uid: uid\n                            });\n                        }));\n                        var setWindowNamePromise = promise_ZalgoPromise.hash({\n                            proxyWin: openPromise,\n                            windowName: buildWindowNamePromise\n                        }).then((function(_ref16) {\n                            if (windowProp) return _ref16.proxyWin.setName(_ref16.windowName);\n                        }));\n                        var loadUrlPromise = promise_ZalgoPromise.hash({\n                            proxyWin: openPromise,\n                            builtUrl: buildUrlPromise,\n                            windowName: setWindowNamePromise,\n                            prerender: prerenderPromise\n                        }).then((function(_ref17) {\n                            return _ref17.proxyWin.setLocation(_ref17.builtUrl);\n                        }));\n                        var watchForClosePromise = openPromise.then((function(proxyWin) {\n                            !function watchForClose(proxyWin, context) {\n                                var cancelled = !1;\n                                clean.register((function() {\n                                    cancelled = !0;\n                                }));\n                                return promise_ZalgoPromise.delay(2e3).then((function() {\n                                    return proxyWin.isClosed();\n                                })).then((function(isClosed) {\n                                    return isClosed ? close(new Error(\"Detected \" + context + \" close\")) : cancelled ? void 0 : watchForClose(proxyWin, context);\n                                }));\n                            }(proxyWin, context);\n                        }));\n                        var onDisplayPromise = promise_ZalgoPromise.hash({\n                            container: renderContainerPromise,\n                            prerender: prerenderPromise\n                        }).then((function() {\n                            return event.trigger(EVENT.DISPLAY);\n                        }));\n                        var openBridgePromise = openPromise.then((function(proxyWin) {}));\n                        var runTimeoutPromise = loadUrlPromise.then((function() {\n                            return promise_ZalgoPromise.try((function() {\n                                var timeout = props.timeout;\n                                if (timeout) return initPromise.timeout(timeout, new Error(\"Loading component timed out after \" + timeout + \" milliseconds\"));\n                            }));\n                        }));\n                        var onRenderedPromise = initPromise.then((function() {\n                            return event.trigger(EVENT.RENDERED);\n                        }));\n                        return promise_ZalgoPromise.hash({\n                            initPromise: initPromise,\n                            buildUrlPromise: buildUrlPromise,\n                            onRenderPromise: onRenderPromise,\n                            getProxyContainerPromise: getProxyContainerPromise,\n                            openFramePromise: openFramePromise,\n                            openPrerenderFramePromise: openPrerenderFramePromise,\n                            renderContainerPromise: renderContainerPromise,\n                            openPromise: openPromise,\n                            openPrerenderPromise: openPrerenderPromise,\n                            setStatePromise: setStatePromise,\n                            prerenderPromise: prerenderPromise,\n                            loadUrlPromise: loadUrlPromise,\n                            buildWindowNamePromise: buildWindowNamePromise,\n                            setWindowNamePromise: setWindowNamePromise,\n                            watchForClosePromise: watchForClosePromise,\n                            onDisplayPromise: onDisplayPromise,\n                            openBridgePromise: openBridgePromise,\n                            runTimeoutPromise: runTimeoutPromise,\n                            onRenderedPromise: onRenderedPromise,\n                            delegatePromise: delegatePromise,\n                            watchForUnloadPromise: watchForUnloadPromise\n                        });\n                    })).catch((function(err) {\n                        return promise_ZalgoPromise.all([ onError(err), destroy(err) ]).then((function() {\n                            throw err;\n                        }), (function() {\n                            throw err;\n                        }));\n                    })).then(src_util_noop);\n                },\n                destroy: destroy,\n                setProps: setProps,\n                getHelpers: getHelpers,\n                getDelegateOverrides: function() {\n                    return promise_ZalgoPromise.try((function() {\n                        return {\n                            getProxyContainer: getProxyContainer,\n                            show: show,\n                            hide: hide,\n                            renderContainer: renderContainer,\n                            getProxyWindow: getProxyWindow,\n                            watchForUnload: watchForUnload,\n                            openFrame: openFrame,\n                            openPrerenderFrame: openPrerenderFrame,\n                            prerender: prerender,\n                            open: open,\n                            openPrerender: openPrerender,\n                            setProxyWin: setProxyWin\n                        };\n                    }));\n                }\n            };\n        }\n        var react = {\n            register: function(tag, propsDef, init, _ref) {\n                var React = _ref.React, ReactDOM = _ref.ReactDOM;\n                return function(_React$Component) {\n                    _inheritsLoose(_class, _React$Component);\n                    function _class() {\n                        return _React$Component.apply(this, arguments) || this;\n                    }\n                    var _proto = _class.prototype;\n                    _proto.render = function() {\n                        return React.createElement(\"div\", null);\n                    };\n                    _proto.componentDidMount = function() {\n                        var el = ReactDOM.findDOMNode(this);\n                        var parent = init(extend({}, this.props));\n                        parent.render(el, CONTEXT.IFRAME);\n                        this.setState({\n                            parent: parent\n                        });\n                    };\n                    _proto.componentDidUpdate = function() {\n                        this.state && this.state.parent && this.state.parent.updateProps(extend({}, this.props)).catch(src_util_noop);\n                    };\n                    return _class;\n                }(React.Component);\n            }\n        };\n        var vue = {\n            register: function(tag, propsDef, init, Vue) {\n                return Vue.component(tag, {\n                    render: function(createElement) {\n                        return createElement(\"div\");\n                    },\n                    inheritAttrs: !1,\n                    mounted: function() {\n                        var el = this.$el;\n                        this.parent = init(_extends({}, this.$attrs));\n                        this.parent.render(el, CONTEXT.IFRAME);\n                    },\n                    watch: {\n                        $attrs: {\n                            handler: function() {\n                                this.parent && this.$attrs && this.parent.updateProps(_extends({}, this.$attrs)).catch(src_util_noop);\n                            },\n                            deep: !0\n                        }\n                    }\n                });\n            }\n        };\n        var angular = {\n            register: function(tag, propsDef, init, ng) {\n                return ng.module(tag, []).directive(tag.replace(/-([a-z])/g, (function(g) {\n                    return g[1].toUpperCase();\n                })), (function() {\n                    var scope = {};\n                    for (var _i2 = 0, _Object$keys2 = Object.keys(propsDef); _i2 < _Object$keys2.length; _i2++) scope[_Object$keys2[_i2]] = \"=\";\n                    scope.props = \"=\";\n                    return {\n                        scope: scope,\n                        restrict: \"E\",\n                        controller: [ \"$scope\", \"$element\", function($scope, $element) {\n                            function safeApply() {\n                                if (\"$apply\" !== $scope.$root.$$phase && \"$digest\" !== $scope.$root.$$phase) try {\n                                    $scope.$apply();\n                                } catch (err) {}\n                            }\n                            var getProps = function() {\n                                return replaceObject($scope.props, (function(item) {\n                                    return \"function\" == typeof item ? function() {\n                                        var result = item.apply(this, arguments);\n                                        safeApply();\n                                        return result;\n                                    } : item;\n                                }));\n                            };\n                            var instance = init(getProps());\n                            instance.render($element[0], CONTEXT.IFRAME);\n                            $scope.$watch((function() {\n                                instance.updateProps(getProps()).catch(src_util_noop);\n                            }));\n                        } ]\n                    };\n                }));\n            }\n        };\n        var angular2 = {\n            register: function(tag, propsDef, init, _ref) {\n                var NgModule = _ref.NgModule, ElementRef = _ref.ElementRef, NgZone = _ref.NgZone;\n                var getProps = function(component) {\n                    return replaceObject(_extends({}, component.internalProps, component.props), (function(item) {\n                        return \"function\" == typeof item ? function() {\n                            var _arguments = arguments, _this = this;\n                            return component.zone.run((function() {\n                                return item.apply(_this, _arguments);\n                            }));\n                        } : item;\n                    }));\n                };\n                var ComponentInstance = (0, _ref.Component)({\n                    selector: tag,\n                    template: \"<div></div>\",\n                    inputs: [ \"props\" ]\n                }).Class({\n                    constructor: [ ElementRef, NgZone, function(elementRef, zone) {\n                        this._props = {};\n                        this.elementRef = elementRef;\n                        this.zone = zone;\n                    } ],\n                    ngOnInit: function() {\n                        var targetElement = this.elementRef.nativeElement;\n                        this.parent = init(getProps(this));\n                        this.parent.render(targetElement, CONTEXT.IFRAME);\n                    },\n                    ngDoCheck: function() {\n                        if (this.parent && !function(obj1, obj2) {\n                            var checked = {};\n                            for (var key in obj1) if (obj1.hasOwnProperty(key)) {\n                                checked[key] = !0;\n                                if (obj1[key] !== obj2[key]) return !1;\n                            }\n                            for (var _key in obj2) if (!checked[_key]) return !1;\n                            return !0;\n                        }(this._props, this.props)) {\n                            this._props = _extends({}, this.props);\n                            this.parent.updateProps(getProps(this));\n                        }\n                    }\n                });\n                return NgModule({\n                    declarations: [ ComponentInstance ],\n                    exports: [ ComponentInstance ]\n                }).Class({\n                    constructor: function() {}\n                });\n            }\n        };\n        function defaultContainerTemplate(_ref) {\n            var uid = _ref.uid, frame = _ref.frame, prerenderFrame = _ref.prerenderFrame, doc = _ref.doc, props = _ref.props, event = _ref.event, _ref$dimensions = _ref.dimensions, width = _ref$dimensions.width, height = _ref$dimensions.height;\n            if (frame && prerenderFrame) {\n                var div = doc.createElement(\"div\");\n                div.setAttribute(\"id\", uid);\n                var style = doc.createElement(\"style\");\n                props.cspNonce && style.setAttribute(\"nonce\", props.cspNonce);\n                style.appendChild(doc.createTextNode(\"\\n            #\" + uid + \" {\\n                display: inline-block;\\n                position: relative;\\n                width: \" + width + \";\\n                height: \" + height + \";\\n            }\\n\\n            #\" + uid + \" > iframe {\\n                display: inline-block;\\n                position: absolute;\\n                width: 100%;\\n                height: 100%;\\n                top: 0;\\n                left: 0;\\n                transition: opacity .2s ease-in-out;\\n            }\\n\\n            #\" + uid + \" > iframe.zoid-invisible {\\n                opacity: 0;\\n            }\\n\\n            #\" + uid + \" > iframe.zoid-visible {\\n                opacity: 1;\\n        }\\n        \"));\n                div.appendChild(frame);\n                div.appendChild(prerenderFrame);\n                div.appendChild(style);\n                prerenderFrame.classList.add(\"zoid-visible\");\n                frame.classList.add(\"zoid-invisible\");\n                event.on(EVENT.RENDERED, (function() {\n                    prerenderFrame.classList.remove(\"zoid-visible\");\n                    prerenderFrame.classList.add(\"zoid-invisible\");\n                    frame.classList.remove(\"zoid-invisible\");\n                    frame.classList.add(\"zoid-visible\");\n                    setTimeout((function() {\n                        destroyElement(prerenderFrame);\n                    }), 1);\n                }));\n                event.on(EVENT.RESIZE, (function(_ref2) {\n                    var newWidth = _ref2.width, newHeight = _ref2.height;\n                    \"number\" == typeof newWidth && (div.style.width = toCSS(newWidth));\n                    \"number\" == typeof newHeight && (div.style.height = toCSS(newHeight));\n                }));\n                return div;\n            }\n        }\n        function defaultPrerenderTemplate(_ref) {\n            var doc = _ref.doc, props = _ref.props;\n            var html = doc.createElement(\"html\");\n            var body = doc.createElement(\"body\");\n            var style = doc.createElement(\"style\");\n            var spinner = doc.createElement(\"div\");\n            spinner.classList.add(\"spinner\");\n            props.cspNonce && style.setAttribute(\"nonce\", props.cspNonce);\n            html.appendChild(body);\n            body.appendChild(spinner);\n            body.appendChild(style);\n            style.appendChild(doc.createTextNode(\"\\n            html, body {\\n                width: 100%;\\n                height: 100%;\\n            }\\n\\n            .spinner {\\n                position: fixed;\\n                max-height: 60vmin;\\n                max-width: 60vmin;\\n                height: 40px;\\n                width: 40px;\\n                top: 50%;\\n                left: 50%;\\n                box-sizing: border-box;\\n                border: 3px solid rgba(0, 0, 0, .2);\\n                border-top-color: rgba(33, 128, 192, 0.8);\\n                border-radius: 100%;\\n                animation: rotation .7s infinite linear;\\n            }\\n\\n            @keyframes rotation {\\n                from {\\n                    transform: translateX(-50%) translateY(-50%) rotate(0deg);\\n                }\\n                to {\\n                    transform: translateX(-50%) translateY(-50%) rotate(359deg);\\n                }\\n            }\\n        \"));\n            return html;\n        }\n        var props_defaultNoop = function() {\n            return src_util_noop;\n        };\n        var props_decorateOnce = function(_ref) {\n            return once(_ref.value);\n        };\n        var cleanInstances = cleanup();\n        var cleanZoid = cleanup();\n        function component_component(opts) {\n            var options = function(options) {\n                var tag = options.tag, url = options.url, domain = options.domain, bridgeUrl = options.bridgeUrl, _options$props = options.props, propsDef = void 0 === _options$props ? {} : _options$props, _options$dimensions = options.dimensions, dimensions = void 0 === _options$dimensions ? {} : _options$dimensions, _options$autoResize = options.autoResize, autoResize = void 0 === _options$autoResize ? {} : _options$autoResize, _options$allowedParen = options.allowedParentDomains, allowedParentDomains = void 0 === _options$allowedParen ? \"*\" : _options$allowedParen, _options$attributes = options.attributes, attributes = void 0 === _options$attributes ? {} : _options$attributes, _options$defaultConte = options.defaultContext, defaultContext = void 0 === _options$defaultConte ? CONTEXT.IFRAME : _options$defaultConte, _options$containerTem = options.containerTemplate, containerTemplate = void 0 === _options$containerTem ? defaultContainerTemplate : _options$containerTem, _options$prerenderTem = options.prerenderTemplate, prerenderTemplate = void 0 === _options$prerenderTem ? defaultPrerenderTemplate : _options$prerenderTem, validate = options.validate, _options$eligible = options.eligible, eligible = void 0 === _options$eligible ? function() {\n                    return {\n                        eligible: !0\n                    };\n                } : _options$eligible, _options$logger = options.logger, logger = void 0 === _options$logger ? {\n                    info: src_util_noop\n                } : _options$logger;\n                var name = tag.replace(/-/g, \"_\");\n                var _dimensions$width = dimensions.width, width = void 0 === _dimensions$width ? \"300px\" : _dimensions$width, _dimensions$height = dimensions.height, height = void 0 === _dimensions$height ? \"150px\" : _dimensions$height;\n                propsDef = _extends({}, {\n                    window: {\n                        type: \"object\",\n                        sendToChild: !1,\n                        required: !1,\n                        allowDelegate: !0,\n                        validate: function(_ref2) {\n                            var value = _ref2.value;\n                            if (!isWindow(value) && !window_ProxyWindow.isProxyWindow(value)) throw new Error(\"Expected Window or ProxyWindow\");\n                            if (isWindow(value)) {\n                                if (isWindowClosed(value)) throw new Error(\"Window is closed\");\n                                if (!isSameDomain(value)) throw new Error(\"Window is not same domain\");\n                            }\n                        },\n                        decorate: function(_ref3) {\n                            return setup_toProxyWindow(_ref3.value);\n                        }\n                    },\n                    timeout: {\n                        type: \"number\",\n                        required: !1,\n                        sendToChild: !1\n                    },\n                    close: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref4) {\n                            return _ref4.close;\n                        }\n                    },\n                    focus: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref5) {\n                            return _ref5.focus;\n                        }\n                    },\n                    resize: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref6) {\n                            return _ref6.resize;\n                        }\n                    },\n                    uid: {\n                        type: \"string\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref7) {\n                            return _ref7.uid;\n                        }\n                    },\n                    cspNonce: {\n                        type: \"string\",\n                        required: !1\n                    },\n                    getParent: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref8) {\n                            return _ref8.getParent;\n                        }\n                    },\n                    getParentDomain: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref9) {\n                            return _ref9.getParentDomain;\n                        }\n                    },\n                    show: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref10) {\n                            return _ref10.show;\n                        }\n                    },\n                    hide: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref11) {\n                            return _ref11.hide;\n                        }\n                    },\n                    onDisplay: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onRendered: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onRender: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onClose: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onDestroy: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onResize: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop\n                    },\n                    onFocus: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop\n                    },\n                    onError: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref12) {\n                            return _ref12.onError;\n                        }\n                    },\n                    onProps: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        default: props_defaultNoop,\n                        childDecorate: function(_ref13) {\n                            return _ref13.onProps;\n                        }\n                    }\n                }, propsDef);\n                if (!containerTemplate) throw new Error(\"Container template required\");\n                return {\n                    name: name,\n                    tag: tag,\n                    url: url,\n                    domain: domain,\n                    bridgeUrl: bridgeUrl,\n                    propsDef: propsDef,\n                    dimensions: {\n                        width: width,\n                        height: height\n                    },\n                    autoResize: autoResize,\n                    allowedParentDomains: allowedParentDomains,\n                    attributes: attributes,\n                    defaultContext: defaultContext,\n                    containerTemplate: containerTemplate,\n                    prerenderTemplate: prerenderTemplate,\n                    validate: validate,\n                    logger: logger,\n                    eligible: eligible\n                };\n            }(opts);\n            var name = options.name, tag = options.tag, defaultContext = options.defaultContext, propsDef = options.propsDef, eligible = options.eligible;\n            var global = lib_global_getGlobal();\n            var driverCache = {};\n            var instances = [];\n            var isChild = function() {\n                var payload = getChildPayload();\n                return Boolean(payload && payload.tag === tag && payload.childDomain === getDomain());\n            };\n            var registerChild = memoize((function() {\n                if (isChild()) {\n                    if (window.xprops) {\n                        delete global.components[tag];\n                        throw new Error(\"Can not register \" + name + \" as child - child already registered\");\n                    }\n                    var child = function(options) {\n                        var propsDef = options.propsDef, autoResize = options.autoResize, allowedParentDomains = options.allowedParentDomains;\n                        var onPropHandlers = [];\n                        var childPayload = getChildPayload();\n                        var props;\n                        if (!childPayload) throw new Error(\"No child payload found\");\n                        if (\"9_0_63\" !== childPayload.version) throw new Error(\"Parent window has zoid version \" + childPayload.version + \", child window has version 9_0_63\");\n                        var uid = childPayload.uid, parentDomain = childPayload.parentDomain, exports = childPayload.exports, context = childPayload.context, propsRef = childPayload.props;\n                        var parentComponentWindow = function(ref) {\n                            var type = ref.type;\n                            if (\"opener\" === type) return assertExists(\"opener\", getOpener(window));\n                            if (\"parent\" === type && \"number\" == typeof ref.distance) return assertExists(\"parent\", function(win, n) {\n                                void 0 === n && (n = 1);\n                                return function(win, n) {\n                                    void 0 === n && (n = 1);\n                                    var parent = win;\n                                    for (var i = 0; i < n; i++) {\n                                        if (!parent) return;\n                                        parent = utils_getParent(parent);\n                                    }\n                                    return parent;\n                                }(win, getDistanceFromTop(win) - n);\n                            }(window, ref.distance));\n                            if (\"global\" === type && ref.uid && \"string\" == typeof ref.uid) {\n                                var uid = ref.uid;\n                                var ancestor = getAncestor(window);\n                                if (!ancestor) throw new Error(\"Can not find ancestor window\");\n                                for (var _i2 = 0, _getAllFramesInWindow2 = getAllFramesInWindow(ancestor); _i2 < _getAllFramesInWindow2.length; _i2++) {\n                                    var frame = _getAllFramesInWindow2[_i2];\n                                    if (isSameDomain(frame)) {\n                                        var global = lib_global_getGlobal(frame);\n                                        if (global && global.windows && global.windows[uid]) return global.windows[uid];\n                                    }\n                                }\n                            }\n                            throw new Error(\"Unable to find \" + type + \" parent component window\");\n                        }(childPayload.parent);\n                        var parent = setup_deserializeMessage(parentComponentWindow, parentDomain, exports);\n                        var show = parent.show, hide = parent.hide, close = parent.close;\n                        var getParent = function() {\n                            return parentComponentWindow;\n                        };\n                        var getParentDomain = function() {\n                            return parentDomain;\n                        };\n                        var onProps = function(handler) {\n                            onPropHandlers.push(handler);\n                        };\n                        var onError = function(err) {\n                            return promise_ZalgoPromise.try((function() {\n                                if (parent && parent.onError) return parent.onError(err);\n                                throw err;\n                            }));\n                        };\n                        var resize = function(_ref2) {\n                            return parent.resize.fireAndForget({\n                                width: _ref2.width,\n                                height: _ref2.height\n                            });\n                        };\n                        var setProps = function(newProps, origin, isUpdate) {\n                            void 0 === isUpdate && (isUpdate = !1);\n                            var normalizedProps = function(parentComponentWindow, propsDef, props, origin, helpers, isUpdate) {\n                                void 0 === isUpdate && (isUpdate = !1);\n                                var result = {};\n                                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {\n                                    var key = _Object$keys2[_i2];\n                                    var prop = propsDef[key];\n                                    if (!prop || !prop.sameDomain || origin === getDomain(window) && isSameDomain(parentComponentWindow)) {\n                                        var value = normalizeChildProp(propsDef, 0, key, props[key], helpers);\n                                        result[key] = value;\n                                        prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);\n                                    }\n                                }\n                                if (!isUpdate) for (var _i4 = 0, _Object$keys4 = Object.keys(propsDef); _i4 < _Object$keys4.length; _i4++) {\n                                    var _key = _Object$keys4[_i4];\n                                    props.hasOwnProperty(_key) || (result[_key] = normalizeChildProp(propsDef, 0, _key, void 0, helpers));\n                                }\n                                return result;\n                            }(parentComponentWindow, propsDef, newProps, origin, {\n                                show: show,\n                                hide: hide,\n                                close: close,\n                                focus: child_focus,\n                                onError: onError,\n                                resize: resize,\n                                onProps: onProps,\n                                getParent: getParent,\n                                getParentDomain: getParentDomain,\n                                uid: uid\n                            }, isUpdate);\n                            props ? extend(props, normalizedProps) : props = normalizedProps;\n                            for (var _i4 = 0; _i4 < onPropHandlers.length; _i4++) (0, onPropHandlers[_i4])(props);\n                        };\n                        var updateProps = function(newProps) {\n                            return promise_ZalgoPromise.try((function() {\n                                return setProps(newProps, parentDomain, !0);\n                            }));\n                        };\n                        return {\n                            init: function() {\n                                return promise_ZalgoPromise.try((function() {\n                                    !function(allowedParentDomains, domain) {\n                                        if (!matchDomain(allowedParentDomains, domain)) throw new Error(\"Can not be rendered by domain: \" + domain);\n                                    }(allowedParentDomains, parentDomain);\n                                    markWindowKnown(parentComponentWindow);\n                                    !function() {\n                                        window.addEventListener(\"beforeunload\", (function() {\n                                            parent.checkClose.fireAndForget();\n                                        }));\n                                        window.addEventListener(\"unload\", (function() {\n                                            parent.checkClose.fireAndForget();\n                                        }));\n                                        onCloseWindow(parentComponentWindow, (function() {\n                                            child_destroy();\n                                        }));\n                                    }();\n                                    return parent.init({\n                                        updateProps: updateProps,\n                                        close: child_destroy\n                                    });\n                                })).then((function() {\n                                    return (_autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, \n                                    _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, \n                                    _autoResize$element = autoResize.element, elementReady(void 0 === _autoResize$element ? \"body\" : _autoResize$element).catch(src_util_noop).then((function(element) {\n                                        return {\n                                            width: width,\n                                            height: height,\n                                            element: element\n                                        };\n                                    }))).then((function(_ref3) {\n                                        var width = _ref3.width, height = _ref3.height, element = _ref3.element;\n                                        element && (width || height) && context !== CONTEXT.POPUP && onResize(element, (function(_ref4) {\n                                            resize({\n                                                width: width ? _ref4.width : void 0,\n                                                height: height ? _ref4.height : void 0\n                                            });\n                                        }), {\n                                            width: width,\n                                            height: height\n                                        });\n                                    }));\n                                    var _autoResize$width, width, _autoResize$height, height, _autoResize$element;\n                                })).catch((function(err) {\n                                    onError(err);\n                                }));\n                            },\n                            getProps: function() {\n                                if (props) return props;\n                                setProps(function(parentComponentWindow, domain, _ref) {\n                                    var type = _ref.type, uid = _ref.uid;\n                                    var props;\n                                    if (\"raw\" === type) props = _ref.value; else if (\"uid\" === type) {\n                                        if (!isSameDomain(parentComponentWindow)) throw new Error(\"Parent component window is on a different domain - expected \" + getDomain() + \" - can not retrieve props\");\n                                        var global = lib_global_getGlobal(parentComponentWindow);\n                                        props = assertExists(\"props\", global && global.props[uid]);\n                                    }\n                                    if (!props) throw new Error(\"Could not find props\");\n                                    return setup_deserializeMessage(parentComponentWindow, domain, props);\n                                }(parentComponentWindow, parentDomain, propsRef), parentDomain);\n                                return props;\n                            }\n                        };\n                    }(options);\n                    child.init();\n                    return child;\n                }\n            }));\n            var init = function init(props) {\n                var instance;\n                var _eligible = eligible({\n                    props: props = props || {}\n                }), eligibility = _eligible.eligible, reason = _eligible.reason;\n                var onDestroy = props.onDestroy;\n                props.onDestroy = function() {\n                    instance && eligibility && instances.splice(instances.indexOf(instance), 1);\n                    if (onDestroy) return onDestroy.apply(void 0, arguments);\n                };\n                var parent = parentComponent(options);\n                parent.init();\n                eligibility ? parent.setProps(props) : props.onDestroy && props.onDestroy();\n                cleanInstances.register((function(err) {\n                    parent.destroy(err || new Error(\"zoid destroyed all components\"));\n                }));\n                var _render = function(target, container, context) {\n                    return promise_ZalgoPromise.try((function() {\n                        if (!eligibility) {\n                            var err = new Error(reason || name + \" component is not eligible\");\n                            return parent.destroy(err).then((function() {\n                                throw err;\n                            }));\n                        }\n                        if (!isWindow(target)) throw new Error(\"Must pass window to renderTo\");\n                        return function(props, context) {\n                            return promise_ZalgoPromise.try((function() {\n                                if (props.window) return setup_toProxyWindow(props.window).getType();\n                                if (context) {\n                                    if (context !== CONTEXT.IFRAME && context !== CONTEXT.POPUP) throw new Error(\"Unrecognized context: \" + context);\n                                    return context;\n                                }\n                                return defaultContext;\n                            }));\n                        }(props, context);\n                    })).then((function(finalContext) {\n                        container = function(context, container) {\n                            if (container) {\n                                if (\"string\" != typeof container && !isElement(container)) throw new TypeError(\"Expected string or element selector to be passed\");\n                                return container;\n                            }\n                            if (context === CONTEXT.POPUP) return \"body\";\n                            throw new Error(\"Expected element to be passed to render iframe\");\n                        }(finalContext, container);\n                        return parent.render(target, container, finalContext);\n                    })).catch((function(err) {\n                        return parent.destroy(err).then((function() {\n                            throw err;\n                        }));\n                    }));\n                };\n                instance = _extends({}, parent.getHelpers(), {\n                    isEligible: function() {\n                        return eligibility;\n                    },\n                    clone: function(_temp) {\n                        var _ref3$decorate = (void 0 === _temp ? {} : _temp).decorate;\n                        return init((void 0 === _ref3$decorate ? identity : _ref3$decorate)(props));\n                    },\n                    render: function(container, context) {\n                        return _render(window, container, context);\n                    },\n                    renderTo: function(target, container, context) {\n                        return _render(target, container, context);\n                    }\n                });\n                eligibility && instances.push(instance);\n                return instance;\n            };\n            registerChild();\n            !function() {\n                var allowDelegateListener = on_on(\"zoid_allow_delegate_\" + name, (function() {\n                    return !0;\n                }));\n                var delegateListener = on_on(\"zoid_delegate_\" + name, (function(_ref) {\n                    return {\n                        parent: parentComponent(options, _ref.data.overrides, _ref.source)\n                    };\n                }));\n                cleanZoid.register(allowDelegateListener.cancel);\n                cleanZoid.register(delegateListener.cancel);\n            }();\n            global.components = global.components || {};\n            if (global.components[tag]) throw new Error(\"Can not register multiple components with the same tag: \" + tag);\n            global.components[tag] = !0;\n            return {\n                init: init,\n                instances: instances,\n                driver: function(driverName, dep) {\n                    var drivers = {\n                        react: react,\n                        angular: angular,\n                        vue: vue,\n                        angular2: angular2\n                    };\n                    if (!drivers[driverName]) throw new Error(\"Could not find driver for framework: \" + driverName);\n                    driverCache[driverName] || (driverCache[driverName] = drivers[driverName].register(tag, propsDef, init, dep));\n                    return driverCache[driverName];\n                },\n                isChild: isChild,\n                canRenderTo: function(win) {\n                    return send_send(win, \"zoid_allow_delegate_\" + name).then((function(_ref2) {\n                        return _ref2.data;\n                    })).catch((function() {\n                        return !1;\n                    }));\n                },\n                registerChild: registerChild\n            };\n        }\n        function create(options) {\n            !function() {\n                if (!global_getGlobal().initialized) {\n                    global_getGlobal().initialized = !0;\n                    on = (_ref3 = {\n                        on: on_on,\n                        send: send_send\n                    }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n                        return receive_receiveMessage(message, {\n                            on: on,\n                            send: send\n                        });\n                    };\n                    !function(_ref5) {\n                        var on = _ref5.on, send = _ref5.send;\n                        globalStore().getOrSet(\"postMessageListener\", (function() {\n                            return addEventListener(window, \"message\", (function(event) {\n                                !function(event, _ref4) {\n                                    var on = _ref4.on, send = _ref4.send;\n                                    promise_ZalgoPromise.try((function() {\n                                        var source = event.source || event.sourceElement;\n                                        var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n                                        var data = event.data;\n                                        \"null\" === origin && (origin = \"file://\");\n                                        if (source) {\n                                            if (!origin) throw new Error(\"Post message did not have origin domain\");\n                                            receive_receiveMessage({\n                                                source: source,\n                                                origin: origin,\n                                                data: data\n                                            }, {\n                                                on: on,\n                                                send: send\n                                            });\n                                        }\n                                    }));\n                                }(event, {\n                                    on: on,\n                                    send: send\n                                });\n                            }));\n                        }));\n                    }({\n                        on: on_on,\n                        send: send_send\n                    });\n                    !function(_ref8) {\n                        var on = _ref8.on, send = _ref8.send;\n                        globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n                            var listener = on(\"postrobot_hello\", {\n                                domain: \"*\"\n                            }, (function(_ref3) {\n                                resolveHelloPromise(_ref3.source, {\n                                    domain: _ref3.origin\n                                });\n                                return {\n                                    instanceID: getInstanceID()\n                                };\n                            }));\n                            var parent = getAncestor();\n                            parent && sayHello(parent, {\n                                send: send\n                            }).catch((function(err) {}));\n                            return listener;\n                        }));\n                    }({\n                        on: on_on,\n                        send: send_send\n                    });\n                }\n                var _ref3, on, send, global;\n            }();\n            var comp = component_component(options);\n            var init = function(props) {\n                return comp.init(props);\n            };\n            init.driver = function(name, dep) {\n                return comp.driver(name, dep);\n            };\n            init.isChild = function() {\n                return comp.isChild();\n            };\n            init.canRenderTo = function(win) {\n                return comp.canRenderTo(win);\n            };\n            init.instances = comp.instances;\n            var child = comp.registerChild();\n            child && (window.xprops = init.xprops = child.getProps());\n            return init;\n        }\n        function destroyComponents(err) {\n            var destroyPromise = cleanInstances.all(err);\n            cleanInstances = cleanup();\n            return destroyPromise;\n        }\n        var destroyAll = destroyComponents;\n        function component_destroy(err) {\n            destroyAll();\n            delete window.__zoid_9_0_63__;\n            !function() {\n                !function() {\n                    var responseListeners = globalStore(\"responseListeners\");\n                    for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n                        var hash = _responseListeners$ke2[_i2];\n                        var listener = responseListeners.get(hash);\n                        listener && (listener.cancelled = !0);\n                        responseListeners.del(hash);\n                    }\n                }();\n                (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n                var listener;\n                delete window.__post_robot_10_0_42__;\n            }();\n            return cleanZoid.all(err);\n        }\n    } ]);\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvem9pZC9kaXN0L3pvaWQuZnJhbWV3b3Jrcy5mcmFtZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQSxJQUFJLEtBQXVELGdDQUFnQyxDQUF1SjtBQUNsUCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDhCQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhCQUFtQjtBQUMzQixRQUFRLDhCQUFtQjtBQUMzQixRQUFRLDhCQUFtQjtBQUMzQixZQUFZLDhCQUFtQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSw4QkFBbUI7QUFDM0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSw4QkFBbUI7QUFDM0IsaUNBQWlDLDhCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkVBQTZFLDhCQUFtQjtBQUNoRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsUUFBUSw4QkFBbUI7QUFDM0I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWSw4QkFBbUI7QUFDL0I7QUFDQTtBQUNBLFFBQVEsOEJBQW1CO0FBQzNCLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVEsOEJBQW1CO0FBQzNCLGVBQWUsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3RELEtBQUssb0JBQW9CLDBCQUFtQixFQUFFLCtCQUFtQjtBQUNqRTtBQUNBLFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pELFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pEO0FBQ0EsU0FBUztBQUNULFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pEO0FBQ0EsU0FBUztBQUNULFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFD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QztBQUNuSjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EscUNBQXFDO0FBQ3JDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3REO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLHFDQUFxQztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsTUFBTTtBQUNOLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL25vZGVfbW9kdWxlcy96b2lkL2Rpc3Qvem9pZC5mcmFtZXdvcmtzLmZyYW1lLmpzPzdiZTgiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcInpvaWRcIiwgW10sIGZhY3RvcnkpIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMuem9pZCA9IGZhY3RvcnkoKSA6IHJvb3Quem9pZCA9IGZhY3RvcnkoKTtcbn0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB0aGlzLCAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZHVsZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiAgICAgICAgICAgICAgICBpOiBtb2R1bGVJZCxcbiAgICAgICAgICAgICAgICBsOiAhMSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuICAgICAgICAgICAgbW9kdWxlLmwgPSAhMDtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiTW9kdWxlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiAgICAgICAgICAgIDEgJiBtb2RlICYmICh2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpKTtcbiAgICAgICAgICAgIGlmICg4ICYgbW9kZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgaWYgKDQgJiBtb2RlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoMiAmIG1vZGUgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdmFsdWUpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5zO1xuICAgICAgICB9O1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCBcImFcIiwgZ2V0dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuICAgICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiAgICB9KFsgZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBvcHVwT3BlbkVycm9yXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21fUG9wdXBPcGVuRXJyb3I7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JlYXRlXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGU7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveVwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50X2Rlc3Ryb3k7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveUNvbXBvbmVudHNcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lDb21wb25lbnRzO1xuICAgICAgICB9KSk7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc3Ryb3lBbGxcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lBbGw7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUFJPUF9UWVBFXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBQUk9QX1RZUEU7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUFJPUF9TRVJJQUxJWkFUSU9OXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBQUk9QX1NFUklBTElaQVRJT047XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ09OVEVYVFwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQ09OVEVYVDtcbiAgICAgICAgfSkpO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFVkVOVFwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gRVZFTlQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgICAgICAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0aWxzX2lzUHJvbWlzZShpdGVtKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBQcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5XaW5kb3cgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LmNvbnN0cnVjdG9yICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuY29uc3RydWN0b3IpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB2YXIgX3RvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKF90b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF90b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgZ2xvYmFsXVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBET01XaW5kb3ddXCIgPT09IG5hbWUpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50aGVuKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3BhdGNoZWRFcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzID0gW107XG4gICAgICAgIHZhciBhY3RpdmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBmbHVzaFByb21pc2U7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoQWN0aXZlKCkge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVDb3VudCAmJiBmbHVzaFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBmbHVzaFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWN0aXZlKCkge1xuICAgICAgICAgICAgYWN0aXZlQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmRBY3RpdmUoKSB7XG4gICAgICAgICAgICBhY3RpdmVDb3VudCAtPSAxO1xuICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZV9aYWxnb1Byb21pc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFphbGdvUHJvbWlzZShoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITE7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZXNvbHZlKHJlcyk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0ID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlamVjdChlcnIpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPyB0aGlzLnJlc29sdmUoX3Jlc3VsdCkgOiByZWplY3RlZCAmJiB0aGlzLnJlamVjdChfZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcHJvdG8gPSBaYWxnb1Byb21pc2UucHJvdG90eXBlO1xuICAgICAgICAgICAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKHJlc3VsdCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8ucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKGVycm9yKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWplY3QgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZXJyID0gZXJyb3IgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCByZWplY3QgdG8gYmUgY2FsbGVkIHdpdGggRXJyb3IsIGdvdCBcIiArIF9lcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkIHx8IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXJyb3JIYW5kbGVkIHx8IGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBkaXNwYXRjaGVkRXJyb3JzLmluZGV4T2YoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzW2pdKGVyciwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oZXJyb3IsIF90aGlzMik7XG4gICAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZWQsIHJlamVjdGVkID0gdGhpcy5yZWplY3RlZCwgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwYXRjaGluZyAmJiAocmVzb2x2ZWQgfHwgcmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oZmlyc3RQcm9taXNlLCBzZWNvbmRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2hhbmRsZXJzJGkgPSBoYW5kbGVyc1tpXSwgb25TdWNjZXNzID0gX2hhbmRsZXJzJGkub25TdWNjZXNzLCBvbkVycm9yID0gX2hhbmRsZXJzJGkub25FcnJvciwgcHJvbWlzZSA9IF9oYW5kbGVycyRpLnByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvblN1Y2Nlc3MgPyBvblN1Y2Nlc3ModGhpcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIudmFsdWUpIDogcHJvbWlzZS5yZWplY3QoX3Jlc3VsdDIuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyLmVycm9ySGFuZGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHV0aWxzX2lzUHJvbWlzZShfcmVzdWx0MikgPyBfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpID8gX3Jlc3VsdDIucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIudmFsdWUpIDogcHJvbWlzZS5yZWplY3QoX3Jlc3VsdDIuZXJyb3IpIDogY2hhaW4oX3Jlc3VsdDIsIHByb21pc2UpIDogcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gITE7XG4gICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvblN1Y2Nlc3MgJiYgIW9uU3VjY2Vzcy5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3Igc3VjY2VzcyBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25FcnJvciAmJiAhb25FcnJvci5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3IgZXJyb3IgaGFuZGxlclwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbihvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIG9uRXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24ob25GaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uRmluYWxseSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRmluYWxseSAmJiAhb25GaW5hbGx5LmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UuZmluYWxseSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lLCBlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMucmVzb2x2ZWQgfHwgX3RoaXMzLnJlamVjdGVkIHx8IF90aGlzMy5yZWplY3QoZXJyIHx8IG5ldyBFcnJvcihcIlByb21pc2UgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZSArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgIH0pLCB0aW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFByb21pc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb3VsZCBub3QgZmluZCBQcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSA/IHZhbHVlIDogdXRpbHNfaXNQcm9taXNlKHZhbHVlKSA/IG5ldyBaYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pKSA6IChuZXcgWmFsZ29Qcm9taXNlKS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLmFzeW5jUmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihpLCBmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAwID09IChjb3VudCAtPSAxKSAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9tID0gcHJvbWlzZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9tIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbS5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWxzX2lzUHJvbWlzZShwcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb207XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhaW4oaSwgWmFsZ29Qcm9taXNlLnJlc29sdmUocHJvbSksIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAwID09PSBjb3VudCAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmhhc2ggPSBmdW5jdGlvbihwcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYXdhaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvbWlzZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBhd2FpdFByb21pc2VzLnB1c2godmFsdWUudGhlbigoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpIDogcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb21pc2VzKSBfbG9vcChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGF3YWl0UHJvbWlzZXMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UubWFwID0gZnVuY3Rpb24oaXRlbXMsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGl0ZW1zLm1hcChtZXRob2QpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5zcGxpY2UocG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfShoYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UudHJ5ID0gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG1ldGhvZCAmJiAhbWV0aG9kLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudHJ5IGV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFphbGdvUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uKF9kZWxheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgX2RlbGF5KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB8fCB1dGlsc19pc1Byb21pc2UodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFphbGdvUHJvbWlzZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihaYWxnbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZSA9IGZsdXNoUHJvbWlzZSB8fCBuZXcgWmFsZ287XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH0oWmFsZ29Qcm9taXNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlO1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVnZXgoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFdJTkRPV19UWVBFID0ge1xuICAgICAgICAgICAgSUZSQU1FOiBcImlmcmFtZVwiLFxuICAgICAgICAgICAgUE9QVVA6IFwicG9wdXBcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgSUVfV0lOX0FDQ0VTU19FUlJPUiA9IFwiQ2FsbCB3YXMgcmVqZWN0ZWQgYnkgY2FsbGVlLlxcclxcblwiO1xuICAgICAgICBmdW5jdGlvbiBpc0Fib3V0UHJvdG9jb2wod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIHJldHVybiBcImFib3V0OlwiID09PSB3aW4ubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXRpbHNfZ2V0UGFyZW50KHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICBpZiAod2luKSB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4ucGFyZW50ICYmIHdpbi5wYXJlbnQgIT09IHdpbikgcmV0dXJuIHdpbi5wYXJlbnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3BlbmVyKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICBpZiAod2luICYmICF1dGlsc19nZXRQYXJlbnQod2luKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luLm9wZW5lcjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbERvbWFpbih3aW4pIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gd2luLmxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBsb2NhdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgaWYgKCFwcm90b2NvbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBwcm90b2NvbFwiKTtcbiAgICAgICAgICAgIGlmIChcImZpbGU6XCIgPT09IHByb3RvY29sKSByZXR1cm4gXCJmaWxlOi8vXCI7XG4gICAgICAgICAgICBpZiAoXCJhYm91dDpcIiA9PT0gcHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdXRpbHNfZ2V0UGFyZW50KHdpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBjYW5SZWFkRnJvbVdpbmRvdygpID8gZ2V0QWN0dWFsRG9tYWluKHBhcmVudCkgOiBcImFib3V0Oi8vXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG4gICAgICAgICAgICBpZiAoIWhvc3QpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgaG9zdFwiKTtcbiAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RG9tYWluKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0QWN0dWFsRG9tYWluKHdpbik7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluICYmIHdpbi5tb2NrRG9tYWluICYmIDAgPT09IHdpbi5tb2NrRG9tYWluLmluZGV4T2YoXCJtb2NrOlwiKSA/IHdpbi5tb2NrRG9tYWluIDogZG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU2FtZURvbWFpbih3aW4pIHtcbiAgICAgICAgICAgIGlmICghZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW4sIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmICExID09PSBkZXNjLmVudW1lcmFibGUpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdHVhbERvbWFpbih3aW4pID09PSBnZXRBY3R1YWxEb21haW4od2luZG93KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9KHdpbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RG9tYWluKHdpbmRvdykgPT09IGdldERvbWFpbih3aW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0U2FtZURvbWFpbih3aW4pIHtcbiAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHdpbmRvdyB0byBiZSBzYW1lIGRvbWFpblwiKTtcbiAgICAgICAgICAgIHJldHVybiB3aW47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3RvclBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHZhciBjaGlsZFBhcmVudCA9IHV0aWxzX2dldFBhcmVudChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRQYXJlbnQgPyBjaGlsZFBhcmVudCA9PT0gcGFyZW50IDogLTEgIT09IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDt3aW4ucGFyZW50ICE9PSB3aW47ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2luLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4gPSB3aW4ucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KGNoaWxkKS5pbmRleE9mKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVzKHdpbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGZyYW1lcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhbWVzID0gd2luLmZyYW1lcztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGZyYW1lcyA9IHdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAoMCA9PT0gbGVuKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDEwMDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gZnJhbWVzW19pXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfZnJhbWUpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX2ZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfZ2V0RnJhbWVzMiA9IGdldEZyYW1lcyh3aW4pOyBfaTMgPCBfZ2V0RnJhbWVzMi5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEZyYW1lczJbX2kzXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzMiA9IGdldEFsbENoaWxkRnJhbWVzKGZyYW1lKTsgX2k1IDwgX2dldEFsbENoaWxkRnJhbWVzMi5sZW5ndGg7IF9pNSsrKSByZXN1bHQucHVzaChfZ2V0QWxsQ2hpbGRGcmFtZXMyW19pNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRUb3Aod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbi50b3ApIHJldHVybiB3aW4udG9wO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgaWYgKHV0aWxzX2dldFBhcmVudCh3aW4pID09PSB3aW4pIHJldHVybiB3aW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbmRvdywgd2luKSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luLCB3aW5kb3cpICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzNCA9IGdldEFsbENoaWxkRnJhbWVzKHdpbik7IF9pNyA8IF9nZXRBbGxDaGlsZEZyYW1lczQubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRBbGxDaGlsZEZyYW1lczRbX2k3XTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUudG9wKSByZXR1cm4gZnJhbWUudG9wO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfZ2V0UGFyZW50KGZyYW1lKSA9PT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBbGxGcmFtZXNJbldpbmRvdyh3aW4pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBnZXRUb3Aod2luKTtcbiAgICAgICAgICAgIGlmICghdG9wKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRldGVybWluZSB0b3Agd2luZG93XCIpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLmNvbmNhdChnZXRBbGxDaGlsZEZyYW1lcyh0b3ApLCBbIHRvcCBdKTtcbiAgICAgICAgICAgIC0xID09PSByZXN1bHQuaW5kZXhPZih3aW4pICYmIChyZXN1bHQgPSBbXS5jb25jYXQocmVzdWx0LCBbIHdpbiBdLCBnZXRBbGxDaGlsZEZyYW1lcyh3aW4pKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZnJhbWVXaW5kb3dzID0gW107XG4gICAgICAgIHZhciBpZnJhbWVGcmFtZXMgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3dDbG9zZWQod2luLCBhbGxvd01vY2spIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYWxsb3dNb2NrICYmIChhbGxvd01vY2sgPSAhMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbikgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAod2luLmNsb3NlZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlcnIgfHwgZXJyLm1lc3NhZ2UgIT09IElFX1dJTl9BQ0NFU1NfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dNb2NrICYmIGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4ubW9ja2Nsb3NlZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbi5wYXJlbnQgfHwgIXdpbi50b3ApIHJldHVybiAhMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIHZhciBpZnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfShpZnJhbWVXaW5kb3dzLCB3aW4pO1xuICAgICAgICAgICAgaWYgKC0xICE9PSBpZnJhbWVJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGlmcmFtZUZyYW1lc1tpZnJhbWVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWUuY29udGVudFdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLnBhcmVudE5vZGUpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGZyYW1lLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCAmJiAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhmcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3BhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQ7ICkgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5ob3N0IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHBhcmVudC5ob3N0KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9KGZyYW1lKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbiA9IHdpbiB8fCB3aW5kb3cpIHx8IHV0aWxzX2dldFBhcmVudCh3aW4pIHx8IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbnlNYXRjaChjb2xsZWN0aW9uMSwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMTcgPSAwOyBfaTE3IDwgY29sbGVjdGlvbjEubGVuZ3RoOyBfaTE3KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbTEgPSBjb2xsZWN0aW9uMVtfaTE3XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE5ID0gMDsgX2kxOSA8IGNvbGxlY3Rpb24yLmxlbmd0aDsgX2kxOSsrKSBpZiAoaXRlbTEgPT09IGNvbGxlY3Rpb24yW19pMTldKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VGcm9tVG9wKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHdpbjtcbiAgICAgICAgICAgIGZvciAoO3BhcmVudDsgKSAocGFyZW50ID0gdXRpbHNfZ2V0UGFyZW50KHBhcmVudCkpICYmIChkaXN0YW5jZSArPSAxKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1NhbWVUb3BXaW5kb3cod2luMSwgd2luMikge1xuICAgICAgICAgICAgdmFyIHRvcDEgPSBnZXRUb3Aod2luMSkgfHwgd2luMTtcbiAgICAgICAgICAgIHZhciB0b3AyID0gZ2V0VG9wKHdpbjIpIHx8IHdpbjI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AxICYmIHRvcDIpIHJldHVybiB0b3AxID09PSB0b3AyO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgdmFyIGFsbEZyYW1lczEgPSBnZXRBbGxGcmFtZXNJbldpbmRvdyh3aW4xKTtcbiAgICAgICAgICAgIHZhciBhbGxGcmFtZXMyID0gZ2V0QWxsRnJhbWVzSW5XaW5kb3cod2luMik7XG4gICAgICAgICAgICBpZiAoYW55TWF0Y2goYWxsRnJhbWVzMSwgYWxsRnJhbWVzMikpIHJldHVybiAhMDtcbiAgICAgICAgICAgIHZhciBvcGVuZXIxID0gZ2V0T3BlbmVyKHRvcDEpO1xuICAgICAgICAgICAgdmFyIG9wZW5lcjIgPSBnZXRPcGVuZXIodG9wMik7XG4gICAgICAgICAgICByZXR1cm4gb3BlbmVyMSAmJiBhbnlNYXRjaChnZXRBbGxGcmFtZXNJbldpbmRvdyhvcGVuZXIxKSwgYWxsRnJhbWVzMikgfHwgb3BlbmVyMiAmJiBhbnlNYXRjaChnZXRBbGxGcmFtZXNJbldpbmRvdyhvcGVuZXIyKSwgYWxsRnJhbWVzMSksIFxuICAgICAgICAgICAgITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hEb21haW4ocGF0dGVybiwgb3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBvcmlnaW4pIHJldHVybiBcIipcIiA9PT0gcGF0dGVybiB8fCBvcmlnaW4gPT09IHBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnZXgob3JpZ2luKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1JlZ2V4KHBhdHRlcm4pID8gaXNSZWdleChvcmlnaW4pID8gcGF0dGVybi50b1N0cmluZygpID09PSBvcmlnaW4udG9TdHJpbmcoKSA6ICFBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgQm9vbGVhbihvcmlnaW4ubWF0Y2gocGF0dGVybikpIDogISFBcnJheS5pc0FycmF5KHBhdHRlcm4pICYmIChBcnJheS5pc0FycmF5KG9yaWdpbikgPyBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSA9PT0gSlNPTi5zdHJpbmdpZnkob3JpZ2luKSA6ICFpc1JlZ2V4KG9yaWdpbikgJiYgcGF0dGVybi5zb21lKChmdW5jdGlvbihzdWJwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoRG9tYWluKHN1YnBhdHRlcm4sIG9yaWdpbik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERvbWFpbkZyb21VcmwodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLm1hdGNoKC9eKGh0dHBzP3xtb2NrfGZpbGUpOlxcL1xcLy8pID8gdXJsLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAzKS5qb2luKFwiL1wiKSA6IGdldERvbWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uQ2xvc2VXaW5kb3cod2luLCBjYWxsYmFjaywgZGVsYXksIG1heHRpbWUpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVsYXkgJiYgKGRlbGF5ID0gMWUzKTtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gbWF4dGltZSAmJiAobWF4dGltZSA9IDEgLyAwKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICAgICAgIWZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heHRpbWUgPD0gMCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4dGltZSAtPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuV2luZG93ICYmIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouc2VsZiA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnBhcmVudCA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnRvcCA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgXCJfX3VubGlrZWx5X3ZhbHVlX19cIiA9PT0gb2JqLl9fY3Jvc3NfZG9tYWluX3V0aWxzX3dpbmRvd19jaGVja19fKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInBvc3RNZXNzYWdlXCIgaW4gb2JqICYmIFwic2VsZlwiIGluIG9iaiAmJiBcImxvY2F0aW9uXCIgaW4gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvc2VXaW5kb3cod2luKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0aWxfc2FmZUluZGV4T2YoY29sbGVjdGlvbiwgaXRlbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiX193ZWFrbWFwX1wiICsgKDFlOSAqIE1hdGgucmFuZG9tKCkgPj4+IDApICsgXCJfX1wiO1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gT2JqZWN0LmZyZWV6ZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RXZWFrTWFwID0gbmV3IFdlYWtNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEtleSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0ZXN0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RXZWFrTWFwLnNldCh0ZXN0S2V5LCBcIl9fdGVzdHZhbHVlX19cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJfX3Rlc3R2YWx1ZV9fXCIgPT09IHRlc3RXZWFrTWFwLmdldCh0ZXN0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCkpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IG5ldyBXZWFrTWFwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9wcm90byA9IENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlO1xuICAgICAgICAgICAgX3Byb3RvLl9jbGVhbnVwQ2xvc2VkV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3codmFsdWUpICYmIGlzV2luZG93Q2xvc2VkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmlzU2FmZVRvUmVhZFdyaXRlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc1dpbmRvdyhrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdID0gdmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG4gICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gd2Vha21hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpbmRleCkgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSAmJiAoZW50cnlbMF0gPSBlbnRyeVsxXSA9IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldE9yU2V0ID0gZnVuY3Rpb24oa2V5LCBnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICAgICAgfSkobyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgICAgIHJldHVybiAoX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKG8sIHApIHtcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9KShvLCBwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgKGZ1bmN0aW9uKCkge30pKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29uc3RydWN0X2NvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0IDogZnVuY3Rpb24oUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gWyBudWxsIF07XG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpKTtcbiAgICAgICAgICAgICAgICBDbGFzcyAmJiBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgfSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwTmF0aXZlU3VwZXJfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICB2YXIgX2NhY2hlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBNYXAgPyBuZXcgTWFwIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuICh3cmFwTmF0aXZlU3VwZXJfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24oQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gQ2xhc3MgfHwgIShmbiA9IENsYXNzLCAtMSAhPT0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpKSByZXR1cm4gQ2xhc3M7XG4gICAgICAgICAgICAgICAgdmFyIGZuO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIENsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gX2NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgICAgICAgICAgfSkoQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuLm5hbWUgfHwgZm4uX19uYW1lX18gfHwgZm4uZGlzcGxheU5hbWUgfHwgXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm4sIG5hbWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZuLm5hbWU7XG4gICAgICAgICAgICAgICAgZm4ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBmbi5fX25hbWVfXyA9IGZuLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlNjRlbmNvZGUoc3RyKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBidG9hKSByZXR1cm4gYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAoZnVuY3Rpb24obSwgcDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwMSwgMTYpKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgd2luZG93LmJ0b2Egb3IgQnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlEKCkge1xuICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eHh4XCIucmVwbGFjZSgvLi9nLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0pKSArIFwiX1wiICsgYmFzZTY0ZW5jb2RlKChuZXcgRGF0ZSkudG9JU09TdHJpbmcoKS5zbGljZSgxMSwgMTkpLnJlcGxhY2UoXCJUXCIsIFwiLlwiKSkucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iamVjdElEcztcbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplQXJncyhhcmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShbXS5zbGljZS5jYWxsKGFyZ3MpLCAoZnVuY3Rpb24oc3Via2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJtZW1vaXplW1wiICsgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMgPSBvYmplY3RJRHMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IG9iaiB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBvYmogJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvYmopIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IG9iamVjdElEcy5nZXQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkID0gdHlwZW9mIG9iaiArIFwiOlwiICsgdW5pcXVlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMuc2V0KG9iaiwgdWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH0odmFsKSArIFwiXVwiIDogdmFsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyBub3Qgc2VyaWFsaXphYmxlIC0tIGNhbiBub3QgYmUgdXNlZCB0byBtZW1vaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEVtcHR5T2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZW1vaXplR2xvYmFsSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gMDtcbiAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZShtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgPSBvcHRpb25zLnRoaXNOYW1lc3BhY2UsIHRoaXNOYW1lc3BhY2UgPSB2b2lkIDAgIT09IF9vcHRpb25zJHRoaXNOYW1lc3BhYyAmJiBfb3B0aW9ucyR0aGlzTmFtZXNwYWMsIGNhY2hlVGltZSA9IG9wdGlvbnMudGltZTtcbiAgICAgICAgICAgIHZhciBzaW1wbGVDYWNoZTtcbiAgICAgICAgICAgIHZhciB0aGlzQ2FjaGU7XG4gICAgICAgICAgICB2YXIgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG4gICAgICAgICAgICB2YXIgbWVtb2l6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobWVtb2l6ZUluZGV4IDwgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlO1xuICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpc05hbWVzcGFjZSA/ICh0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCkuZ2V0T3JTZXQodGhpcywgZ2V0RW1wdHlPYmplY3QpIDogc2ltcGxlQ2FjaGUgPSBzaW1wbGVDYWNoZSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemVBcmdzKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZVJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQgJiYgY2FjaGVUaW1lICYmIERhdGUubm93KCkgLSBjYWNoZVJlc3VsdC50aW1lIDwgY2FjaGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVzdWx0KSByZXR1cm4gY2FjaGVSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWVtb2l6ZWRGdW5jdGlvbi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRGdW5jdGlvbiwgKG9wdGlvbnMubmFtZSB8fCBnZXRGdW5jdGlvbk5hbWUobWV0aG9kKSkgKyBcIjo6bWVtb2l6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBtZW1vaXplUHJvbWlzZShtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgY2FjaGVba2V5XSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0pKS5maW5hbGx5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHt9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24sIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6OnByb21pc2VNZW1vaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVNZW1vaXplKG1ldGhvZCwgbG9naWMsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYXJncyAmJiAoYXJncyA9IFtdKTtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IG1ldGhvZC5fX2lubGluZV9tZW1vaXplX2NhY2hlX18gPSBtZXRob2QuX19pbmxpbmVfbWVtb2l6ZV9jYWNoZV9fIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9IHNlcmlhbGl6ZUFyZ3MoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNhY2hlW2tleV0gOiBjYWNoZVtrZXldID0gbG9naWMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzcmNfdXRpbF9ub29wKCkge31cbiAgICAgICAgZnVuY3Rpb24gb25jZShtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBjYWxsZWQgPSAhMTtcbiAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6Om9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyLCBsZXZlbCkge1xuICAgICAgICAgICAgdm9pZCAwID09PSBsZXZlbCAmJiAobGV2ZWwgPSAxKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSAzKSByZXR1cm4gXCJzdHJpbmdpZnlFcnJvciBzdGFjayBvdmVyZmxvd1wiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikgcmV0dXJuIFwiPHVua25vd24gZXJyb3I6IFwiICsge30udG9TdHJpbmcuY2FsbChlcnIpICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGVycikgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyICYmIGVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBtZXNzYWdlKSByZXR1cm4gLTEgIT09IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPyBzdGFjayA6IG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjaykgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLnRvU3RyaW5nICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyLnRvU3RyaW5nID8gZXJyLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvciB3aGlsZSBzdHJpbmdpZnlpbmcgZXJyb3I6IFwiICsgc3RyaW5naWZ5RXJyb3IobmV3RXJyLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbSA/IGl0ZW0gOiBpdGVtICYmIGl0ZW0udG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRvU3RyaW5nID8gaXRlbS50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHRlbmQob2JqLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5hc3NpZ24pIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgc291cmNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvYmpba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcykgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHJlc3VsdC5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gaWRlbnRpdHkoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2FmZUludGVydmFsKG1ldGhvZCwgdGltZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICAhZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCgpO1xuICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgfSksIHRpbWUpO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWZpbmVMYXp5UHJvcChvYmosIGtleSwgZ2V0dGVyKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGtleSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5IGtleSBtdXN0IGJlIG51bWJlclwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2Ygb2JqICYmIG51bGwgIT09IG9iaiAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBrZXkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qga2V5IG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheUZyb20oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgKGl0ZW0gPSBvYmopICYmIG51bGwgIT09IGl0ZW0gJiYgXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3RPYmplY3Qob2JqKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY29uc3RydWN0b3IpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICByZXR1cm4gISFpc09iamVjdE9iamVjdChwcm90b3R5cGUpICYmICEhcHJvdG90eXBlLmhhc093blByb3BlcnR5KFwiaXNQcm90b3R5cGVPZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlT2JqZWN0KGl0ZW0sIHJlcGxhY2VyLCBmdWxsS2V5KSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGZ1bGxLZXkgJiYgKGZ1bGxLZXkgPSBcIlwiKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMYXp5UHJvcChyZXN1bHQsIGksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gZnVsbEtleSA/IGZ1bGxLZXkgKyBcIi5cIiArIGkgOiBcIlwiICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHJlcGxhY2VyKGl0ZW1baV0sIGksIGl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlzUGxhaW5PYmplY3QoY2hpbGQpIHx8IEFycmF5LmlzQXJyYXkoY2hpbGQpKSAmJiAoY2hpbGQgPSByZXBsYWNlT2JqZWN0KGNoaWxkLCByZXBsYWNlciwgaXRlbUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBfbG9vcDIoaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMYXp5UHJvcChfcmVzdWx0LCBrZXksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gZnVsbEtleSA/IGZ1bGxLZXkgKyBcIi5cIiArIGtleSA6IFwiXCIgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSByZXBsYWNlcihpdGVtW2tleV0sIGtleSwgaXRlbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNQbGFpbk9iamVjdChjaGlsZCkgfHwgQXJyYXkuaXNBcnJheShjaGlsZCkpICYmIChjaGlsZCA9IHJlcGxhY2VPYmplY3QoY2hpbGQsIHJlcGxhY2VyLCBpdGVtS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtKSBfbG9vcDMoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3MgYW4gb2JqZWN0IG9yIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXRpbF9pc1JlZ2V4KGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0aWxfZ2V0T3JTZXQob2JqLCBrZXksIGdldHRlcikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gb2JqW2tleV07XG4gICAgICAgICAgICB2YXIgdmFsID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cChvYmopIHtcbiAgICAgICAgICAgIHZhciB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNsZWFuZWQgPSAhMTtcbiAgICAgICAgICAgIHZhciBjbGVhbkVycjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xlYW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW25hbWVdID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWQgPyBtZXRob2QoY2xlYW5FcnIpIDogdGFza3MucHVzaChvbmNlKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QoY2xlYW5FcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWxsOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5FcnIgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7dGFza3MubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0YXNrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEV4aXN0cyhuYW1lLCB0aGluZykge1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gdGhpbmcpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiICsgbmFtZSArIFwiIHRvIGJlIHByZXNlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0aWxfRXh0ZW5kYWJsZUVycm9yID0gZnVuY3Rpb24oX0Vycm9yKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHNMb29zZShFeHRlbmRhYmxlRXJyb3IsIF9FcnJvcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBFeHRlbmRhYmxlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczY7XG4gICAgICAgICAgICAgICAgKF90aGlzNiA9IF9FcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXMpLm5hbWUgPSBfdGhpczYuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBzZWxmKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH0oX3RoaXM2KSwgX3RoaXM2LmNvbnN0cnVjdG9yKSA6IF90aGlzNi5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGFibGVFcnJvcjtcbiAgICAgICAgfSh3cmFwTmF0aXZlU3VwZXJfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG4gICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRSZWFkeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiY29tcGxldGVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudC5ib2R5KSAmJiBcImludGVyYWN0aXZlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXJsRW5jb2RlKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXD8vZywgXCIlM0ZcIikucmVwbGFjZSgvJi9nLCBcIiUyNlwiKS5yZXBsYWNlKC8jL2csIFwiJTIzXCIpLnJlcGxhY2UoL1xcKy9nLCBcIiUyQlwiKTtcbiAgICAgICAgfVxuICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCAxMCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VRdWVyeShxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZU1lbW9pemUocGFyc2VRdWVyeSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5U3RyaW5nKSByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gcXVlcnlTdHJpbmcuaW5kZXhPZihcIj1cIikpIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3F1ZXJ5U3RyaW5nJHNwbGl0MiA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKTsgX2kyIDwgX3F1ZXJ5U3RyaW5nJHNwbGl0Mi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gX3F1ZXJ5U3RyaW5nJHNwbGl0MltfaTJdO1xuICAgICAgICAgICAgICAgICAgICAocGFpciA9IHBhaXIuc3BsaXQoXCI9XCIpKVswXSAmJiBwYWlyWzFdICYmIChwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9KSwgWyBxdWVyeVN0cmluZyBdKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHRlbmRRdWVyeShvcmlnaW5hbFF1ZXJ5LCBwcm9wcykge1xuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcyAmJiAocHJvcHMgPSB7fSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMgJiYgT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb2JqICYmIChvYmogPSB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH0pKS5tYXAoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsRW5jb2RlKGtleSkgKyBcIj1cIiArIHVybEVuY29kZShvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfSkpLmpvaW4oXCImXCIpO1xuICAgICAgICAgICAgfShfZXh0ZW5kcyh7fSwgcGFyc2VRdWVyeShvcmlnaW5hbFF1ZXJ5KSwgcHJvcHMpKSA6IG9yaWdpbmFsUXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCB8fCBudWxsICE9PSBlbGVtZW50ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGVsZW1lbnQgJiYgMSA9PT0gZWxlbWVudC5ub2RlVHlwZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlbGVtZW50LnN0eWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2FmZShpZCwgZG9jKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGRvYyAmJiAoZG9jID0gZG9jdW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGlzRWxlbWVudChpZCkgPyBpZCA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGlkID8gZG9jLnF1ZXJ5U2VsZWN0b3IoaWQpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWFkeShpZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzdHJpbmdpZnkoaWQpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGdldEVsZW1lbnRTYWZlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHJldHVybiByZXNvbHZlKGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiRG9jdW1lbnQgaXMgcmVhZHkgYW5kIGVsZW1lbnQgXCIgKyBuYW1lICsgXCIgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsID0gZ2V0RWxlbWVudFNhZmUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyByZWFkeSBhbmQgZWxlbWVudCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgMTApO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb21fUG9wdXBPcGVuRXJyb3IgPSBmdW5jdGlvbihfRXh0ZW5kYWJsZUVycm9yKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHNMb29zZShQb3B1cE9wZW5FcnJvciwgX0V4dGVuZGFibGVFcnJvcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQb3B1cE9wZW5FcnJvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX0V4dGVuZGFibGVFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9wdXBPcGVuRXJyb3I7XG4gICAgICAgIH0odXRpbF9FeHRlbmRhYmxlRXJyb3IpO1xuICAgICAgICB2YXIgYXdhaXRGcmFtZUxvYWRQcm9taXNlcztcbiAgICAgICAgZnVuY3Rpb24gYXdhaXRGcmFtZUxvYWQoZnJhbWUpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXRGcmFtZUxvYWRQcm9taXNlcyA9IGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCkuaGFzKGZyYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBfcHJvbWlzZSA9IGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuZ2V0KGZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb21pc2UpIHJldHVybiBfcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWZyYW1lV2luZG93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VkID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSBpZnJhbWVXaW5kb3dzW2ldLmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVGcmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lV2luZG93cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuY29udGVudFdpbmRvdykgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVXaW5kb3dzLnB1c2goZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lRnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB9KGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmNvbnRlbnRXaW5kb3cgPyByZXNvbHZlKGZyYW1lKSA6IHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuc2V0KGZyYW1lLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGF3YWl0RnJhbWVXaW5kb3coZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdEZyYW1lTG9hZChmcmFtZSkudGhlbigoZnVuY3Rpb24obG9hZGVkRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZEZyYW1lLmNvbnRlbnRXaW5kb3cpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdpbmRvdyBpbiBpZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZEZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9tX2lmcmFtZShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGUgfHwge307XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbih0YWcsIG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdGFnICYmICh0YWcgPSBcImRpdlwiKTtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHlsZSAmJiBleHRlbmQoZWxlbWVudC5zdHlsZSwgb3B0aW9ucy5zdHlsZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jbGFzcyAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmlkICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgb3B0aW9ucy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgZm9yICh2YXIgX2kxMCA9IDAsIF9PYmplY3Qka2V5czIgPSBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaTEwIDwgX09iamVjdCRrZXlzMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzMltfaTEwXTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVTaGVldCAmJiBmdW5jdGlvbihlbCwgc3R5bGVUZXh0LCBkb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBkb2MgJiYgKGRvYyA9IHdpbmRvdy5kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlU2hlZXQgPyBlbC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZVRleHQgOiBlbC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc3R5bGVUZXh0KSk7XG4gICAgICAgICAgICAgICAgfShlbGVtZW50LCBvcHRpb25zLnN0eWxlU2hlZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaWZyYW1lXCIgPT09IHRhZykgdGhyb3cgbmV3IEVycm9yKFwiSWZyYW1lIGh0bWwgY2FuIG5vdCBiZSB3cml0dGVuIHVubGVzcyBjb250YWluZXIgcHJvdmlkZWQgYW5kIGlmcmFtZSBpbiBET01cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH0oXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUcmFuc3BhcmVuY3k6IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9KSxcbiAgICAgICAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIH0sIHN0eWxlKSxcbiAgICAgICAgICAgICAgICBodG1sOiBvcHRpb25zLmh0bWwsXG4gICAgICAgICAgICAgICAgY2xhc3M6IG9wdGlvbnMuY2xhc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzSUUgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRXxFZGdlL2kpO1xuICAgICAgICAgICAgZnJhbWUuaGFzQXR0cmlidXRlKFwiaWRcIikgfHwgZnJhbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgdW5pcXVlSUQoKSk7XG4gICAgICAgICAgICBhd2FpdEZyYW1lTG9hZChmcmFtZSk7XG4gICAgICAgICAgICBjb250YWluZXIgJiYgZnVuY3Rpb24oaWQsIGRvYykge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZG9jICYmIChkb2MgPSBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBnZXRFbGVtZW50U2FmZShpZCwgZG9jKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGVsZW1lbnQ6IFwiICsgc3RyaW5naWZ5KGlkKSk7XG4gICAgICAgICAgICB9KGNvbnRhaW5lcikuYXBwZW5kQ2hpbGQoZnJhbWUpO1xuICAgICAgICAgICAgKG9wdGlvbnMudXJsIHx8IGlzSUUpICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcInNyY1wiLCBvcHRpb25zLnVybCB8fCBcImFib3V0OmJsYW5rXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIob2JqLCBldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaG93RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoaWRlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRWxlbWVudENsb3NlZChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICEoZWwgJiYgZWwucGFyZW50Tm9kZSAmJiBlbC5vd25lckRvY3VtZW50ICYmIGVsLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGVsLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZXNpemUoZWwsIGhhbmRsZXIsIF90ZW1wKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjIgPSB2b2lkIDAgPT09IF90ZW1wID8ge30gOiBfdGVtcCwgX3JlZjIkd2lkdGggPSBfcmVmMi53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9yZWYyJHdpZHRoIHx8IF9yZWYyJHdpZHRoLCBfcmVmMiRoZWlnaHQgPSBfcmVmMi5oZWlnaHQsIGhlaWdodCA9IHZvaWQgMCA9PT0gX3JlZjIkaGVpZ2h0IHx8IF9yZWYyJGhlaWdodCwgX3JlZjIkaW50ZXJ2YWwgPSBfcmVmMi5pbnRlcnZhbCwgaW50ZXJ2YWwgPSB2b2lkIDAgPT09IF9yZWYyJGludGVydmFsID8gMTAwIDogX3JlZjIkaW50ZXJ2YWwsIF9yZWYyJHdpbiA9IF9yZWYyLndpbiwgd2luID0gdm9pZCAwID09PSBfcmVmMiR3aW4gPyB3aW5kb3cgOiBfcmVmMiR3aW47XG4gICAgICAgICAgICB2YXIgY3VycmVudFdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHZhciBjYW5jZWxlZCA9ICExO1xuICAgICAgICAgICAgaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGN1cnJlbnRIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZCAmJiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0oZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAod2lkdGggJiYgbmV3V2lkdGggIT09IGN1cnJlbnRXaWR0aCB8fCBoZWlnaHQgJiYgbmV3SGVpZ2h0ICE9PSBjdXJyZW50SGVpZ2h0KSAmJiBoYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9ic2VydmVyO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjaGVjayk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSB3aW4uUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAob2JzZXJ2ZXIgPSBuZXcgd2luLlJlc2l6ZU9ic2VydmVyKGNoZWNrKSkub2JzZXJ2ZShlbCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNhZmVJbnRlcnZhbChjaGVjaywgMTAgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gd2luLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAob2JzZXJ2ZXIgPSBuZXcgd2luLk11dGF0aW9uT2JzZXJ2ZXIoY2hlY2spKS5vYnNlcnZlKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogITFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2FmZUludGVydmFsKGNoZWNrLCAxMCAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB0aW1lb3V0ID0gc2FmZUludGVydmFsKGNoZWNrLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNTaGFkb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvciAoO2VsZW1lbnQucGFyZW50Tm9kZTsgKSBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTaGFkb3dSb290XVwiID09PSBlbGVtZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiBudWxsO1xuICAgICAgICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIuc3RhY2sgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tEZXRhaWxzID0gLy4qYXQgW14oXSpcXCgoLiopOiguKyk6KC4rKVxcKSQvZ2kuZXhlYyhzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRMb2NhdGlvbiA9IHN0YWNrRGV0YWlscyAmJiBzdGFja0RldGFpbHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NyaXB0TG9jYXRpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMiA9IDAsIF9BcnJheSRwcm90b3R5cGUkc2xpYzIgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKS5yZXZlcnNlKCk7IF9pMjIgPCBfQXJyYXkkcHJvdG90eXBlJHNsaWMyLmxlbmd0aDsgX2kyMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gX0FycmF5JHByb3RvdHlwZSRzbGljMltfaTIyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjICYmIHNjcmlwdC5zcmMgPT09IHNjcmlwdExvY2F0aW9uKSByZXR1cm4gc2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgfSgpKSByZXR1cm4gY3VycmVudFNjcmlwdDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGN1cnJlbnQgc2NyaXB0XCIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBjdXJyZW50VUlEID0gdW5pcXVlSUQoKTtcbiAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFVJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWRcIik7XG4gICAgICAgICAgICBpZiAodWlkICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcbiAgICAgICAgICAgIGlmICgodWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIikpICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcbiAgICAgICAgICAgIHVpZCA9IHVuaXF1ZUlEKCk7XG4gICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiLCB1aWQpO1xuICAgICAgICAgICAgcmV0dXJuIHVpZDtcbiAgICAgICAgfSkpO1xuICAgICAgICBmdW5jdGlvbiB0b1B4KHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB2YWwpIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKC9eKFswLTldKykocHh8JSkkLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IG1hdGNoIGNzcyB2YWx1ZSBmcm9tIFwiICsgdmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICAgIH0odmFsKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0NTUyh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB2YWwgPyB0b1B4KHZhbCkgOiBcInN0cmluZ1wiID09IHR5cGVvZiAoc3RyID0gdmFsKSAmJiAvXlswLTldKyUkLy50ZXN0KHN0cikgPyB2YWwgOiB0b1B4KHZhbCk7XG4gICAgICAgICAgICB2YXIgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdsb2JhbF9nZXRHbG9iYWwod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxLZXkgPSBcIl9fcG9zdF9yb2JvdF8xMF8wXzQyX19cIjtcbiAgICAgICAgICAgIHJldHVybiB3aW4gIT09IHdpbmRvdyA/IHdpbltnbG9iYWxLZXldIDogd2luW2dsb2JhbEtleV0gPSB3aW5bZ2xvYmFsS2V5XSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0T2JqID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdsb2JhbFN0b3JlKGtleSwgZGVmU3RvcmUpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuICAgICAgICAgICAgdm9pZCAwID09PSBkZWZTdG9yZSAmJiAoZGVmU3RvcmUgPSBnZXRPYmopO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2xvYmFsX2dldEdsb2JhbCgpLCBrZXksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBkZWZTdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oc3RvcmVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShzdG9yZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmVLZXksIGRlZlZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KSA/IHN0b3JlW3N0b3JlS2V5XSA6IGRlZlZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihzdG9yZUtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtzdG9yZUtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKHN0b3JlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVbc3RvcmVLZXldO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRPclNldDogZnVuY3Rpb24oc3RvcmVLZXksIGdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoc3RvcmUsIHN0b3JlS2V5LCBnZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IGRlZlN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFdpbGRDYXJkID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0V2lsZGNhcmQoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpO1xuICAgICAgICAgICAgZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCA9IGdsb2JhbC5XSU5ET1dfV0lMRENBUkQgfHwgbmV3IFdpbGRDYXJkO1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5XSU5ET1dfV0lMRENBUkQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2luZG93U3RvcmUoa2V5LCBkZWZTdG9yZSkge1xuICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJ3aW5kb3dTdG9yZVwiKS5nZXRPclNldChrZXksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luU3RvcmUgPSBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuICAgICAgICAgICAgICAgIHZhciBnZXRTdG9yZSA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luU3RvcmUuZ2V0T3JTZXQod2luLCBkZWZTdG9yZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0b3JlKHdpbikuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih3aW4sIGRlZlZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2V0U3RvcmUod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpID8gc3RvcmVba2V5XSA6IGRlZlZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih3aW4sIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RvcmUod2luKVtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnZXRTdG9yZSh3aW4pW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbih3aW4sIGdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2V0U3RvcmUod2luKSwga2V5LCBnZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZUlEKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiaW5zdGFuY2VcIikuZ2V0T3JTZXQoXCJpbnN0YW5jZUlEXCIsIHVuaXF1ZUlEKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwgX3JlZikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuICAgICAgICAgICAgdmFyIGhlbGxvUHJvbWlzZXMgPSB3aW5kb3dTdG9yZShcImhlbGxvUHJvbWlzZXNcIik7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQcm9taXNlID0gaGVsbG9Qcm9taXNlcy5nZXQod2luKTtcbiAgICAgICAgICAgIGV4aXN0aW5nUHJvbWlzZSAmJiBleGlzdGluZ1Byb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5ld1Byb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWxsb1Byb21pc2VzLnNldCh3aW4sIG5ld1Byb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2F5SGVsbG8od2luLCBfcmVmNCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVmNC5zZW5kKSh3aW4sIFwicG9zdHJvYm90X2hlbGxvXCIsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG4gICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBfcmVmNS5vcmlnaW4sIGluc3RhbmNlSUQgPSBfcmVmNS5kYXRhLmluc3RhbmNlSUQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGluc3RhbmNlSURcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCBfcmVmNikge1xuICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luZG93SW5zdGFuY2VJRFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYXlIZWxsbyh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy5pbnN0YW5jZUlEO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXJrV2luZG93S25vd24od2luKSB7XG4gICAgICAgICAgICB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5zZXQod2luLCAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNTZXJpYWxpemVkVHlwZShpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgaXRlbSAmJiBudWxsICE9PSBpdGVtICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0uX190eXBlX187XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lVHlwZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHZhbCA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSB2YWwgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkodmFsKSA/IFwiYXJyYXlcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJmdW5jdGlvblwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsID8gdmFsIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yXCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbC50aGVuID8gXCJwcm9taXNlXCIgOiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcInJlZ2V4XCIgOiBcIltvYmplY3QgRGF0ZV1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJkYXRlXCIgOiBcIm9iamVjdFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsID8gXCJzdHJpbmdcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCA/IFwibnVtYmVyXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdmFsID8gXCJib29sZWFuXCIgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplVHlwZSh0eXBlLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX190eXBlX186IHR5cGUsXG4gICAgICAgICAgICAgICAgX192YWxfXzogdmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfU0VSSUFMSVpFUjtcbiAgICAgICAgdmFyIFNFUklBTElaRVIgPSAoKF9TRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBfcmVmLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgc3RhY2s6IF9yZWYuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogX3JlZi5jb2RlLFxuICAgICAgICAgICAgICAgIGRhdGE6IF9yZWYuZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIF9TRVJJQUxJWkVSLnByb21pc2UgPSBmdW5jdGlvbigpIHt9LCBfU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJyZWdleFwiLCB2YWwuc291cmNlKTtcbiAgICAgICAgfSwgX1NFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJkYXRlXCIsIHZhbC50b0pTT04oKSk7XG4gICAgICAgIH0sIF9TRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sIF9TRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSwgX1NFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUik7XG4gICAgICAgIHZhciBkZWZhdWx0U2VyaWFsaXplcnMgPSB7fTtcbiAgICAgICAgdmFyIF9ERVNFUklBTElaRVI7XG4gICAgICAgIHZhciBERVNFUklBTElaRVIgPSAoKF9ERVNFUklBTElaRVIgPSB7fSkuZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHNlcmlhbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkOyBub3RoaW5nIHRvIGRlc2VyaWFsaXplXCIpO1xuICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IF9yZWYyLnN0YWNrLCBjb2RlID0gX3JlZjIuY29kZSwgZGF0YSA9IF9yZWYyLmRhdGE7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoX3JlZjIubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIGRhdGEgJiYgKGVycm9yLmRhdGEgPSBkYXRhKTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2sgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH0sIF9ERVNFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5kYXRlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sIF9ERVNFUklBTElaRVIuc3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sIF9ERVNFUklBTElaRVIpO1xuICAgICAgICB2YXIgZGVmYXVsdERlc2VyaWFsaXplcnMgPSB7fTtcbiAgICAgICAgbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCAxMCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cFByb3h5V2luZG93cygpIHtcbiAgICAgICAgICAgIHZhciBpZFRvUHJveHlXaW5kb3cgPSBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pZFRvUHJveHlXaW5kb3cka2V5czIgPSBpZFRvUHJveHlXaW5kb3cua2V5cygpOyBfaTIgPCBfaWRUb1Byb3h5V2luZG93JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfaWRUb1Byb3h5V2luZG93JGtleXMyW19pMl07XG4gICAgICAgICAgICAgICAgaWRUb1Byb3h5V2luZG93LmdldChpZCkuc2hvdWxkQ2xlYW4oKSAmJiBpZFRvUHJveHlXaW5kb3cuZGVsKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkV2luZG93KHdpblByb21pc2UsIF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kLCBfcmVmJGlkID0gX3JlZi5pZCwgaWQgPSB2b2lkIDAgPT09IF9yZWYkaWQgPyB1bmlxdWVJRCgpIDogX3JlZiRpZDtcbiAgICAgICAgICAgIHZhciB3aW5kb3dOYW1lUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgd2luZG93VHlwZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW5kb3cpKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgY2xvc2VkLCBjYW4gbm90IGRldGVybWluZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRPcGVuZXIod2luZG93KSA/IFdJTkRPV19UWVBFLlBPUFVQIDogV0lORE9XX1RZUEUuSUZSQU1FO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgd2luZG93TmFtZVByb21pc2UuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICB3aW5kb3dUeXBlUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93VHlwZVByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRJbnN0YW5jZUlEOiBtZW1vaXplUHJvbWlzZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKGNsb3NlV2luZG93KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIGlzU2FtZURvbWFpbih3aW4pID8gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgOiB3aW5kb3dOYW1lUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93Q2xvc2VkKHdpbik7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldExvY2F0aW9uOiBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGhyZWYuaW5kZXhPZihcIi9cIikpIGhyZWYgPSBcIlwiICsgZG9tYWluICsgaHJlZjsgZWxzZSBpZiAoIWhyZWYubWF0Y2goL15odHRwcz86XFwvXFwvLykgJiYgMCAhPT0gaHJlZi5pbmRleE9mKGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHVybCB0byBiZSBodHRwIG9yIGh0dHBzIHVybCwgb3IgYWJzb2x1dGUgcGF0aCwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoaHJlZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubG9jYXRpb24gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW4ubG9jYXRpb24ucmVwbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbiA9IGhyZWY7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZURvbWFpbiA9IGlzU2FtZURvbWFpbih3aW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLmZyYW1lRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIxID0gMCwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIik7IF9pMjEgPCBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyLmxlbmd0aDsgX2kyMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9kb2N1bWVudCRxdWVyeVNlbGVjdDJbX2kyMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5jb250ZW50V2luZG93ICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgPT09IHdpbikgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZXQgbmFtZSBmb3IgY3Jvc3MtZG9tYWluIHdpbmRvdzogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dfUHJveHlXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFByb3h5V2luZG93KF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kLCB3aW4gPSBfcmVmMi53aW4sIHNlcmlhbGl6ZWRXaW5kb3cgPSBfcmVmMi5zZXJpYWxpemVkV2luZG93O1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb3h5V2luZG93ID0gITA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSBzZXJpYWxpemVkV2luZG93IHx8IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKS5zZXQodGhpcy5nZXRJRCgpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aW4gJiYgdGhpcy5zZXRXaW5kb3cod2luLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcHJvdG8gPSBQcm94eVdpbmRvdy5wcm90b3R5cGU7XG4gICAgICAgICAgICBfcHJvdG8uZ2V0SUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXRUeXBlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmlzUG9wdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkudGhlbigoZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gV0lORE9XX1RZUEUuUE9QVVA7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKGhyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TG9jYXRpb24oaHJlZikudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldE5hbWUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LnNldE5hbWUobmFtZSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuY2xvc2UoKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGlzUG9wdXBQcm9taXNlID0gdGhpcy5pc1BvcHVwKCk7XG4gICAgICAgICAgICAgICAgdmFyIGdldE5hbWVQcm9taXNlID0gdGhpcy5nZXROYW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlb3BlblByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaXNQb3B1cDogaXNQb3B1cFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldE5hbWVQcm9taXNlXG4gICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBfcmVmMy5pc1BvcHVwICYmIG5hbWUgJiYgd2luZG93Lm9wZW4oXCJcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHZhciBmb2N1c1Byb21pc2UgPSB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcmVvcGVuUHJvbWlzZSwgZm9jdXNQcm9taXNlIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uaXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlzQ2xvc2VkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvdztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uc2V0V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjQuc2VuZDtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHdpbjtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UucmVzb2x2ZSh0aGlzLmFjdHVhbFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SUQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5zZXQod2luLCB0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uYXdhaXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5tYXRjaFdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY1LnNlbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuYWN0dWFsV2luZG93ID8gd2luID09PSBfdGhpczUuYWN0dWFsV2luZG93IDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eUluc3RhbmNlSUQ6IF90aGlzNS5nZXRJbnN0YW5jZUlEKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBrbm93bldpbmRvd0luc3RhbmNlSUQ6IGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IF9yZWY2LnByb3h5SW5zdGFuY2VJRCA9PT0gX3JlZjYua25vd25XaW5kb3dJbnN0YW5jZUlEO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggJiYgX3RoaXM1LnNldFdpbmRvdyh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8udW53cmFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93IHx8IHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldEluc3RhbmNlSUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldEluc3RhbmNlSUQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uc2hvdWxkQ2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFjdHVhbFdpbmRvdyAmJiBpc1dpbmRvd0Nsb3NlZCh0aGlzLmFjdHVhbFdpbmRvdykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFByb3h5V2luZG93LnVud3JhcCA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikgPyB3aW4udW53cmFwKCkgOiB3aW47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUHJveHlXaW5kb3cuc2VyaWFsaXplID0gZnVuY3Rpb24od2luLCBfcmVmNykge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjcuc2VuZDtcbiAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm94eVdpbmRvdy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3csIF9yZWY4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmOC5zZW5kO1xuICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuZ2V0KHNlcmlhbGl6ZWRXaW5kb3cuaWQpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRXaW5kb3c6IHNlcmlhbGl6ZWRXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmICFpc1dpbmRvdyhvYmopICYmIG9iai5pc1Byb3h5V2luZG93KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmOSkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjkuc2VuZDtcbiAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgaWYgKFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luKSkgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsV2luZG93ID0gd2luO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcIndpblRvUHJveHlXaW5kb3dcIikuZ2V0KGFjdHVhbFdpbmRvdykgfHwgbmV3IFByb3h5V2luZG93KHtcbiAgICAgICAgICAgICAgICAgICAgd2luOiBhY3R1YWxXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3c7XG4gICAgICAgIH0oKTtcbiAgICAgICAgZnVuY3Rpb24gYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHNvdXJjZSwgZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuICAgICAgICAgICAgdmFyIHByb3h5V2luZG93TWV0aG9kcyA9IGdsb2JhbFN0b3JlKFwicHJveHlXaW5kb3dNZXRob2RzXCIpO1xuICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHNvdXJjZSkpIHByb3h5V2luZG93TWV0aG9kcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICB9KTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJveHlXaW5kb3dNZXRob2RzLmRlbChpZCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9KSlbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29rdXBNZXRob2Qoc291cmNlLCBpZCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZFN0b3JlID0gd2luZG93U3RvcmUoXCJtZXRob2RTdG9yZVwiKTtcbiAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RTdG9yZS5nZXRPclNldChzb3VyY2UsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9KSlbaWRdIHx8IHByb3h5V2luZG93TWV0aG9kcy5nZXQoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCBfcmVmMykge1xuICAgICAgICAgICAgb24gPSAoX3JlZiA9IHtcbiAgICAgICAgICAgICAgICBvbjogX3JlZjMub24sXG4gICAgICAgICAgICAgICAgc2VuZDogX3JlZjMuc2VuZFxuICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmLnNlbmQsIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImZ1bmN0aW9uQ2FsbHNcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbihcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiXG4gICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfcmVmMi5zb3VyY2UsIG9yaWdpbiA9IF9yZWYyLm9yaWdpbiwgZGF0YSA9IF9yZWYyLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGRhdGEuaWQsIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGgpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1ldGhvZCAnXCIgKyBuYW1lICsgXCInIHdpdGggaWQ6IFwiICsgZGF0YS5pZCArIFwiIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kU291cmNlID0gbWV0aC5zb3VyY2UsIGRvbWFpbiA9IG1ldGguZG9tYWluLCB2YWwgPSBtZXRoLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kICdcIiArIGRhdGEubmFtZSArIFwiJyBkb21haW4gXCIgKyBKU09OLnN0cmluZ2lmeSh1dGlsX2lzUmVnZXgobWV0aC5kb21haW4pID8gbWV0aC5kb21haW4uc291cmNlIDogbWV0aC5kb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3cobWV0aG9kU291cmNlKSkgcmV0dXJuIG1ldGhvZFNvdXJjZS5tYXRjaFdpbmRvdyhzb3VyY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBjYWxsICdcIiArIGRhdGEubmFtZSArIFwiJyBmYWlsZWQgLSBwcm94eSB3aW5kb3cgZG9lcyBub3QgbWF0Y2ggc291cmNlIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmFwcGx5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0YS5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwub25FcnJvcikgcmV0dXJuIHZhbC5vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICYmIChlcnIuc3RhY2sgPSBcIlJlbW90ZSBjYWxsIHRvIFwiICsgbmFtZSArIFwiKFwiICsgZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGFyZ3MgJiYgKGFyZ3MgPSBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZyb20oYXJncykubWFwKChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBhcmcgPyBcIidcIiArIGFyZyArIFwiJ1wiIDogdm9pZCAwID09PSBhcmcgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gYXJnID8gXCJudWxsXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgYXJnID8gYXJnLnRvU3RyaW5nKCkgOiBBcnJheS5pc0FycmF5KGFyZykgPyBcIlsgLi4uIF1cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGFyZyA/IFwieyAuLi4gfVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBhcmcgPyBcIigpID0+IHsgLi4uIH1cIiA6IFwiPFwiICsgdHlwZW9mIGFyZyArIFwiPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZGF0YS5hcmdzKSArIFwiKSBmYWlsZWRcXG5cXG5cIiArIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIF9yZWYsIG9uLCBzZW5kO1xuICAgICAgICAgICAgdmFyIGlkID0gdmFsLl9faWRfXyB8fCB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSB3aW5kb3dfUHJveHlXaW5kb3cudW53cmFwKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdmFsLl9fbmFtZV9fIHx8IHZhbC5uYW1lIHx8IGtleTtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIG5hbWUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuYW1lLmluZGV4T2YgJiYgMCA9PT0gbmFtZS5pbmRleE9mKFwiYW5vbnltb3VzOjpcIikgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoXCJhbm9ueW1vdXM6OlwiLCBrZXkgKyBcIjo6XCIpKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgZGVzdGluYXRpb24sIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHdpbiwgZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2UgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5fZnVuY3Rpb25cIiwge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwgX3JlZikge1xuICAgICAgICAgICAgdmFyIF9zZXJpYWxpemU7XG4gICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHNlcmlhbGl6ZXJzICYmIChzZXJpYWxpemVycyA9IGRlZmF1bHRTZXJpYWxpemVycyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KG9iaiwgKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc1t0eXBlXSB8fCBTRVJJQUxJWkVSW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplciA/IHNlcmlhbGl6ZXIodmFsLCBrZXkpIDogdmFsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSByZXN1bHQgPyBcInVuZGVmaW5lZFwiIDogcmVzdWx0O1xuICAgICAgICAgICAgfShvYmosICgoX3NlcmlhbGl6ZSA9IHt9KS5wcm9taXNlID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5femFsZ29fcHJvbWlzZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCAoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IF9yZWYub24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogX3JlZi5zZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3codmFsKSB8fCB3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh2YWwpID8gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl93aW5kb3dcIiwgd2luZG93X1Byb3h5V2luZG93LnNlcmlhbGl6ZSh2YWwsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pKSA6IHZhbDtcbiAgICAgICAgICAgIH0sIF9zZXJpYWxpemUpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgX2Rlc2VyaWFsaXplO1xuICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGVzZXJpYWxpemVycykge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVzZXJpYWxpemVycyAmJiAoZGVzZXJpYWxpemVycyA9IGRlZmF1bHREZXNlcmlhbGl6ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gc3RyKSByZXR1cm4gSlNPTi5wYXJzZShzdHIsIChmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZhbC5fX3R5cGVfXztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsLl9fdmFsX187XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZXJzW3R5cGVdIHx8IERFU0VSSUFMSVpFUlt0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplciA/IGRlc2VyaWFsaXplcih2YWx1ZSwga2V5KSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0obWVzc2FnZSwgKChfZGVzZXJpYWxpemUgPSB7fSkuY3Jvc3NfZG9tYWluX3phbGdvX3Byb21pc2UgPSBmdW5jdGlvbihzZXJpYWxpemVkUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZShfcmVmMi50aGVuKTtcbiAgICAgICAgICAgICAgICB9KDAsIDAsIHNlcmlhbGl6ZWRQcm9taXNlKTtcbiAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fZnVuY3Rpb24gPSBmdW5jdGlvbihzZXJpYWxpemVkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIF9yZWY0LCBfcmVmNSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmNC5pZCwgbmFtZSA9IF9yZWY0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldERlc2VyaWFsaXplZEZ1bmN0aW9uID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHNvdXJjZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBsb29rdXBNZXRob2Qod2luLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRoICYmIG1ldGgudmFsICE9PSBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcikgcmV0dXJuIG1ldGgudmFsLmFwcGx5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmdzID0gW10uc2xpY2UuY2FsbChfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuZmlyZUFuZEZvcmdldCA/IHNlbmQod2luLCBcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IF9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX25hbWVfXyA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX29yaWdpbl9fID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19zb3VyY2VfXyA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9faWRfXyA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5maXJlQW5kRm9yZ2V0ID0gZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcjtcbiAgICAgICAgICAgICAgICB9KHNvdXJjZSwgb3JpZ2luLCBzZXJpYWxpemVkRnVuY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplLmNyb3NzX2RvbWFpbl93aW5kb3cgPSBmdW5jdGlvbihzZXJpYWxpemVkV2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkV2luZG93LCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyA9IHt9O1xuICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUy5wb3N0cm9ib3RfcG9zdF9tZXNzYWdlID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAwID09PSBkb21haW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChkb21haW4gPSBcIipcIik7XG4gICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2Uoc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgIH07XG4gICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTLnBvc3Ryb2JvdF9nbG9iYWwgPSBmdW5jdGlvbih3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoIWZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAod2luID0gd2luIHx8IHdpbmRvdykubmF2aWdhdG9yLm1vY2tVc2VyQWdlbnQgfHwgd2luLm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgICAgICB9KHdpbmRvdykubWF0Y2goL01TSUV8cnY6MTF8dHJpZGVudHxlZGdlXFwvMTJ8ZWRnZVxcLzEzL2kpKSB0aHJvdyBuZXcgRXJyb3IoXCJHbG9iYWwgbWVzc2FnaW5nIG5vdCBuZWVkZWQgZm9yIGJyb3dzZXJcIik7XG4gICAgICAgICAgICBpZiAoIWlzU2FtZURvbWFpbih3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgdGhyb3VnaCBnbG9iYWwgZGlzYWJsZWQgYmV0d2VlbiBkaWZmZXJlbnQgZG9tYWluIHdpbmRvd3NcIik7XG4gICAgICAgICAgICBpZiAoITEgIT09IGlzU2FtZVRvcFdpbmRvdyh3aW5kb3csIHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IHVzZSBnbG9iYWwgdG8gY29tbXVuaWNhdGUgYmV0d2VlbiB0d28gZGlmZmVyZW50IHdpbmRvd3MsIG5vdCBiZXR3ZWVuIGZyYW1lc1wiKTtcbiAgICAgICAgICAgIHZhciBmb3JlaWduR2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCh3aW4pO1xuICAgICAgICAgICAgaWYgKCFmb3JlaWduR2xvYmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgcG9zdFJvYm90IGdsb2JhbCBvbiBmb3JlaWduIHdpbmRvd1wiKTtcbiAgICAgICAgICAgIGZvcmVpZ25HbG9iYWwucmVjZWl2ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKCksXG4gICAgICAgICAgICAgICAgZGF0YTogc2VyaWFsaXplZE1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCBtZXNzYWdlLCBfcmVmMikge1xuICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbkJ1ZmZlciA9IHdpbmRvd1N0b3JlKCkuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlciA9IGRvbWFpbkJ1ZmZlci5idWZmZXIgfHwgW107XG4gICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5mbHVzaCA9IGRvbWFpbkJ1ZmZlci5mbHVzaCB8fCBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gc2VyaWFsaXplTWVzc2FnZSh3aW4sIGRvbWFpbiwgKChfcmVmID0ge30pLl9fcG9zdF9yb2JvdF8xMF8wXzQyX18gPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdLCBcbiAgICAgICAgICAgICAgICAgICAgX3JlZiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSBPYmplY3Qua2V5cyhTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc3RyYXRlZ2llcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ3lOYW1lID0gc3RyYXRlZ2llc1tfaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tzdHJhdGVneU5hbWVdKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSBzdHJhdGVnaWVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHBvc3Qtcm9ib3QgbWVzc2FnaW5nIHN0cmF0ZWdpZXMgZmFpbGVkOlxcblxcblwiICsgZXJyb3JzLm1hcCgoZnVuY3Rpb24oZXJyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIFwiLiBcIiArIHN0cmluZ2lmeUVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiXFxuXFxuXCIpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkJ1ZmZlci5mbHVzaC50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkJ1ZmZlci5mbHVzaDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmdldChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWxldGVSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcbiAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZGVsKGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQoaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLmhhcyhoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRSZXF1ZXN0TGlzdGVuZXIoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0TGlzdGVuZXJzXCIpO1xuICAgICAgICAgICAgXCIqXCIgPT09IHdpbiAmJiAod2luID0gbnVsbCk7XG4gICAgICAgICAgICBcIipcIiA9PT0gZG9tYWluICYmIChkb21haW4gPSBudWxsKTtcbiAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBnZXQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9yZWYzID0gWyB3aW4sIGdldFdpbGRjYXJkKCkgXTsgX2k0IDwgX3JlZjMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgICAgIHZhciB3aW5RdWFsaWZpZXIgPSBfcmVmM1tfaTRdO1xuICAgICAgICAgICAgICAgIGlmICh3aW5RdWFsaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzLmdldCh3aW5RdWFsaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkxpc3RlbmVycyA9IG5hbWVMaXN0ZW5lcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tkb21haW5dKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW2RvbWFpbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXykgZm9yICh2YXIgX2k2ID0gMCwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMiA9IGRvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fOyBfaTYgPCBfZG9tYWluTGlzdGVuZXJzJF9fRE8yLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZG9tYWluTGlzdGVuZXJzJF9fRE8zID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMltfaTZdLCBsaXN0ZW5lciA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzMubGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hEb21haW4oX2RvbWFpbkxpc3RlbmVycyRfX0RPMy5yZWdleCwgZG9tYWluKSkgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnNbXCIqXCJdKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW1wiKlwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCBfcmVmKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcbiAgICAgICAgICAgICAgICB3aW46IHNvdXJjZSxcbiAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbG9nTmFtZSA9IFwicG9zdHJvYm90X21ldGhvZFwiID09PSBtZXNzYWdlLm5hbWUgJiYgbWVzc2FnZS5kYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIG1lc3NhZ2UuZGF0YS5uYW1lID8gbWVzc2FnZS5kYXRhLm5hbWUgKyBcIigpXCIgOiBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBzZW5kUmVzcG9uc2UoYWNrLCBkYXRhLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2s6IGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIHJlc3BvbnNlIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgYWNrIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSwgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBvcHRpb25zLmRvbWFpbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5oYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcInN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcImVycm9yXCIsIG51bGwsIGVycm9yKTtcbiAgICAgICAgICAgIH0pKSBdKS50aGVuKHNyY191dGlsX25vb3ApLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUVycm9yKSByZXR1cm4gb3B0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgYWNrIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgb3B0aW9ucy5kb21haW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWNrID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgcmVzcG9uc2UgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4ob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIChwYXR0ZXJuID0gb3B0aW9ucy5kb21haW4sIFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGF0dGVybikgPyBcIihcIiArIHBhdHRlcm4uam9pbihcIiB8IFwiKSArIFwiKVwiIDogaXNSZWdleChwYXR0ZXJuKSA/IFwiUmVnRXhwKFwiICsgcGF0dGVybi50b1N0cmluZygpIDogcGF0dGVybi50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICBkZWxldGVSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgXCJlcnJvclwiID09PSBtZXNzYWdlLmFjayA/IG9wdGlvbnMucHJvbWlzZS5yZWplY3QobWVzc2FnZS5lcnJvcikgOiBcInN1Y2Nlc3NcIiA9PT0gbWVzc2FnZS5hY2sgJiYgb3B0aW9ucy5wcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UoZXZlbnQsIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBfcmVmMi5vbiwgc2VuZCA9IF9yZWYyLnNlbmQ7XG4gICAgICAgICAgICB2YXIgcmVjZWl2ZWRNZXNzYWdlcyA9IGdsb2JhbFN0b3JlKFwicmVjZWl2ZWRNZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cgfHwgd2luZG93LmNsb3NlZCB8fCAhZXZlbnQuc291cmNlKSByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlLCBvcmlnaW4gPSBldmVudC5vcmlnaW47XG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBmdW5jdGlvbihtZXNzYWdlLCBzb3VyY2UsIG9yaWdpbiwgX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkTWVzc2FnZSA9IGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBwYXJzZWRNZXNzYWdlICYmIG51bGwgIT09IHBhcnNlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlTWVzc2FnZXMgPSBwYXJzZWRNZXNzYWdlLl9fcG9zdF9yb2JvdF8xMF8wXzQyX187XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlTWVzc2FnZXMpKSByZXR1cm4gcGFyc2VNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KGV2ZW50LmRhdGEsIHNvdXJjZSwgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgb246IG9uLFxuICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgbWFya1dpbmRvd0tub3duKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVzc2FnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW19pMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlLmlkKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLnNldChtZXNzYWdlLmlkLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZChzb3VyY2UpICYmICFtZXNzYWdlLmZpcmVBbmRGb3JnZXQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gbWVzc2FnZS5vcmlnaW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChvcmlnaW4gPSBcImZpbGU6Ly9cIik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVxdWVzdChzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIiA9PT0gbWVzc2FnZS50eXBlICYmIGhhbmRsZUFjayhzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uX29uKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGhhbmRsZXJcIik7XG4gICAgICAgICAgICAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgb3B0aW9ucy5oYW5kbGVyID0gaGFuZGxlciB8fCBvcHRpb25zLmhhbmRsZXI7XG4gICAgICAgICAgICB2YXIgd2luID0gb3B0aW9ucy53aW5kb3c7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW47XG4gICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyID0gZnVuY3Rpb24gYWRkUmVxdWVzdExpc3RlbmVyKF9yZWY0LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjQubmFtZSwgd2luID0gX3JlZjQud2luLCBkb21haW4gPSBfcmVmNC5kb21haW47XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gYWRkIHJlcXVlc3QgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfd2luMiA9IHdpbjsgX2k4IDwgX3dpbjIubGVuZ3RoOyBfaTgrKykgbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW46IF93aW4yW19pOF1cbiAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBsaXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxMCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uW19pMTBdLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2RvbWFpbjIgPSBkb21haW47IF9pMTIgPCBfZG9tYWluMi5sZW5ndGg7IF9pMTIrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfZG9tYWluMltfaTEyXVxuICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IF9saXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxNCsrKSBfbGlzdGVuZXJzQ29sbGVjdGlvbltfaTE0XS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nTGlzdGVuZXIgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW4gJiYgXCIqXCIgIT09IHdpbiB8fCAod2luID0gZ2V0V2lsZGNhcmQoKSk7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluIHx8IFwiKlwiO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0xpc3RlbmVyKSB0aHJvdyB3aW4gJiYgZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiB3aW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSkgOiBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluTGlzdGVuZXJzID0gdXRpbF9nZXRPclNldChuYW1lTGlzdGVuZXJzLCBuYW1lLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ckRvbWFpbiA9IGRvbWFpbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciByZWdleExpc3RlbmVycztcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICB1dGlsX2lzUmVnZXgoZG9tYWluKSA/IChyZWdleExpc3RlbmVycyA9IHV0aWxfZ2V0T3JTZXQoZG9tYWluTGlzdGVuZXJzLCBcIl9fZG9tYWluX3JlZ2V4X19cIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfSkpKS5wdXNoKHJlZ2V4TGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIH0pIDogZG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkxpc3RlbmVyc1tzdHJEb21haW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleExpc3RlbmVycy5zcGxpY2UocmVnZXhMaXN0ZW5lcnMuaW5kZXhPZihyZWdleExpc3RlbmVyLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhMaXN0ZW5lcnMubGVuZ3RoIHx8IGRlbGV0ZSBkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRvbWFpbkxpc3RlbmVycykubGVuZ3RoIHx8IGRlbGV0ZSBuYW1lTGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luICYmICFPYmplY3Qua2V5cyhuYW1lTGlzdGVuZXJzKS5sZW5ndGggJiYgcmVxdWVzdExpc3RlbmVycy5kZWwod2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogb3B0aW9ucy5oYW5kbGVyLFxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiBvcHRpb25zLmVycm9ySGFuZGxlciB8fCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd2luZG93OiB3aW4sXG4gICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4gfHwgXCIqXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW5kX3NlbmQgPSBmdW5jdGlvbiBzZW5kKHdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGRvbWFpbk1hdGNoZXIgPSAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLmRvbWFpbiB8fCBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgLTE7XG4gICAgICAgICAgICB2YXIgY2hpbGRUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDVlMztcbiAgICAgICAgICAgIHZhciBmaXJlQW5kRm9yZ2V0ID0gb3B0aW9ucy5maXJlQW5kRm9yZ2V0IHx8ICExO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKG5hbWUsIHdpbiwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBkb21haW4gJiYgIUFycmF5LmlzQXJyYXkoZG9tYWluKSAmJiAhdXRpbF9pc1JlZ2V4KGRvbWFpbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIEV4cGVjdGVkIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KGRvbWFpbikgKyBcIiB0byBiZSBhIHN0cmluZywgYXJyYXksIG9yIHJlZ2V4XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZW5kIFwiICsgbmFtZSArIFwiLiBUYXJnZXQgd2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICB9KG5hbWUsIHdpbiwgZG9tYWluTWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFBhcmVudCA9IGdldEFuY2VzdG9yKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFBhcmVudCkgcmV0dXJuIGFjdHVhbFBhcmVudCA9PT0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0VG9wKGNoaWxkKSA9PT0gY2hpbGQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxNSA9IDAsIF9nZXRGcmFtZXM4ID0gZ2V0RnJhbWVzKHBhcmVudCk7IF9pMTUgPCBfZ2V0RnJhbWVzOC5sZW5ndGg7IF9pMTUrKykgaWYgKF9nZXRGcmFtZXM4W19pMTVdID09PSBjaGlsZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfSh3aW5kb3csIHdpbikpIHJldHVybiBmdW5jdGlvbih3aW4sIHRpbWVvdXQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB0aW1lb3V0ICYmICh0aW1lb3V0ID0gNWUzKTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lICYmIChuYW1lID0gXCJXaW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0od2luKTtcbiAgICAgICAgICAgICAgICAgICAgLTEgIT09IHRpbWVvdXQgJiYgKHByb21pc2UgPSBwcm9taXNlLnRpbWVvdXQodGltZW91dCwgbmV3IEVycm9yKG5hbWUgKyBcIiBkaWQgbm90IGxvYWQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCJtc1wiKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9KHdpbiwgY2hpbGRUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihfdGVtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih3aW4sIHRhcmdldERvbWFpbiwgYWN0dWFsRG9tYWluLCBfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0YXJnZXREb21haW4gPyB0YXJnZXREb21haW4gOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxEb21haW4gfHwgc2F5SGVsbG8od2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihub3JtYWxpemVkRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbih0YXJnZXREb21haW4sIHRhcmdldERvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkRvbWFpbiBcIiArIHN0cmluZ2lmeSh0YXJnZXREb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWREb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KHdpbiwgZG9tYWluTWF0Y2hlciwgKHZvaWQgMCA9PT0gX3RlbXAgPyB7fSA6IF90ZW1wKS5kb21haW4sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHRhcmdldERvbWFpbikge1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0YXJnZXREb21haW47XG4gICAgICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbmFtZSAmJiBkYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRhdGEubmFtZSA/IGRhdGEubmFtZSArIFwiKClcIiA6IG5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBuYW1lICsgXCJfXCIgKyB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgIGlmICghZmlyZUFuZEZvcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuc2V0KGhhc2gsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfShoYXNoLCByZXNwb25zZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVByb21pc2VzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxBY2tUaW1lb3V0ID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJrbm93bldpbmRvd3NcIikuZ2V0KHdpbiwgITEpO1xuICAgICAgICAgICAgICAgICAgICB9KHdpbikgPyAxZTQgOiAyZTM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJlc1RpbWVvdXQgPSByZXNwb25zZVRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2tUaW1lb3V0ID0gdG90YWxBY2tUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzVGltZW91dCA9IHRvdGFsUmVzVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2FmZUludGVydmFsKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIFwiICsgKHJlc3BvbnNlTGlzdGVuZXIuYWNrID8gXCJyZXNwb25zZVwiIDogXCJhY2tcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUxpc3RlbmVyLmNhbmNlbGxlZCkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlc3BvbnNlIGxpc3RlbmVyIHdhcyBjYW5jZWxsZWQgZm9yIFwiICsgbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNrVGltZW91dCA9IE1hdGgubWF4KGFja1RpbWVvdXQgLSA1MDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHJlc1RpbWVvdXQgJiYgKHJlc1RpbWVvdXQgPSBNYXRoLm1heChyZXNUaW1lb3V0IC0gNTAwLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VMaXN0ZW5lci5hY2sgfHwgMCAhPT0gYWNrVGltZW91dCA/IDAgPT09IHJlc1RpbWVvdXQgPyBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxSZXNUaW1lb3V0ICsgXCJtc1wiKSkgOiB2b2lkIDAgOiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBhY2sgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsQWNrVGltZW91dCArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMuc3BsaWNlKHJlcVByb21pc2VzLmluZGV4T2YocHJvbWlzZSwgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmlyZUFuZEZvcmdldFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJlQW5kRm9yZ2V0ID8gcHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVxdWVzdCBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmosIHtcbiAgICAgICAgICAgICAgICBvbjogb25fb24sXG4gICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBvbjogb25fb24sXG4gICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cF90b1Byb3h5V2luZG93KHdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGliX2dsb2JhbF9nZXRHbG9iYWwod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZ2V0IGdsb2JhbCBmb3Igd2luZG93IG9uIGRpZmZlcmVudCBkb21haW5cIik7XG4gICAgICAgICAgICB3aW4uX196b2lkXzlfMF82M19fIHx8ICh3aW4uX196b2lkXzlfMF82M19fID0ge30pO1xuICAgICAgICAgICAgcmV0dXJuIHdpbi5fX3pvaWRfOV8wXzYzX187XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UHJveHlPYmplY3Qob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNvdXJjZSAmJiBfdGhpcy5zb3VyY2UgIT09IHdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjYWxsIGdldCBvbiBwcm94eSBvYmplY3QgZnJvbSBhIHJlbW90ZSB3aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUFJPUF9UWVBFID0ge1xuICAgICAgICAgICAgU1RSSU5HOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgT0JKRUNUOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgRlVOQ1RJT046IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIEJPT0xFQU46IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgTlVNQkVSOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgQVJSQVk6IFwiYXJyYXlcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgUFJPUF9TRVJJQUxJWkFUSU9OID0ge1xuICAgICAgICAgICAgSlNPTjogXCJqc29uXCIsXG4gICAgICAgICAgICBET1RJRlk6IFwiZG90aWZ5XCIsXG4gICAgICAgICAgICBCQVNFNjQ6IFwiYmFzZTY0XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIENPTlRFWFQgPSBXSU5ET1dfVFlQRTtcbiAgICAgICAgdmFyIEVWRU5UID0ge1xuICAgICAgICAgICAgUkVOREVSOiBcInpvaWQtcmVuZGVyXCIsXG4gICAgICAgICAgICBSRU5ERVJFRDogXCJ6b2lkLXJlbmRlcmVkXCIsXG4gICAgICAgICAgICBESVNQTEFZOiBcInpvaWQtZGlzcGxheVwiLFxuICAgICAgICAgICAgRVJST1I6IFwiem9pZC1lcnJvclwiLFxuICAgICAgICAgICAgQ0xPU0U6IFwiem9pZC1jbG9zZVwiLFxuICAgICAgICAgICAgREVTVFJPWTogXCJ6b2lkLWRlc3Ryb3lcIixcbiAgICAgICAgICAgIFBST1BTOiBcInpvaWQtcHJvcHNcIixcbiAgICAgICAgICAgIFJFU0laRTogXCJ6b2lkLXJlc2l6ZVwiLFxuICAgICAgICAgICAgRk9DVVM6IFwiem9pZC1mb2N1c1wiXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkUHJvcChwcm9wc0RlZiwgcHJvcHMsIGtleSwgdmFsdWUsIGhlbHBlcnMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHNEZWYuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5jaGlsZERlY29yYXRlID8gcHJvcC5jaGlsZERlY29yYXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdWlkOiBoZWxwZXJzLnVpZCxcbiAgICAgICAgICAgICAgICBjbG9zZTogaGVscGVycy5jbG9zZSxcbiAgICAgICAgICAgICAgICBmb2N1czogaGVscGVycy5mb2N1cyxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBoZWxwZXJzLm9uRXJyb3IsXG4gICAgICAgICAgICAgICAgb25Qcm9wczogaGVscGVycy5vblByb3BzLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogaGVscGVycy5yZXNpemUsXG4gICAgICAgICAgICAgICAgZ2V0UGFyZW50OiBoZWxwZXJzLmdldFBhcmVudCxcbiAgICAgICAgICAgICAgICBnZXRQYXJlbnREb21haW46IGhlbHBlcnMuZ2V0UGFyZW50RG9tYWluLFxuICAgICAgICAgICAgICAgIHNob3c6IGhlbHBlcnMuc2hvdyxcbiAgICAgICAgICAgICAgICBoaWRlOiBoZWxwZXJzLmhpZGVcbiAgICAgICAgICAgIH0pIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDaGlsZFdpbmRvd05hbWUod2luZG93TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZU1lbW9pemUocGFyc2VDaGlsZFdpbmRvd05hbWUsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvd05hbWUpIHRocm93IG5ldyBFcnJvcihcIk5vIHdpbmRvdyBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIHZhciBfd2luZG93TmFtZSRzcGxpdCA9IHdpbmRvd05hbWUuc3BsaXQoXCJfX1wiKSwgem9pZGNvbXAgPSBfd2luZG93TmFtZSRzcGxpdFsxXSwgbmFtZSA9IF93aW5kb3dOYW1lJHNwbGl0WzJdLCBlbmNvZGVkUGF5bG9hZCA9IF93aW5kb3dOYW1lJHNwbGl0WzNdO1xuICAgICAgICAgICAgICAgIGlmIChcInpvaWRcIiAhPT0gem9pZGNvbXApIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBub3QgcmVuZGVyZWQgYnkgem9pZCAtIGdvdCBcIiArIHpvaWRjb21wKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGNvbXBvbmVudCBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghZW5jb2RlZFBheWxvYWQpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVuY29kZWQgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGF0b2IpIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoW10ubWFwLmNhbGwoYXRvYihzdHIpLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgd2luZG93LmF0b2Igb3IgQnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KGVuY29kZWRQYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVjb2RlIHdpbmRvdyBuYW1lIHBheWxvYWQ6IFwiICsgZW5jb2RlZFBheWxvYWQgKyBcIjogXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgWyB3aW5kb3dOYW1lIF0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldENoaWxkUGF5bG9hZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2hpbGRXaW5kb3dOYW1lKHdpbmRvdy5uYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGlsZF9mb2N1cygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9wc19nZXRRdWVyeVBhcmFtKHByb3AsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHByb3AucXVlcnlQYXJhbSA/IHByb3AucXVlcnlQYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgcHJvcC5xdWVyeVBhcmFtID8gcHJvcC5xdWVyeVBhcmFtIDoga2V5O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFF1ZXJ5VmFsdWUocHJvcCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5xdWVyeVZhbHVlICYmIGlzRGVmaW5lZCh2YWx1ZSkgPyBwcm9wLnF1ZXJ5VmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSA6IHZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudENvbXBvbmVudChvcHRpb25zLCBvdmVycmlkZXMsIHBhcmVudFdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSBvdmVycmlkZXMgJiYgKG92ZXJyaWRlcyA9IHt9KTtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcGFyZW50V2luICYmIChwYXJlbnRXaW4gPSB3aW5kb3cpO1xuICAgICAgICAgICAgdmFyIHByb3BzRGVmID0gb3B0aW9ucy5wcm9wc0RlZiwgY29udGFpbmVyVGVtcGxhdGUgPSBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlLCBwcmVyZW5kZXJUZW1wbGF0ZSA9IG9wdGlvbnMucHJlcmVuZGVyVGVtcGxhdGUsIHRhZyA9IG9wdGlvbnMudGFnLCBuYW1lID0gb3B0aW9ucy5uYW1lLCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLCBkaW1lbnNpb25zID0gb3B0aW9ucy5kaW1lbnNpb25zLCBhdXRvUmVzaXplID0gb3B0aW9ucy5hdXRvUmVzaXplLCB1cmwgPSBvcHRpb25zLnVybCwgZG9tYWluTWF0Y2ggPSBvcHRpb25zLmRvbWFpbjtcbiAgICAgICAgICAgIHZhciBpbml0UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVkRXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgY2xlYW4gPSBjbGVhbnVwKCk7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHZpc2libGU6ICEwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gb3ZlcnJpZGVzLmV2ZW50ID8gb3ZlcnJpZGVzLmV2ZW50IDogKHRyaWdnZXJlZCA9IHt9LCBoYW5kbGVycyA9IHt9LCBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBoYW5kbGVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGlzdC5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGlzdC5zcGxpY2UoaGFuZGxlckxpc3QuaW5kZXhPZihoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25jZTogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMub24oZXZlbnROYW1lLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKF9pMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlckxpc3RbX2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBoYW5kbGVyTGlzdC5sZW5ndGg7IF9pMisrKSBfbG9vcChfaTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyT25jZTogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyZWRbZXZlbnROYW1lXSkgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkW2V2ZW50TmFtZV0gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgWyBldmVudE5hbWUgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJlZCwgaGFuZGxlcnM7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBvdmVycmlkZXMucHJvcHMgPyBvdmVycmlkZXMucHJvcHMgOiB7fTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJveHlXaW47XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb3h5Q29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGNoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIG9uRXJyb3JPdmVycmlkZSA9IG92ZXJyaWRlcy5vbkVycm9yO1xuICAgICAgICAgICAgdmFyIGdldFByb3h5Q29udGFpbmVyT3ZlcnJpZGUgPSBvdmVycmlkZXMuZ2V0UHJveHlDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc2hvd092ZXJyaWRlID0gb3ZlcnJpZGVzLnNob3c7XG4gICAgICAgICAgICB2YXIgaGlkZU92ZXJyaWRlID0gb3ZlcnJpZGVzLmhpZGU7XG4gICAgICAgICAgICB2YXIgY2xvc2VPdmVycmlkZSA9IG92ZXJyaWRlcy5jbG9zZTtcbiAgICAgICAgICAgIHZhciByZW5kZXJDb250YWluZXJPdmVycmlkZSA9IG92ZXJyaWRlcy5yZW5kZXJDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgZ2V0UHJveHlXaW5kb3dPdmVycmlkZSA9IG92ZXJyaWRlcy5nZXRQcm94eVdpbmRvdztcbiAgICAgICAgICAgIHZhciBzZXRQcm94eVdpbk92ZXJyaWRlID0gb3ZlcnJpZGVzLnNldFByb3h5V2luO1xuICAgICAgICAgICAgdmFyIG9wZW5GcmFtZU92ZXJyaWRlID0gb3ZlcnJpZGVzLm9wZW5GcmFtZTtcbiAgICAgICAgICAgIHZhciBvcGVuUHJlcmVuZGVyRnJhbWVPdmVycmlkZSA9IG92ZXJyaWRlcy5vcGVuUHJlcmVuZGVyRnJhbWU7XG4gICAgICAgICAgICB2YXIgcHJlcmVuZGVyT3ZlcnJpZGUgPSBvdmVycmlkZXMucHJlcmVuZGVyO1xuICAgICAgICAgICAgdmFyIG9wZW5PdmVycmlkZSA9IG92ZXJyaWRlcy5vcGVuO1xuICAgICAgICAgICAgdmFyIG9wZW5QcmVyZW5kZXJPdmVycmlkZSA9IG92ZXJyaWRlcy5vcGVuUHJlcmVuZGVyO1xuICAgICAgICAgICAgdmFyIHdhdGNoRm9yVW5sb2FkT3ZlcnJpZGUgPSBvdmVycmlkZXMud2F0Y2hGb3JVbmxvYWQ7XG4gICAgICAgICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlID0gb3ZlcnJpZGVzLmdldEludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB2YXIgc2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlID0gb3ZlcnJpZGVzLnNldEludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB2YXIgZ2V0UHJvcHNGb3JDaGlsZCA9IGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9PYmplY3Qka2V5czJbX2kyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgICAgICAgICBwcm9wICYmICExID09PSBwcm9wLnNlbmRUb0NoaWxkIHx8IHByb3AgJiYgcHJvcC5zYW1lRG9tYWluICYmICFtYXRjaERvbWFpbihkb21haW4sIGdldERvbWFpbih3aW5kb3cpKSB8fCAocmVzdWx0W2tleV0gPSBwcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2gocmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlID8gZ2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlKCkgOiBpbnRlcm5hbFN0YXRlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGZ1bmN0aW9uKG5ld0ludGVybmFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEludGVybmFsU3RhdGVPdmVycmlkZSA/IHNldEludGVybmFsU3RhdGVPdmVycmlkZShuZXdJbnRlcm5hbFN0YXRlKSA6IGludGVybmFsU3RhdGUgPSBfZXh0ZW5kcyh7fSwgaW50ZXJuYWxTdGF0ZSwgbmV3SW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXRQcm94eVdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eVdpbmRvd092ZXJyaWRlID8gZ2V0UHJveHlXaW5kb3dPdmVycmlkZSgpIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd1Byb3AgPSBwcm9wcy53aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3dQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Byb3h5V2luID0gc2V0dXBfdG9Qcm94eVdpbmRvdyh3aW5kb3dQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93UHJvcC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm94eVdpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvd19Qcm94eVdpbmRvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXRQcm94eUNvbnRhaW5lciA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eUNvbnRhaW5lck92ZXJyaWRlID8gZ2V0UHJveHlDb250YWluZXJPdmVycmlkZShjb250YWluZXIpIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRSZWFkeShjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihjb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2hhZG93RWxlbWVudChjb250YWluZXJFbGVtZW50KSAmJiAoY29udGFpbmVyRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dIb3N0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dSb290ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtlbGVtZW50LnBhcmVudE5vZGU7ICkgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2hhZG93RWxlbWVudChlbGVtZW50KSkgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdC5ob3N0KSByZXR1cm4gc2hhZG93Um9vdC5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hhZG93SG9zdCkgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgaW4gc2hhZG93IGRvbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NoYWRvd0VsZW1lbnQoc2hhZG93SG9zdCkpIHRocm93IG5ldyBFcnJvcihcIkhvc3QgZWxlbWVudCBpcyBhbHNvIGluIHNoYWRvdyBkb21cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdE5hbWUgPSBcInNoYWRvdy1zbG90LVwiICsgdW5pcXVlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNsb3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgc2xvdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChzbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90UHJvdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdFByb3ZpZGVyLnNldEF0dHJpYnV0ZShcInNsb3RcIiwgc2xvdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93SG9zdC5hcHBlbmRDaGlsZChzbG90UHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsb3RQcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgICAgfShjb250YWluZXJFbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eU9iamVjdChjb250YWluZXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNldFByb3h5V2luID0gZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJveHlXaW5PdmVycmlkZSA/IHNldFByb3h5V2luT3ZlcnJpZGUocHJveHlXaW4pIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3h5V2luID0gcHJveHlXaW47XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3dPdmVycmlkZSA/IHNob3dPdmVycmlkZSgpIDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlOiBzZXRJbnRlcm5hbFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzaG93RWxlbWVudDogY3VycmVudFByb3h5Q29udGFpbmVyID8gY3VycmVudFByb3h5Q29udGFpbmVyLmdldCgpLnRoZW4oc2hvd0VsZW1lbnQpIDogbnVsbFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkZU92ZXJyaWRlID8gaGlkZU92ZXJyaWRlKCkgOiBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGU6IHNldEludGVybmFsU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogITFcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHNob3dFbGVtZW50OiBjdXJyZW50UHJveHlDb250YWluZXIgPyBjdXJyZW50UHJveHlDb250YWluZXIuZ2V0KCkudGhlbihoaWRlRWxlbWVudCkgOiBudWxsXG4gICAgICAgICAgICAgICAgfSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0VXJsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdXJsID8gdXJsKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgICAgICAgICAgfSkgOiB1cmw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBhdHRyaWJ1dGVzID8gYXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgIH0pIDogYXR0cmlidXRlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0Q2hpbGREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluTWF0Y2ggJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZG9tYWluTWF0Y2ggPyBkb21haW5NYXRjaCA6IGdldERvbWFpbkZyb21VcmwoZ2V0VXJsKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXREb21haW5NYXRjaGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbk1hdGNoICYmIHV0aWxfaXNSZWdleChkb21haW5NYXRjaCkgPyBkb21haW5NYXRjaCA6IGdldENoaWxkRG9tYWluKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9wZW5GcmFtZSA9IGZ1bmN0aW9uKGNvbnRleHQsIF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93TmFtZSA9IF9yZWYud2luZG93TmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlbkZyYW1lT3ZlcnJpZGUgPyBvcGVuRnJhbWVPdmVycmlkZShjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IHdpbmRvd05hbWVcbiAgICAgICAgICAgICAgICB9KSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkgcmV0dXJuIGdldFByb3h5T2JqZWN0KGRvbV9pZnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHdpbmRvd05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGdldEF0dHJpYnV0ZXMoKS5pZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9wZW5QcmVyZW5kZXJGcmFtZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblByZXJlbmRlckZyYW1lT3ZlcnJpZGUgPyBvcGVuUHJlcmVuZGVyRnJhbWVPdmVycmlkZShjb250ZXh0KSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkgcmV0dXJuIGdldFByb3h5T2JqZWN0KGRvbV9pZnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX196b2lkX3ByZXJlbmRlcl9mcmFtZV9fXCIgKyBuYW1lICsgXCJfXCIgKyB1bmlxdWVJRCgpICsgXCJfX1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcInByZXJlbmRlcl9fXCIgKyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBnZXRBdHRyaWJ1dGVzKCkuaWZyYW1lKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvcGVuUHJlcmVuZGVyID0gZnVuY3Rpb24oY29udGV4dCwgcHJveHlXaW4sIHByb3h5UHJlcmVuZGVyRnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblByZXJlbmRlck92ZXJyaWRlID8gb3BlblByZXJlbmRlck92ZXJyaWRlKGNvbnRleHQsIHByb3h5V2luLCBwcm94eVByZXJlbmRlckZyYW1lKSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm94eVByZXJlbmRlckZyYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcm94eSBmcmFtZSB0byBiZSBwYXNzZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlQcmVyZW5kZXJGcmFtZS5nZXQoKS50aGVuKChmdW5jdGlvbihwcmVyZW5kZXJGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lFbGVtZW50KHByZXJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0RnJhbWVXaW5kb3cocHJlcmVuZGVyRnJhbWUpLnRoZW4oKGZ1bmN0aW9uKHByZXJlbmRlckZyYW1lV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHByZXJlbmRlckZyYW1lV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cF90b1Byb3h5V2luZG93KHdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlbmRlciBjb250ZXh0IGF2YWlsYWJsZSBmb3IgXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJveHlXaW4pIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyBldmVudC50cmlnZ2VyKEVWRU5ULkZPQ1VTKSwgY3VycmVudFByb3h5V2luLmZvY3VzKCkgXSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFdpbmRvd1JlZiA9IGZ1bmN0aW9uKHRhcmdldCwgZG9tYWluLCB1aWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluID09PSBnZXREb21haW4od2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsID0gbGliX2dsb2JhbF9nZXRHbG9iYWwod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLndpbmRvd3MgPSBnbG9iYWwud2luZG93cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLndpbmRvd3NbdWlkXSA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbC53aW5kb3dzW3VpZF07XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2xvYmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCA9PT0gQ09OVEVYVC5QT1BVUCA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvcGVuZXJcIlxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGFyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBnZXREaXN0YW5jZUZyb21Ub3Aod2luZG93KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGluaXRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkRXhwb3J0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZENvbXBvbmVudCA9IGNoaWxkRXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRFeHBvcnRzLmNsb3NlLmZpcmVBbmRGb3JnZXQoKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzaXplID0gZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCwgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKEVWRU5ULlJFU0laRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50cmlnZ2VyKEVWRU5ULkRFU1RST1kpO1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaChzcmNfdXRpbF9ub29wKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuLmFsbChlcnIpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2UuYXN5bmNSZWplY3QoZXJyIHx8IG5ldyBFcnJvcihcIkNvbXBvbmVudCBkZXN0cm95ZWRcIikpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBtZW1vaXplKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZChjbG9zZU92ZXJyaWRlLl9fc291cmNlX18pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VPdmVycmlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRyaWdnZXIoRVZFTlQuQ0xPU0UpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzdHJveShlcnIgfHwgbmV3IEVycm9yKFwiQ29tcG9uZW50IGNsb3NlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IGZ1bmN0aW9uKGNvbnRleHQsIF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3h5V2luID0gX3JlZjMucHJveHlXaW4sIHByb3h5RnJhbWUgPSBfcmVmMy5wcm94eUZyYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuT3ZlcnJpZGUgPyBvcGVuT3ZlcnJpZGUoY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogcHJveHlXaW4sXG4gICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IHByb3h5RnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IF9yZWYzLndpbmRvd05hbWVcbiAgICAgICAgICAgICAgICB9KSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm94eUZyYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcm94eSBmcmFtZSB0byBiZSBwYXNzZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlGcmFtZS5nZXQoKS50aGVuKChmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdEZyYW1lV2luZG93KGZyYW1lKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lFbGVtZW50KGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3JlcXVlc3RQcm9taXNlcyRnZXQyID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0KHdpbiwgW10pOyBfaTIgPCBfcmVxdWVzdFByb21pc2VzJGdldDIubGVuZ3RoOyBfaTIrKykgX3JlcXVlc3RQcm9taXNlcyRnZXQyW19pMl0ucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBcIiArIChpc1dpbmRvd0Nsb3NlZCh3aW4pID8gXCJjbG9zZWRcIiA6IFwiY2xlYW5lZCB1cFwiKSArIFwiIGJlZm9yZSByZXNwb25zZVwiKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVuZGVyIGNvbnRleHQgYXZhaWxhYmxlIGZvciBcIiArIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlXaW4uc2V0V2luZG93KHdpbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlXaW47XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB3YXRjaEZvclVubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5sb2FkV2luZG93TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJ1bmxvYWRcIiwgb25jZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95KG5ldyBFcnJvcihcIldpbmRvdyBuYXZpZ2F0ZWQgYXdheVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVBhcmVudFdpbmRvd0xpc3RlbmVyID0gb25DbG9zZVdpbmRvdyhwYXJlbnRXaW4sIGRlc3Ryb3ksIDNlMyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKGNsb3NlUGFyZW50V2luZG93TGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIodW5sb2FkV2luZG93TGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhdGNoRm9yVW5sb2FkT3ZlcnJpZGUpIHJldHVybiB3YXRjaEZvclVubG9hZE92ZXJyaWRlKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjaGVja1dpbmRvd0Nsb3NlID0gZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VkID0gITE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5V2luLmlzQ2xvc2VkKCkudGhlbigoZnVuY3Rpb24oaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZShuZXcgRXJyb3IoXCJEZXRlY3RlZCBjb21wb25lbnQgd2luZG93IGNsb3NlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuZGVsYXkoMjAwKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eVdpbi5pc0Nsb3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oc2Vjb25kSXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmRJc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZShuZXcgRXJyb3IoXCJEZXRlY3RlZCBjb21wb25lbnQgd2luZG93IGNsb3NlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25FcnJvck92ZXJyaWRlID8gb25FcnJvck92ZXJyaWRlKGVycikgOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGhhbmRsZWRFcnJvcnMuaW5kZXhPZihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLmFzeW5jUmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHJpZ2dlcihFVkVOVC5FUlJPUiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbml0Q2hpbGQub25FcnJvciA9IG9uRXJyb3I7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVGVtcGxhdGUgPSBmdW5jdGlvbihyZW5kZXJlciwgX3JlZjYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIoe1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IF9yZWY2LmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3JlZjYuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdWlkOiBfcmVmNi51aWQsXG4gICAgICAgICAgICAgICAgICAgIGRvYzogX3JlZjYuZG9jLFxuICAgICAgICAgICAgICAgICAgICBmcmFtZTogX3JlZjYuZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lOiBfcmVmNi5wcmVyZW5kZXJGcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHByZXJlbmRlciA9IGZ1bmN0aW9uKHByb3h5UHJlcmVuZGVyV2luLCBfcmVmNykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3JlZjcuY29udGV4dCwgdWlkID0gX3JlZjcudWlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVyZW5kZXJPdmVycmlkZSA/IHByZXJlbmRlck92ZXJyaWRlKHByb3h5UHJlcmVuZGVyV2luLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgfSkgOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlcmVuZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVyZW5kZXJXaW5kb3cgPSBwcm94eVByZXJlbmRlcldpbi5nZXRXaW5kb3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVyZW5kZXJXaW5kb3cgJiYgaXNTYW1lRG9tYWluKHByZXJlbmRlcldpbmRvdykgJiYgZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4ubG9jYXRpb24uaHJlZikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJhYm91dDpibGFua1wiID09PSB3aW4ubG9jYXRpb24uaHJlZikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByZXJlbmRlcldpbmRvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gKHByZXJlbmRlcldpbmRvdyA9IGFzc2VydFNhbWVEb21haW4ocHJlcmVuZGVyV2luZG93KSkuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gcmVuZGVyVGVtcGxhdGUocHJlcmVuZGVyVGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYzogZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSBkb2MpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHByZXJlbmRlciB0ZW1wbGF0ZSB0byBoYXZlIGJlZW4gY3JlYXRlZCB3aXRoIGRvY3VtZW50IGZyb20gY2hpbGQgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24od2luLCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImh0bWxcIiAhPT0gdGFnKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGJlIGh0bWwsIGdvdCBcIiArIHRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9hcnJheUZyb20yID0gYXJyYXlGcm9tKGRvY3VtZW50RWxlbWVudC5jaGlsZHJlbik7IF9pNiA8IF9hcnJheUZyb20yLmxlbmd0aDsgX2k2KyspIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChfYXJyYXlGcm9tMltfaTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pOCA9IDAsIF9hcnJheUZyb200ID0gYXJyYXlGcm9tKGVsLmNoaWxkcmVuKTsgX2k4IDwgX2FycmF5RnJvbTQubGVuZ3RoOyBfaTgrKykgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKF9hcnJheUZyb200W19pOF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHByZXJlbmRlcldpbmRvdywgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2F1dG9SZXNpemUkd2lkdGggPSBhdXRvUmVzaXplLndpZHRoLCB3aWR0aCA9IHZvaWQgMCAhPT0gX2F1dG9SZXNpemUkd2lkdGggJiYgX2F1dG9SZXNpemUkd2lkdGgsIF9hdXRvUmVzaXplJGhlaWdodCA9IGF1dG9SZXNpemUuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgIT09IF9hdXRvUmVzaXplJGhlaWdodCAmJiBfYXV0b1Jlc2l6ZSRoZWlnaHQsIF9hdXRvUmVzaXplJGVsZW1lbnQgPSBhdXRvUmVzaXplLmVsZW1lbnQsIGVsZW1lbnQgPSB2b2lkIDAgPT09IF9hdXRvUmVzaXplJGVsZW1lbnQgPyBcImJvZHlcIiA6IF9hdXRvUmVzaXplJGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbWVudCA9IGdldEVsZW1lbnRTYWZlKGVsZW1lbnQsIGRvYykpICYmICh3aWR0aCB8fCBoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlcmVuZGVyUmVzaXplTGlzdGVuZXIgPSBvblJlc2l6ZShlbGVtZW50LCAoZnVuY3Rpb24oX3JlZjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPyBfcmVmOC53aWR0aCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBfcmVmOC5oZWlnaHQgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogcHJlcmVuZGVyV2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULlJFTkRFUkVELCBwcmVyZW5kZXJSZXNpemVMaXN0ZW5lci5jYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZW5kZXJDb250YWluZXIgPSBmdW5jdGlvbihwcm94eUNvbnRhaW5lciwgX3JlZjkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHlGcmFtZSA9IF9yZWY5LnByb3h5RnJhbWUsIHByb3h5UHJlcmVuZGVyRnJhbWUgPSBfcmVmOS5wcm94eVByZXJlbmRlckZyYW1lLCBjb250ZXh0ID0gX3JlZjkuY29udGV4dCwgdWlkID0gX3JlZjkudWlkO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJDb250YWluZXJPdmVycmlkZSA/IHJlbmRlckNvbnRhaW5lck92ZXJyaWRlKHByb3h5Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IHByb3h5RnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3h5UHJlcmVuZGVyRnJhbWU6IHByb3h5UHJlcmVuZGVyRnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgfSkgOiBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBwcm94eUNvbnRhaW5lci5nZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgZnJhbWU6IHByb3h5RnJhbWUgPyBwcm94eUZyYW1lLmdldCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyRnJhbWU6IHByb3h5UHJlcmVuZGVyRnJhbWUgPyBwcm94eVByZXJlbmRlckZyYW1lLmdldCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxTdGF0ZTogZ2V0SW50ZXJuYWxTdGF0ZSgpXG4gICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfcmVmMTAuY29udGFpbmVyLCB2aXNpYmxlID0gX3JlZjEwLmludGVybmFsU3RhdGUudmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyQ29udGFpbmVyID0gcmVuZGVyVGVtcGxhdGUoY29udGFpbmVyVGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWU6IF9yZWYxMC5mcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lOiBfcmVmMTAucHJlcmVuZGVyRnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2M6IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGUgfHwgaGlkZUVsZW1lbnQoaW5uZXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBpbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyV2F0Y2hlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gb25jZShoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYWNyaWZpY2lhbEZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYWNyaWZpY2lhbEZyYW1lV2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTggPSAwOyBfaTE4IDwgbXV0YXRpb25PYnNlcnZlcnMubGVuZ3RoOyBfaTE4KyspIG11dGF0aW9uT2JzZXJ2ZXJzW19pMThdLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgJiYgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhY3JpZmljaWFsRnJhbWVXaW4gJiYgc2FjcmlmaWNpYWxGcmFtZVdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIGVsZW1lbnRDbG9zZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWNyaWZpY2lhbEZyYW1lICYmIGRlc3Ryb3lFbGVtZW50KHNhY3JpZmljaWFsRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRDbG9zZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50Q2xvc2VkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRDbG9zZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25FbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDttdXRhdGlvbkVsZW1lbnQ7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRWxlbWVudENsb3NlZChlbGVtZW50KSAmJiBlbGVtZW50Q2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUobXV0YXRpb25FbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0OiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVycy5wdXNoKG11dGF0aW9uT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25FbGVtZW50ID0gbXV0YXRpb25FbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNhY3JpZmljaWFsRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpKS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiX19kZXRlY3RfY2xvc2VfXCIgKyB1bmlxdWVJRCgpICsgXCJfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWNyaWZpY2lhbEZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdEZyYW1lV2luZG93KHNhY3JpZmljaWFsRnJhbWUpLnRoZW4oKGZ1bmN0aW9uKGZyYW1lV2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzYWNyaWZpY2lhbEZyYW1lV2luID0gYXNzZXJ0U2FtZURvbWFpbihmcmFtZVdpbikpLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgZWxlbWVudENsb3NlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc2FjcmlmaWNpYWxGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzYWZlSW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VsZW1lbnRDbG9zZWQoZWxlbWVudCkgJiYgZWxlbWVudENsb3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oaW5uZXJDb250YWluZXIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2UobmV3IEVycm9yKFwiRGV0ZWN0ZWQgY29udGFpbmVyIGVsZW1lbnQgcmVtb3ZlZCBmcm9tIERPTVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcldhdGNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lFbGVtZW50KGlubmVyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UHJveHlDb250YWluZXIgPSBnZXRQcm94eU9iamVjdChpbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldEhlbHBlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICBmb2N1czogZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogcmVzaXplLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogdXBkYXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzZXRQcm9wcyA9IGZ1bmN0aW9uKG5ld1Byb3BzLCBpc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaXNVcGRhdGUgJiYgKGlzVXBkYXRlID0gITEpO1xuICAgICAgICAgICAgICAgIHZhciBoZWxwZXJzID0gZ2V0SGVscGVycygpO1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbihwcm9wc0RlZiwgcHJvcHMsIGlucHV0UHJvcHMsIGhlbHBlcnMsIGlzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaXNVcGRhdGUgJiYgKGlzVXBkYXRlID0gITEpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocHJvcHMsIGlucHV0UHJvcHMgPSBpbnB1dFByb3BzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lcyA9IGlzVXBkYXRlID8gW10gOiBbXS5jb25jYXQoT2JqZWN0LmtleXMocHJvcHNEZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKGlucHV0UHJvcHMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXMyW19pMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gcHJvcE5hbWVzLmluZGV4T2Yoa2V5KSAmJiBwcm9wTmFtZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGlhc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhlbHBlcnMuc3RhdGUsIGNsb3NlID0gaGVscGVycy5jbG9zZSwgZm9jdXMgPSBoZWxwZXJzLmZvY3VzLCBldmVudCA9IGhlbHBlcnMuZXZlbnQsIG9uRXJyb3IgPSBoZWxwZXJzLm9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHByb3BOYW1lcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleSA9IHByb3BOYW1lc1tfaTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BEZWYgPSBwcm9wc0RlZltfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0UHJvcHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcERlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGlhcyA9IHByb3BEZWYuYWxpYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc0RlZmluZWQodmFsdWUpICYmIGlzRGVmaW5lZChpbnB1dFByb3BzW2FsaWFzXSkgJiYgKHZhbHVlID0gaW5wdXRQcm9wc1thbGlhc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzLnB1c2goYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wRGVmLnZhbHVlICYmICh2YWx1ZSA9IHByb3BEZWYudmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1czogZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNEZWZpbmVkKHZhbHVlKSAmJiBwcm9wRGVmLmRlZmF1bHQgJiYgKHZhbHVlID0gcHJvcERlZi5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgKFwiYXJyYXlcIiA9PT0gcHJvcERlZi50eXBlID8gIUFycmF5LmlzQXJyYXkodmFsdWUpIDogdHlwZW9mIHZhbHVlICE9PSBwcm9wRGVmLnR5cGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcCBpcyBub3Qgb2YgdHlwZSBcIiArIHByb3BEZWYudHlwZSArIFwiOiBcIiArIF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW19rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgYWxpYXNlcy5sZW5ndGg7IF9pNisrKSBkZWxldGUgcHJvcHNbYWxpYXNlc1tfaTZdXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX09iamVjdCRrZXlzNCA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2k4IDwgX09iamVjdCRrZXlzNC5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleTIgPSBfT2JqZWN0JGtleXM0W19pOF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Byb3BEZWYgPSBwcm9wc0RlZltfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3ZhbHVlID0gcHJvcHNbX2tleTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Byb3BEZWYgJiYgaXNEZWZpbmVkKF92YWx1ZSkgJiYgX3Byb3BEZWYuZGVjb3JhdGUgJiYgKHByb3BzW19rZXkyXSA9IF9wcm9wRGVmLmRlY29yYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfT2JqZWN0JGtleXM2ID0gT2JqZWN0LmtleXMocHJvcHNEZWYpOyBfaTEwIDwgX09iamVjdCRrZXlzNi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9rZXkzID0gX09iamVjdCRrZXlzNltfaTEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gcHJvcHNEZWZbX2tleTNdLnJlcXVpcmVkICYmICFpc0RlZmluZWQocHJvcHNbX2tleTNdKSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcm9wIFwiJyArIF9rZXkzICsgJ1wiIHRvIGJlIGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0ocHJvcHNEZWYsIHByb3BzLCBuZXdQcm9wcywgaGVscGVycywgaXNVcGRhdGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVQcm9wcyA9IGZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgc2V0UHJvcHMobmV3UHJvcHMsICEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2UudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHlXaW4gPSBjdXJyZW50UHJveHlXaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCAmJiBwcm94eVdpbikgcmV0dXJuIGdldFByb3BzRm9yQ2hpbGQoZ2V0RG9tYWluTWF0Y2hlcigpKS50aGVuKChmdW5jdGlvbihjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQudXBkYXRlUHJvcHMoY2hpbGRQcm9wcykuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1dpbmRvd0Nsb3NlKHByb3h5V2luKS50aGVuKChmdW5jdGlvbihjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUkVOREVSLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9uUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vbihFVkVOVC5ESVNQTEFZLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9uRGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUkVOREVSRUQsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25SZW5kZXJlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuQ0xPU0UsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuREVTVFJPWSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vbkRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULlJFU0laRSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuRk9DVVMsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25Gb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUFJPUFMsIChmdW5jdGlvbihuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vblByb3BzKG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULkVSUk9SLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzICYmIHByb3BzLm9uRXJyb3IgPyBwcm9wcy5vbkVycm9yKGVycikgOiBpbml0UHJvbWlzZS5yZWplY3QoZXJyKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcihldmVudC5yZXNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24odGFyZ2V0LCBjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gXCJ6b2lkLVwiICsgdGFnICsgXCItXCIgKyB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbk1hdGNoZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZERvbWFpbiA9IGdldENoaWxkRG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24odGFyZ2V0LCBkb21haW4sIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVRvcFdpbmRvdyh3aW5kb3csIHRhcmdldCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IHJlbmRlclRvIGFuIGFkamFjZW50IGZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oZG9tYWluLCBvcmlnaW4pICYmICFpc1NhbWVEb21haW4odGFyZ2V0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZW5kZXIgcmVtb3RlbHkgdG8gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIC0gY2FuIG9ubHkgcmVuZGVyIHRvIFwiICsgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBjb250YWluZXIpIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBwYXNzZWQgdG8gcmVuZGVyVG8gbXVzdCBiZSBhIHN0cmluZyBzZWxlY3RvciwgZ290IFwiICsgdHlwZW9mIGNvbnRhaW5lciArIFwiIH1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSh0YXJnZXQsIGRvbWFpbiwgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHdpbmRvdykgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHQsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGVQcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfT2JqZWN0JGtleXM0ID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaTQgPCBfT2JqZWN0JGtleXM0Lmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IF9PYmplY3Qka2V5czRbX2k0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVmID0gcHJvcHNEZWZbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcERlZiAmJiBwcm9wRGVmLmFsbG93RGVsZWdhdGUgJiYgKGRlbGVnYXRlUHJvcHNbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRPdmVycmlkZXNQcm9taXNlID0gc2VuZF9zZW5kKHRhcmdldCwgXCJ6b2lkX2RlbGVnYXRlX1wiICsgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGRlbGVnYXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEludGVybmFsU3RhdGU6IGdldEludGVybmFsU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZTogc2V0SW50ZXJuYWxTdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb21wID0gX3JlZjExLmRhdGEucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQodGFyZ2V0KSkgcmV0dXJuIHBhcmVudENvbXAuZGVzdHJveShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudENvbXAuZ2V0RGVsZWdhdGVPdmVycmlkZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWxlZ2F0ZSByZW5kZXJpbmcuIFBvc3NpYmx5IHRoZSBjb21wb25lbnQgaXMgbm90IGxvYWRlZCBpbiB0aGUgdGFyZ2V0IHdpbmRvdy5cXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3h5Q29udGFpbmVyT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXMuZ2V0UHJveHlDb250YWluZXIuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb250YWluZXJPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLnJlbmRlckNvbnRhaW5lci5hcHBseShjaGlsZE92ZXJyaWRlcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLnNob3cuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZS50aGVuKChmdW5jdGlvbihjaGlsZE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlcy5oaWRlLmFwcGx5KGNoaWxkT3ZlcnJpZGVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JVbmxvYWRPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLndhdGNoRm9yVW5sb2FkLmFwcGx5KGNoaWxkT3ZlcnJpZGVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IENPTlRFWFQuSUZSQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQcm94eVdpbmRvd092ZXJyaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZS50aGVuKChmdW5jdGlvbihjaGlsZE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXMuZ2V0UHJveHlXaW5kb3cuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuRnJhbWVPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLm9wZW5GcmFtZS5hcHBseShjaGlsZE92ZXJyaWRlcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5QcmVyZW5kZXJGcmFtZU92ZXJyaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZS50aGVuKChmdW5jdGlvbihjaGlsZE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXMub3BlblByZXJlbmRlckZyYW1lLmFwcGx5KGNoaWxkT3ZlcnJpZGVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlcy5wcmVyZW5kZXIuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIGFyZ3NbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLm9wZW4uYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuUHJlcmVuZGVyT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIGFyZ3NbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLm9wZW5QcmVyZW5kZXIuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGNvbnRleHQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93UHJvcCA9IHByb3BzLndpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YXRjaEZvclVubG9hZFByb21pc2UgPSB3YXRjaEZvclVubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkVXJsUHJvbWlzZSA9IGZ1bmN0aW9uKHByb3BzRGVmLCBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKGtleXMubWFwKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCkgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgcHJvcC5xdWVyeVBhcmFtKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyBwcm9wc19nZXRRdWVyeVBhcmFtKHByb3AsIGtleSwgdmFsdWUpLCBnZXRRdWVyeVZhbHVlKHByb3AsIDAsIHZhbHVlKSBdKS50aGVuKChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW0gPSBfcmVmWzBdLCBxdWVyeVZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgcXVlcnlWYWx1ZSkgcmVzdWx0ID0gcXVlcnlWYWx1ZS50b1N0cmluZygpOyBlbHNlIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBxdWVyeVZhbHVlKSByZXN1bHQgPSBxdWVyeVZhbHVlLnRvU3RyaW5nKCk7IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHF1ZXJ5VmFsdWUgJiYgbnVsbCAhPT0gcXVlcnlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5zZXJpYWxpemF0aW9uID09PSBQUk9QX1NFUklBTElaQVRJT04uSlNPTikgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocXVlcnlWYWx1ZSk7IGVsc2UgaWYgKHByb3Auc2VyaWFsaXphdGlvbiA9PT0gUFJPUF9TRVJJQUxJWkFUSU9OLkJBU0U2NCkgcmVzdWx0ID0gYnRvYShKU09OLnN0cmluZ2lmeShxdWVyeVZhbHVlKSk7IGVsc2UgaWYgKHByb3Auc2VyaWFsaXphdGlvbiA9PT0gUFJPUF9TRVJJQUxJWkFUSU9OLkRPVElGWSB8fCAhcHJvcC5zZXJpYWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbiBkb3RpZnkob2JqLCBwcmVmaXgsIG5ld29iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJlZml4ICYmIChwcmVmaXggPSBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG5ld29iaiAmJiAobmV3b2JqID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCA/IHByZWZpeCArIFwiLlwiIDogcHJlZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG51bGwgIT0gb2JqW2tleV0gJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvYmpba2V5XSAmJiAob2JqW2tleV0gJiYgQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgb2JqW2tleV0ubGVuZ3RoICYmIG9ialtrZXldLmV2ZXJ5KChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgPyBuZXdvYmpbXCJcIiArIHByZWZpeCArIGtleSArIFwiW11cIl0gPSBvYmpba2V5XS5qb2luKFwiLFwiKSA6IG9ialtrZXldICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG9ialtrZXldID8gbmV3b2JqID0gZG90aWZ5KG9ialtrZXldLCBcIlwiICsgcHJlZml4ICsga2V5LCBuZXdvYmopIDogbmV3b2JqW1wiXCIgKyBwcmVmaXggKyBrZXldID0gb2JqW2tleV0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld29iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0ocXVlcnlWYWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfT2JqZWN0JGtleXM4ID0gT2JqZWN0LmtleXMocmVzdWx0KTsgX2kxMiA8IF9PYmplY3Qka2V5czgubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90a2V5ID0gX09iamVjdCRrZXlzOFtfaTEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZG90a2V5XSA9IHJlc3VsdFtkb3RrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIFwibnVtYmVyXCIgPT0gdHlwZW9mIHF1ZXJ5VmFsdWUgJiYgKHJlc3VsdCA9IHF1ZXJ5VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3F1ZXJ5UGFyYW1dID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByb3BzRGVmLCBwcm9wcykudGhlbigoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IG9wdGlvbnMucXVlcnkgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gb3B0aW9ucy5oYXNoIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdXJsJHNwbGl0ID0gdXJsLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIYXNoID0gX3VybCRzcGxpdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vcmlnaW5hbFVybCRzcGxpdCA9IChvcmlnaW5hbFVybCA9IF91cmwkc3BsaXRbMF0pLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxVcmwgPSBfb3JpZ2luYWxVcmwkc3BsaXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IGV4dGVuZFF1ZXJ5KF9vcmlnaW5hbFVybCRzcGxpdFsxXSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaFN0cmluZyA9IGV4dGVuZFF1ZXJ5KG9yaWdpbmFsSGFzaCwgaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nICYmIChvcmlnaW5hbFVybCA9IG9yaWdpbmFsVXJsICsgXCI/XCIgKyBxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdHJpbmcgJiYgKG9yaWdpbmFsVXJsID0gb3JpZ2luYWxVcmwgKyBcIiNcIiArIGhhc2hTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZG9tYWluID0gZ2V0RG9tYWluRnJvbVVybCh1cmwpLCAwID09PSBkb21haW4uaW5kZXhPZihcIm1vY2s6XCIpKSkgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9jayB1cmxzIG5vdCBzdXBwb3J0ZWQgb3V0IG9mIHRlc3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGdldFVybCgpKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvblJlbmRlclByb21pc2UgPSBldmVudC50cmlnZ2VyKEVWRU5ULlJFTkRFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UHJveHlDb250YWluZXJQcm9taXNlID0gZ2V0UHJveHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRQcm94eVdpbmRvd1Byb21pc2UgPSBnZXRQcm94eVdpbmRvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkV2luZG93TmFtZVByb21pc2UgPSBnZXRQcm94eVdpbmRvd1Byb21pc2UudGhlbigoZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gdm9pZCAwID09PSBfdGVtcCA/IHt9IDogX3RlbXAsIHByb3h5V2luID0gX3JlZjQucHJveHlXaW4sIGNoaWxkRG9tYWluID0gX3JlZjQuY2hpbGREb21haW4sIGRvbWFpbiA9IF9yZWY0LmRvbWFpbiwgY29udGV4dCA9ICh2b2lkIDAgPT09IF9yZWY0LnRhcmdldCAmJiB3aW5kb3csIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNC5jb250ZXh0KSwgdWlkID0gX3JlZjQudWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJveHlXaW4sIGNoaWxkRG9tYWluLCBkb21haW4sIHVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3BzRm9yQ2hpbGQoZG9tYWluKS50aGVuKChmdW5jdGlvbihjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2V0dXBfc2VyaWFsaXplTWVzc2FnZShwcm94eVdpbiwgZG9tYWluLCBjaGlsZFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcFJlZiA9IGNoaWxkRG9tYWluID09PSBnZXREb21haW4oKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJhd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInVpZFwiID09PSBwcm9wUmVmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdsb2JhbCA9IGxpYl9nbG9iYWxfZ2V0R2xvYmFsKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5wcm9wcyA9IGdsb2JhbC5wcm9wcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLnByb3BzW3VpZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbC5wcm9wc1t1aWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHByb3h5V2luLCBjaGlsZERvbWFpbiwgZG9tYWluLCB1aWQpLnRoZW4oKGZ1bmN0aW9uKHByb3BzUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCI5XzBfNjNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERvbWFpbjogY2hpbGREb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RG9tYWluOiBnZXREb21haW4od2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdldFdpbmRvd1JlZigwLCBjaGlsZERvbWFpbiwgdWlkLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogc2V0dXBfc2VyaWFsaXplTWVzc2FnZShwcm94eVdpbiwgZG9tYWluLCAod2luID0gcHJveHlXaW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogaW5pdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrV2luZG93Q2xvc2Uod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiAoX3JlZjUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogcHJveHlXaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERvbWFpbjogY2hpbGREb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb3h5V2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERvbWFpbjogX3JlZjUuY2hpbGREb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX3JlZjUuZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IF9yZWY1LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3JlZjUuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBfcmVmNS51aWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihjaGlsZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX196b2lkX19cIiArIG5hbWUgKyBcIl9fXCIgKyBiYXNlNjRlbmNvZGUoSlNPTi5zdHJpbmdpZnkoY2hpbGRQYXlsb2FkKSkgKyBcIl9fXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuRnJhbWVQcm9taXNlID0gYnVpbGRXaW5kb3dOYW1lUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW5kb3dOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5GcmFtZShjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IHdpbmRvd05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuUHJlcmVuZGVyRnJhbWVQcm9taXNlID0gb3BlblByZXJlbmRlckZyYW1lKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlckNvbnRhaW5lclByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUNvbnRhaW5lcjogZ2V0UHJveHlDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IG9wZW5GcmFtZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlQcmVyZW5kZXJGcmFtZTogb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckNvbnRhaW5lcihfcmVmMTIucHJveHlDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IF9yZWYxMi5wcm94eUZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVByZXJlbmRlckZyYW1lOiBfcmVmMTIucHJveHlQcmVyZW5kZXJGcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHByb3h5Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5Qcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93TmFtZTogYnVpbGRXaW5kb3dOYW1lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUZyYW1lOiBvcGVuRnJhbWVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiBnZXRQcm94eVdpbmRvd1Byb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWYxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm94eVdpbiA9IF9yZWYxMy5wcm94eVdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93UHJvcCA/IHByb3h5V2luIDogb3Blbihjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IF9yZWYxMy53aW5kb3dOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogcHJveHlXaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IF9yZWYxMy5wcm94eUZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblByZXJlbmRlclByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogb3BlblByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlQcmVyZW5kZXJGcmFtZTogb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjE0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5QcmVyZW5kZXIoY29udGV4dCwgX3JlZjE0LnByb3h5V2luLCBfcmVmMTQucHJveHlQcmVyZW5kZXJGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0U3RhdGVQcm9taXNlID0gb3BlblByb21pc2UudGhlbigoZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJveHlXaW4gPSBwcm94eVdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJveHlXaW4ocHJveHlXaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXJlbmRlclByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVByZXJlbmRlcldpbjogb3BlblByZXJlbmRlclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHNldFN0YXRlUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjE1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXJlbmRlcihfcmVmMTUucHJveHlQcmVyZW5kZXJXaW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRXaW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiBvcGVuUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lOiBidWlsZFdpbmRvd05hbWVQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93UHJvcCkgcmV0dXJuIF9yZWYxNi5wcm94eVdpbi5zZXROYW1lKF9yZWYxNi53aW5kb3dOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2FkVXJsUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiBvcGVuUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsdFVybDogYnVpbGRVcmxQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IHNldFdpbmRvd05hbWVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcjogcHJlcmVuZGVyUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjE3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYxNy5wcm94eVdpbi5zZXRMb2NhdGlvbihfcmVmMTcuYnVpbHRVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhdGNoRm9yQ2xvc2VQcm9taXNlID0gb3BlblByb21pc2UudGhlbigoZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gd2F0Y2hGb3JDbG9zZShwcm94eVdpbiwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5kZWxheSgyZTMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5V2luLmlzQ2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihpc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQ2xvc2VkID8gY2xvc2UobmV3IEVycm9yKFwiRGV0ZWN0ZWQgXCIgKyBjb250ZXh0ICsgXCIgY2xvc2VcIikpIDogY2FuY2VsbGVkID8gdm9pZCAwIDogd2F0Y2hGb3JDbG9zZShwcm94eVdpbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHByb3h5V2luLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkRpc3BsYXlQcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiByZW5kZXJDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcjogcHJlcmVuZGVyUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRyaWdnZXIoRVZFTlQuRElTUExBWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbkJyaWRnZVByb21pc2UgPSBvcGVuUHJvbWlzZS50aGVuKChmdW5jdGlvbihwcm94eVdpbikge30pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5UaW1lb3V0UHJvbWlzZSA9IGxvYWRVcmxQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHByb3BzLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSByZXR1cm4gaW5pdFByb21pc2UudGltZW91dCh0aW1lb3V0LCBuZXcgRXJyb3IoXCJMb2FkaW5nIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCIgbWlsbGlzZWNvbmRzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25SZW5kZXJlZFByb21pc2UgPSBpbml0UHJvbWlzZS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHJpZ2dlcihFVkVOVC5SRU5ERVJFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2U6IGluaXRQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkVXJsUHJvbWlzZTogYnVpbGRVcmxQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyUHJvbWlzZTogb25SZW5kZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3h5Q29udGFpbmVyUHJvbWlzZTogZ2V0UHJveHlDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5GcmFtZVByb21pc2U6IG9wZW5GcmFtZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZTogb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb250YWluZXJQcm9taXNlOiByZW5kZXJDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9taXNlOiBvcGVuUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuUHJlcmVuZGVyUHJvbWlzZTogb3BlblByZXJlbmRlclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGVQcm9taXNlOiBzZXRTdGF0ZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyUHJvbWlzZTogcHJlcmVuZGVyUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVXJsUHJvbWlzZTogbG9hZFVybFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRXaW5kb3dOYW1lUHJvbWlzZTogYnVpbGRXaW5kb3dOYW1lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRXaW5kb3dOYW1lUHJvbWlzZTogc2V0V2luZG93TmFtZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JDbG9zZVByb21pc2U6IHdhdGNoRm9yQ2xvc2VQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheVByb21pc2U6IG9uRGlzcGxheVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkJyaWRnZVByb21pc2U6IG9wZW5CcmlkZ2VQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1blRpbWVvdXRQcm9taXNlOiBydW5UaW1lb3V0UHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlbmRlcmVkUHJvbWlzZTogb25SZW5kZXJlZFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVQcm9taXNlOiBkZWxlZ2F0ZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JVbmxvYWRQcm9taXNlOiB3YXRjaEZvclVubG9hZFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIG9uRXJyb3IoZXJyKSwgZGVzdHJveShlcnIpIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgc2V0UHJvcHM6IHNldFByb3BzLFxuICAgICAgICAgICAgICAgIGdldEhlbHBlcnM6IGdldEhlbHBlcnMsXG4gICAgICAgICAgICAgICAgZ2V0RGVsZWdhdGVPdmVycmlkZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UHJveHlDb250YWluZXI6IGdldFByb3h5Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogaGlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb250YWluZXI6IHJlbmRlckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQcm94eVdpbmRvdzogZ2V0UHJveHlXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JVbmxvYWQ6IHdhdGNoRm9yVW5sb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5GcmFtZTogb3BlbkZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5QcmVyZW5kZXJGcmFtZTogb3BlblByZXJlbmRlckZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcjogcHJlcmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblByZXJlbmRlcjogb3BlblByZXJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm94eVdpbjogc2V0UHJveHlXaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWFjdCA9IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YWcsIHByb3BzRGVmLCBpbml0LCBfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIFJlYWN0ID0gX3JlZi5SZWFjdCwgUmVhY3RET00gPSBfcmVmLlJlYWN0RE9NO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9pbmhlcml0c0xvb3NlKF9jbGFzcywgX1JlYWN0JENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgX3Byb3RvID0gX2NsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5pdChleHRlbmQoe30sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW5kZXIoZWwsIENPTlRFWFQuSUZSQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLnBhcmVudCAmJiB0aGlzLnN0YXRlLnBhcmVudC51cGRhdGVQcm9wcyhleHRlbmQoe30sIHRoaXMucHJvcHMpKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jbGFzcztcbiAgICAgICAgICAgICAgICB9KFJlYWN0LkNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2dWUgPSB7XG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24odGFnLCBwcm9wc0RlZiwgaW5pdCwgVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5jb21wb25lbnQodGFnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3JlYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRBdHRyczogITEsXG4gICAgICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy4kZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IGluaXQoX2V4dGVuZHMoe30sIHRoaXMuJGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yZW5kZXIoZWwsIENPTlRFWFQuSUZSQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLiRhdHRycyAmJiB0aGlzLnBhcmVudC51cGRhdGVQcm9wcyhfZXh0ZW5kcyh7fSwgdGhpcy4kYXR0cnMpKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXA6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFuZ3VsYXIgPSB7XG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24odGFnLCBwcm9wc0RlZiwgaW5pdCwgbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmcubW9kdWxlKHRhZywgW10pLmRpcmVjdGl2ZSh0YWcucmVwbGFjZSgvLShbYS16XSkvZywgKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KSksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9PYmplY3Qka2V5czIgPSBPYmplY3Qua2V5cyhwcm9wc0RlZik7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykgc2NvcGVbX09iamVjdCRrZXlzMltfaTJdXSA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5wcm9wcyA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogWyBcIiRzY29wZVwiLCBcIiRlbGVtZW50XCIsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzYWZlQXBwbHkoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIiRhcHBseVwiICE9PSAkc2NvcGUuJHJvb3QuJCRwaGFzZSAmJiBcIiRkaWdlc3RcIiAhPT0gJHNjb3BlLiRyb290LiQkcGhhc2UpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlT2JqZWN0KCRzY29wZS5wcm9wcywgKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVBcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5pdChnZXRQcm9wcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoJGVsZW1lbnRbMF0sIENPTlRFWFQuSUZSQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlUHJvcHMoZ2V0UHJvcHMoKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYW5ndWxhcjIgPSB7XG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24odGFnLCBwcm9wc0RlZiwgaW5pdCwgX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBOZ01vZHVsZSA9IF9yZWYuTmdNb2R1bGUsIEVsZW1lbnRSZWYgPSBfcmVmLkVsZW1lbnRSZWYsIE5nWm9uZSA9IF9yZWYuTmdab25lO1xuICAgICAgICAgICAgICAgIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU9iamVjdChfZXh0ZW5kcyh7fSwgY29tcG9uZW50LmludGVybmFsUHJvcHMsIGNvbXBvbmVudC5wcm9wcyksIChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnpvbmUucnVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50SW5zdGFuY2UgPSAoMCwgX3JlZi5Db21wb25lbnQpKHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbIFwicHJvcHNcIiBdXG4gICAgICAgICAgICAgICAgfSkuQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogWyBFbGVtZW50UmVmLCBOZ1pvbmUsIGZ1bmN0aW9uKGVsZW1lbnRSZWYsIHpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBpbml0KGdldFByb3BzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbmRlcih0YXJnZXRFbGVtZW50LCBDT05URVhULklGUkFNRSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG5nRG9DaGVjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgIWZ1bmN0aW9uKG9iajEsIG9iajIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmoxKSBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRba2V5XSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBvYmoyKSBpZiAoIWNoZWNrZWRbX2tleV0pIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHRoaXMuX3Byb3BzLCB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZVByb3BzKGdldFByb3BzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBOZ01vZHVsZSh7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogWyBDb21wb25lbnRJbnN0YW5jZSBdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbIENvbXBvbmVudEluc3RhbmNlIF1cbiAgICAgICAgICAgICAgICB9KS5DbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXJUZW1wbGF0ZShfcmVmKSB7XG4gICAgICAgICAgICB2YXIgdWlkID0gX3JlZi51aWQsIGZyYW1lID0gX3JlZi5mcmFtZSwgcHJlcmVuZGVyRnJhbWUgPSBfcmVmLnByZXJlbmRlckZyYW1lLCBkb2MgPSBfcmVmLmRvYywgcHJvcHMgPSBfcmVmLnByb3BzLCBldmVudCA9IF9yZWYuZXZlbnQsIF9yZWYkZGltZW5zaW9ucyA9IF9yZWYuZGltZW5zaW9ucywgd2lkdGggPSBfcmVmJGRpbWVuc2lvbnMud2lkdGgsIGhlaWdodCA9IF9yZWYkZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZnJhbWUgJiYgcHJlcmVuZGVyRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHVpZCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgICAgICBwcm9wcy5jc3BOb25jZSAmJiBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBwcm9wcy5jc3BOb25jZSk7XG4gICAgICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgI1wiICsgdWlkICsgXCIge1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiICsgd2lkdGggKyBcIjtcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIGhlaWdodCArIFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAjXCIgKyB1aWQgKyBcIiA+IGlmcmFtZSB7XFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjJzIGVhc2UtaW4tb3V0O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAjXCIgKyB1aWQgKyBcIiA+IGlmcmFtZS56b2lkLWludmlzaWJsZSB7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICNcIiArIHVpZCArIFwiID4gaWZyYW1lLnpvaWQtdmlzaWJsZSB7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgICB9XFxuICAgICAgICBcIikpO1xuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHByZXJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lLmNsYXNzTGlzdC5hZGQoXCJ6b2lkLXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgZnJhbWUuY2xhc3NMaXN0LmFkZChcInpvaWQtaW52aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULlJFTkRFUkVELCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lLmNsYXNzTGlzdC5yZW1vdmUoXCJ6b2lkLXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lLmNsYXNzTGlzdC5hZGQoXCJ6b2lkLWludmlzaWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuY2xhc3NMaXN0LnJlbW92ZShcInpvaWQtaW52aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5jbGFzc0xpc3QuYWRkKFwiem9pZC12aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lFbGVtZW50KHByZXJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBldmVudC5vbihFVkVOVC5SRVNJWkUsIChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBfcmVmMi53aWR0aCwgbmV3SGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09IHR5cGVvZiBuZXdXaWR0aCAmJiAoZGl2LnN0eWxlLndpZHRoID0gdG9DU1MobmV3V2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgbmV3SGVpZ2h0ICYmIChkaXYuc3R5bGUuaGVpZ2h0ID0gdG9DU1MobmV3SGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFByZXJlbmRlclRlbXBsYXRlKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBfcmVmLmRvYywgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgICAgICB2YXIgc3Bpbm5lciA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc3Bpbm5lci5jbGFzc0xpc3QuYWRkKFwic3Bpbm5lclwiKTtcbiAgICAgICAgICAgIHByb3BzLmNzcE5vbmNlICYmIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHByb3BzLmNzcE5vbmNlKTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoYm9keSk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHNwaW5uZXIpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBodG1sLCBib2R5IHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLnNwaW5uZXIge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgICAgICAgICAgIG1heC1oZWlnaHQ6IDYwdm1pbjtcXG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA2MHZtaW47XFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDBweDtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQwcHg7XFxuICAgICAgICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICAgICAgICBsZWZ0OiA1MCU7XFxuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHJnYmEoMCwgMCwgMCwgLjIpO1xcbiAgICAgICAgICAgICAgICBib3JkZXItdG9wLWNvbG9yOiByZ2JhKDMzLCAxMjgsIDE5MiwgMC44KTtcXG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiByb3RhdGlvbiAuN3MgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBAa2V5ZnJhbWVzIHJvdGF0aW9uIHtcXG4gICAgICAgICAgICAgICAgZnJvbSB7XFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdG8ge1xcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDM1OWRlZyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICBcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzX2RlZmF1bHROb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjX3V0aWxfbm9vcDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb3BzX2RlY29yYXRlT25jZSA9IGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBvbmNlKF9yZWYudmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xlYW5JbnN0YW5jZXMgPSBjbGVhbnVwKCk7XG4gICAgICAgIHZhciBjbGVhblpvaWQgPSBjbGVhbnVwKCk7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvbmVudF9jb21wb25lbnQob3B0cykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMudGFnLCB1cmwgPSBvcHRpb25zLnVybCwgZG9tYWluID0gb3B0aW9ucy5kb21haW4sIGJyaWRnZVVybCA9IG9wdGlvbnMuYnJpZGdlVXJsLCBfb3B0aW9ucyRwcm9wcyA9IG9wdGlvbnMucHJvcHMsIHByb3BzRGVmID0gdm9pZCAwID09PSBfb3B0aW9ucyRwcm9wcyA/IHt9IDogX29wdGlvbnMkcHJvcHMsIF9vcHRpb25zJGRpbWVuc2lvbnMgPSBvcHRpb25zLmRpbWVuc2lvbnMsIGRpbWVuc2lvbnMgPSB2b2lkIDAgPT09IF9vcHRpb25zJGRpbWVuc2lvbnMgPyB7fSA6IF9vcHRpb25zJGRpbWVuc2lvbnMsIF9vcHRpb25zJGF1dG9SZXNpemUgPSBvcHRpb25zLmF1dG9SZXNpemUsIGF1dG9SZXNpemUgPSB2b2lkIDAgPT09IF9vcHRpb25zJGF1dG9SZXNpemUgPyB7fSA6IF9vcHRpb25zJGF1dG9SZXNpemUsIF9vcHRpb25zJGFsbG93ZWRQYXJlbiA9IG9wdGlvbnMuYWxsb3dlZFBhcmVudERvbWFpbnMsIGFsbG93ZWRQYXJlbnREb21haW5zID0gdm9pZCAwID09PSBfb3B0aW9ucyRhbGxvd2VkUGFyZW4gPyBcIipcIiA6IF9vcHRpb25zJGFsbG93ZWRQYXJlbiwgX29wdGlvbnMkYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcywgYXR0cmlidXRlcyA9IHZvaWQgMCA9PT0gX29wdGlvbnMkYXR0cmlidXRlcyA/IHt9IDogX29wdGlvbnMkYXR0cmlidXRlcywgX29wdGlvbnMkZGVmYXVsdENvbnRlID0gb3B0aW9ucy5kZWZhdWx0Q29udGV4dCwgZGVmYXVsdENvbnRleHQgPSB2b2lkIDAgPT09IF9vcHRpb25zJGRlZmF1bHRDb250ZSA/IENPTlRFWFQuSUZSQU1FIDogX29wdGlvbnMkZGVmYXVsdENvbnRlLCBfb3B0aW9ucyRjb250YWluZXJUZW0gPSBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlLCBjb250YWluZXJUZW1wbGF0ZSA9IHZvaWQgMCA9PT0gX29wdGlvbnMkY29udGFpbmVyVGVtID8gZGVmYXVsdENvbnRhaW5lclRlbXBsYXRlIDogX29wdGlvbnMkY29udGFpbmVyVGVtLCBfb3B0aW9ucyRwcmVyZW5kZXJUZW0gPSBvcHRpb25zLnByZXJlbmRlclRlbXBsYXRlLCBwcmVyZW5kZXJUZW1wbGF0ZSA9IHZvaWQgMCA9PT0gX29wdGlvbnMkcHJlcmVuZGVyVGVtID8gZGVmYXVsdFByZXJlbmRlclRlbXBsYXRlIDogX29wdGlvbnMkcHJlcmVuZGVyVGVtLCB2YWxpZGF0ZSA9IG9wdGlvbnMudmFsaWRhdGUsIF9vcHRpb25zJGVsaWdpYmxlID0gb3B0aW9ucy5lbGlnaWJsZSwgZWxpZ2libGUgPSB2b2lkIDAgPT09IF9vcHRpb25zJGVsaWdpYmxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGlnaWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IDogX29wdGlvbnMkZWxpZ2libGUsIF9vcHRpb25zJGxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyLCBsb2dnZXIgPSB2b2lkIDAgPT09IF9vcHRpb25zJGxvZ2dlciA/IHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogc3JjX3V0aWxfbm9vcFxuICAgICAgICAgICAgICAgIH0gOiBfb3B0aW9ucyRsb2dnZXI7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0YWcucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgdmFyIF9kaW1lbnNpb25zJHdpZHRoID0gZGltZW5zaW9ucy53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9kaW1lbnNpb25zJHdpZHRoID8gXCIzMDBweFwiIDogX2RpbWVuc2lvbnMkd2lkdGgsIF9kaW1lbnNpb25zJGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9kaW1lbnNpb25zJGhlaWdodCA/IFwiMTUwcHhcIiA6IF9kaW1lbnNpb25zJGhlaWdodDtcbiAgICAgICAgICAgICAgICBwcm9wc0RlZiA9IF9leHRlbmRzKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93RGVsZWdhdGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1dpbmRvdyh2YWx1ZSkgJiYgIXdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgV2luZG93IG9yIFByb3h5V2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvdyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVEb21haW4odmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgbm90IHNhbWUgZG9tYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBfdG9Qcm94eVdpbmRvdyhfcmVmMy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRGVjb3JhdGU6IGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmNsb3NlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjUuZm9jdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjYucmVzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERlY29yYXRlOiBmdW5jdGlvbihfcmVmNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy51aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNzcE5vbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFBhcmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjguZ2V0UGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRQYXJlbnREb21haW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRGVjb3JhdGU6IGZ1bmN0aW9uKF9yZWY5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY5LmdldFBhcmVudERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYxMC5zaG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERlY29yYXRlOiBmdW5jdGlvbihfcmVmMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjExLmhpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dEZWxlZ2F0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlOiBwcm9wc19kZWNvcmF0ZU9uY2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZW5kZXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcHJvcHNfZGVmYXVsdE5vb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZTogcHJvcHNfZGVjb3JhdGVPbmNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlOiBwcm9wc19kZWNvcmF0ZU9uY2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dEZWxlZ2F0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlOiBwcm9wc19kZWNvcmF0ZU9uY2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZXN0cm95OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0RlbGVnYXRlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHByb3BzX2RlZmF1bHROb29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGU6IHByb3BzX2RlY29yYXRlT25jZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblJlc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dEZWxlZ2F0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0RlbGVnYXRlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHByb3BzX2RlZmF1bHROb29wXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRGVjb3JhdGU6IGZ1bmN0aW9uKF9yZWYxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMTIub25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcHJvcHNfZGVmYXVsdE5vb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERlY29yYXRlOiBmdW5jdGlvbihfcmVmMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjEzLm9uUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBwcm9wc0RlZik7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJUZW1wbGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIHRlbXBsYXRlIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZVVybDogYnJpZGdlVXJsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wc0RlZjogcHJvcHNEZWYsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF1dG9SZXNpemU6IGF1dG9SZXNpemUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRQYXJlbnREb21haW5zOiBhbGxvd2VkUGFyZW50RG9tYWlucyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENvbnRleHQ6IGRlZmF1bHRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJUZW1wbGF0ZTogY29udGFpbmVyVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlclRlbXBsYXRlOiBwcmVyZW5kZXJUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IGxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgZWxpZ2libGU6IGVsaWdpYmxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0ob3B0cyk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSwgdGFnID0gb3B0aW9ucy50YWcsIGRlZmF1bHRDb250ZXh0ID0gb3B0aW9ucy5kZWZhdWx0Q29udGV4dCwgcHJvcHNEZWYgPSBvcHRpb25zLnByb3BzRGVmLCBlbGlnaWJsZSA9IG9wdGlvbnMuZWxpZ2libGU7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsID0gbGliX2dsb2JhbF9nZXRHbG9iYWwoKTtcbiAgICAgICAgICAgIHZhciBkcml2ZXJDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGlzQ2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGdldENoaWxkUGF5bG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHBheWxvYWQgJiYgcGF5bG9hZC50YWcgPT09IHRhZyAmJiBwYXlsb2FkLmNoaWxkRG9tYWluID09PSBnZXREb21haW4oKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyQ2hpbGQgPSBtZW1vaXplKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cueHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsLmNvbXBvbmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVnaXN0ZXIgXCIgKyBuYW1lICsgXCIgYXMgY2hpbGQgLSBjaGlsZCBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzRGVmID0gb3B0aW9ucy5wcm9wc0RlZiwgYXV0b1Jlc2l6ZSA9IG9wdGlvbnMuYXV0b1Jlc2l6ZSwgYWxsb3dlZFBhcmVudERvbWFpbnMgPSBvcHRpb25zLmFsbG93ZWRQYXJlbnREb21haW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uUHJvcEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQYXlsb2FkID0gZ2V0Q2hpbGRQYXlsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkUGF5bG9hZCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hpbGQgcGF5bG9hZCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIjlfMF82M1wiICE9PSBjaGlsZFBheWxvYWQudmVyc2lvbikgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IHdpbmRvdyBoYXMgem9pZCB2ZXJzaW9uIFwiICsgY2hpbGRQYXlsb2FkLnZlcnNpb24gKyBcIiwgY2hpbGQgd2luZG93IGhhcyB2ZXJzaW9uIDlfMF82M1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSBjaGlsZFBheWxvYWQudWlkLCBwYXJlbnREb21haW4gPSBjaGlsZFBheWxvYWQucGFyZW50RG9tYWluLCBleHBvcnRzID0gY2hpbGRQYXlsb2FkLmV4cG9ydHMsIGNvbnRleHQgPSBjaGlsZFBheWxvYWQuY29udGV4dCwgcHJvcHNSZWYgPSBjaGlsZFBheWxvYWQucHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29tcG9uZW50V2luZG93ID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvcGVuZXJcIiA9PT0gdHlwZSkgcmV0dXJuIGFzc2VydEV4aXN0cyhcIm9wZW5lclwiLCBnZXRPcGVuZXIod2luZG93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicGFyZW50XCIgPT09IHR5cGUgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgcmVmLmRpc3RhbmNlKSByZXR1cm4gYXNzZXJ0RXhpc3RzKFwicGFyZW50XCIsIGZ1bmN0aW9uKHdpbiwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHdpbiwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuICYmIChuID0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gd2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHV0aWxzX2dldFBhcmVudChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGdldERpc3RhbmNlRnJvbVRvcCh3aW4pIC0gbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW5kb3csIHJlZi5kaXN0YW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImdsb2JhbFwiID09PSB0eXBlICYmIHJlZi51aWQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgcmVmLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gcmVmLnVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gZ2V0QW5jZXN0b3Iod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmNlc3RvcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGFuY2VzdG9yIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2dldEFsbEZyYW1lc0luV2luZG93MiA9IGdldEFsbEZyYW1lc0luV2luZG93KGFuY2VzdG9yKTsgX2kyIDwgX2dldEFsbEZyYW1lc0luV2luZG93Mi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZ2V0QWxsRnJhbWVzSW5XaW5kb3cyW19pMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKGZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbG9iYWwgPSBsaWJfZ2xvYmFsX2dldEdsb2JhbChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbCAmJiBnbG9iYWwud2luZG93cyAmJiBnbG9iYWwud2luZG93c1t1aWRdKSByZXR1cm4gZ2xvYmFsLndpbmRvd3NbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBcIiArIHR5cGUgKyBcIiBwYXJlbnQgY29tcG9uZW50IHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oY2hpbGRQYXlsb2FkLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gc2V0dXBfZGVzZXJpYWxpemVNZXNzYWdlKHBhcmVudENvbXBvbmVudFdpbmRvdywgcGFyZW50RG9tYWluLCBleHBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG93ID0gcGFyZW50LnNob3csIGhpZGUgPSBwYXJlbnQuaGlkZSwgY2xvc2UgPSBwYXJlbnQuY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudFdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UGFyZW50RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Qcm9wcyA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblByb3BIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm9uRXJyb3IpIHJldHVybiBwYXJlbnQub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemUgPSBmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQucmVzaXplLmZpcmVBbmRGb3JnZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3JlZjIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3JlZjIuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldFByb3BzID0gZnVuY3Rpb24obmV3UHJvcHMsIG9yaWdpbiwgaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGlzVXBkYXRlICYmIChpc1VwZGF0ZSA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFByb3BzID0gZnVuY3Rpb24ocGFyZW50Q29tcG9uZW50V2luZG93LCBwcm9wc0RlZiwgcHJvcHMsIG9yaWdpbiwgaGVscGVycywgaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBpc1VwZGF0ZSAmJiAoaXNVcGRhdGUgPSAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kyIDwgX09iamVjdCRrZXlzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzMltfaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wIHx8ICFwcm9wLnNhbWVEb21haW4gfHwgb3JpZ2luID09PSBnZXREb21haW4od2luZG93KSAmJiBpc1NhbWVEb21haW4ocGFyZW50Q29tcG9uZW50V2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZUNoaWxkUHJvcChwcm9wc0RlZiwgMCwga2V5LCBwcm9wc1trZXldLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgJiYgcHJvcC5hbGlhcyAmJiAhcmVzdWx0W3Byb3AuYWxpYXNdICYmIChyZXN1bHRbcHJvcC5hbGlhc10gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VwZGF0ZSkgZm9yICh2YXIgX2k0ID0gMCwgX09iamVjdCRrZXlzNCA9IE9iamVjdC5rZXlzKHByb3BzRGVmKTsgX2k0IDwgX09iamVjdCRrZXlzNC5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleSA9IF9PYmplY3Qka2V5czRbX2k0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KF9rZXkpIHx8IChyZXN1bHRbX2tleV0gPSBub3JtYWxpemVDaGlsZFByb3AocHJvcHNEZWYsIDAsIF9rZXksIHZvaWQgMCwgaGVscGVycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShwYXJlbnRDb21wb25lbnRXaW5kb3csIHByb3BzRGVmLCBuZXdQcm9wcywgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGNoaWxkX2ZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemU6IHJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9wczogb25Qcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyZW50OiBnZXRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFBhcmVudERvbWFpbjogZ2V0UGFyZW50RG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlzVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA/IGV4dGVuZChwcm9wcywgbm9ybWFsaXplZFByb3BzKSA6IHByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG9uUHJvcEhhbmRsZXJzLmxlbmd0aDsgX2k0KyspICgwLCBvblByb3BIYW5kbGVyc1tfaTRdKShwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVByb3BzID0gZnVuY3Rpb24obmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFByb3BzKG5ld1Byb3BzLCBwYXJlbnREb21haW4sICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oYWxsb3dlZFBhcmVudERvbWFpbnMsIGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oYWxsb3dlZFBhcmVudERvbWFpbnMsIGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYmUgcmVuZGVyZWQgYnkgZG9tYWluOiBcIiArIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGFsbG93ZWRQYXJlbnREb21haW5zLCBwYXJlbnREb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya1dpbmRvd0tub3duKHBhcmVudENvbXBvbmVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hlY2tDbG9zZS5maXJlQW5kRm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoZWNrQ2xvc2UuZmlyZUFuZEZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlV2luZG93KHBhcmVudENvbXBvbmVudFdpbmRvdywgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZF9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pbml0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogdXBkYXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNoaWxkX2Rlc3Ryb3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hdXRvUmVzaXplJHdpZHRoID0gYXV0b1Jlc2l6ZS53aWR0aCwgd2lkdGggPSB2b2lkIDAgIT09IF9hdXRvUmVzaXplJHdpZHRoICYmIF9hdXRvUmVzaXplJHdpZHRoLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdXRvUmVzaXplJGhlaWdodCA9IGF1dG9SZXNpemUuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgIT09IF9hdXRvUmVzaXplJGhlaWdodCAmJiBfYXV0b1Jlc2l6ZSRoZWlnaHQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2F1dG9SZXNpemUkZWxlbWVudCA9IGF1dG9SZXNpemUuZWxlbWVudCwgZWxlbWVudFJlYWR5KHZvaWQgMCA9PT0gX2F1dG9SZXNpemUkZWxlbWVudCA/IFwiYm9keVwiIDogX2F1dG9SZXNpemUkZWxlbWVudCkuY2F0Y2goc3JjX3V0aWxfbm9vcCkudGhlbigoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKS50aGVuKChmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9yZWYzLndpZHRoLCBoZWlnaHQgPSBfcmVmMy5oZWlnaHQsIGVsZW1lbnQgPSBfcmVmMy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgJiYgKHdpZHRoIHx8IGhlaWdodCkgJiYgY29udGV4dCAhPT0gQ09OVEVYVC5QT1BVUCAmJiBvblJlc2l6ZShlbGVtZW50LCAoZnVuY3Rpb24oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/IF9yZWY0LndpZHRoIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBfcmVmNC5oZWlnaHQgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hdXRvUmVzaXplJHdpZHRoLCB3aWR0aCwgX2F1dG9SZXNpemUkaGVpZ2h0LCBoZWlnaHQsIF9hdXRvUmVzaXplJGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzKSByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3BzKGZ1bmN0aW9uKHBhcmVudENvbXBvbmVudFdpbmRvdywgZG9tYWluLCBfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9yZWYudHlwZSwgdWlkID0gX3JlZi51aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJyYXdcIiA9PT0gdHlwZSkgcHJvcHMgPSBfcmVmLnZhbHVlOyBlbHNlIGlmIChcInVpZFwiID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVEb21haW4ocGFyZW50Q29tcG9uZW50V2luZG93KSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGNvbXBvbmVudCB3aW5kb3cgaXMgb24gYSBkaWZmZXJlbnQgZG9tYWluIC0gZXhwZWN0ZWQgXCIgKyBnZXREb21haW4oKSArIFwiIC0gY2FuIG5vdCByZXRyaWV2ZSBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsID0gbGliX2dsb2JhbF9nZXRHbG9iYWwocGFyZW50Q29tcG9uZW50V2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFzc2VydEV4aXN0cyhcInByb3BzXCIsIGdsb2JhbCAmJiBnbG9iYWwucHJvcHNbdWlkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BzKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2UocGFyZW50Q29tcG9uZW50V2luZG93LCBkb21haW4sIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShwYXJlbnRDb21wb25lbnRXaW5kb3csIHBhcmVudERvbWFpbiwgcHJvcHNSZWYpLCBwYXJlbnREb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KHByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZhciBfZWxpZ2libGUgPSBlbGlnaWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyA9IHByb3BzIHx8IHt9XG4gICAgICAgICAgICAgICAgfSksIGVsaWdpYmlsaXR5ID0gX2VsaWdpYmxlLmVsaWdpYmxlLCByZWFzb24gPSBfZWxpZ2libGUucmVhc29uO1xuICAgICAgICAgICAgICAgIHZhciBvbkRlc3Ryb3kgPSBwcm9wcy5vbkRlc3Ryb3k7XG4gICAgICAgICAgICAgICAgcHJvcHMub25EZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlICYmIGVsaWdpYmlsaXR5ICYmIGluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VzLmluZGV4T2YoaW5zdGFuY2UpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVzdHJveSkgcmV0dXJuIG9uRGVzdHJveS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50Q29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbml0KCk7XG4gICAgICAgICAgICAgICAgZWxpZ2liaWxpdHkgPyBwYXJlbnQuc2V0UHJvcHMocHJvcHMpIDogcHJvcHMub25EZXN0cm95ICYmIHByb3BzLm9uRGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGNsZWFuSW5zdGFuY2VzLnJlZ2lzdGVyKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmRlc3Ryb3koZXJyIHx8IG5ldyBFcnJvcihcInpvaWQgZGVzdHJveWVkIGFsbCBjb21wb25lbnRzXCIpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIF9yZW5kZXIgPSBmdW5jdGlvbih0YXJnZXQsIGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWxpZ2liaWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHJlYXNvbiB8fCBuYW1lICsgXCIgY29tcG9uZW50IGlzIG5vdCBlbGlnaWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmRlc3Ryb3koZXJyKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3codGFyZ2V0KSkgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIHdpbmRvdyB0byByZW5kZXJUb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMud2luZG93KSByZXR1cm4gc2V0dXBfdG9Qcm94eVdpbmRvdyhwcm9wcy53aW5kb3cpLmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSBDT05URVhULklGUkFNRSAmJiBjb250ZXh0ICE9PSBDT05URVhULlBPUFVQKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgY29udGV4dDogXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKGZpbmFsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gZnVuY3Rpb24oY29udGV4dCwgY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgY29udGFpbmVyICYmICFpc0VsZW1lbnQoY29udGFpbmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBvciBlbGVtZW50IHNlbGVjdG9yIHRvIGJlIHBhc3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IENPTlRFWFQuUE9QVVApIHJldHVybiBcImJvZHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGJlIHBhc3NlZCB0byByZW5kZXIgaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShmaW5hbENvbnRleHQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LnJlbmRlcih0YXJnZXQsIGNvbnRhaW5lciwgZmluYWxDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZGVzdHJveShlcnIpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBfZXh0ZW5kcyh7fSwgcGFyZW50LmdldEhlbHBlcnMoKSwge1xuICAgICAgICAgICAgICAgICAgICBpc0VsaWdpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGlnaWJpbGl0eTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKF90ZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMkZGVjb3JhdGUgPSAodm9pZCAwID09PSBfdGVtcCA/IHt9IDogX3RlbXApLmRlY29yYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXQoKHZvaWQgMCA9PT0gX3JlZjMkZGVjb3JhdGUgPyBpZGVudGl0eSA6IF9yZWYzJGRlY29yYXRlKShwcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXIod2luZG93LCBjb250YWluZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUbzogZnVuY3Rpb24odGFyZ2V0LCBjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVuZGVyKHRhcmdldCwgY29udGFpbmVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsaWdpYmlsaXR5ICYmIGluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVnaXN0ZXJDaGlsZCgpO1xuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGxvd0RlbGVnYXRlTGlzdGVuZXIgPSBvbl9vbihcInpvaWRfYWxsb3dfZGVsZWdhdGVfXCIgKyBuYW1lLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlTGlzdGVuZXIgPSBvbl9vbihcInpvaWRfZGVsZWdhdGVfXCIgKyBuYW1lLCAoZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRDb21wb25lbnQob3B0aW9ucywgX3JlZi5kYXRhLm92ZXJyaWRlcywgX3JlZi5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNsZWFuWm9pZC5yZWdpc3RlcihhbGxvd0RlbGVnYXRlTGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICBjbGVhblpvaWQucmVnaXN0ZXIoZGVsZWdhdGVMaXN0ZW5lci5jYW5jZWwpO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgZ2xvYmFsLmNvbXBvbmVudHMgPSBnbG9iYWwuY29tcG9uZW50cyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuY29tcG9uZW50c1t0YWddKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSB0YWc6IFwiICsgdGFnKTtcbiAgICAgICAgICAgIGdsb2JhbC5jb21wb25lbnRzW3RhZ10gPSAhMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBkcml2ZXI6IGZ1bmN0aW9uKGRyaXZlck5hbWUsIGRlcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0OiByZWFjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXI6IGFuZ3VsYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2dWU6IHZ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIyOiBhbmd1bGFyMlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRyaXZlcnNbZHJpdmVyTmFtZV0pIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGRyaXZlciBmb3IgZnJhbWV3b3JrOiBcIiArIGRyaXZlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBkcml2ZXJDYWNoZVtkcml2ZXJOYW1lXSB8fCAoZHJpdmVyQ2FjaGVbZHJpdmVyTmFtZV0gPSBkcml2ZXJzW2RyaXZlck5hbWVdLnJlZ2lzdGVyKHRhZywgcHJvcHNEZWYsIGluaXQsIGRlcCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHJpdmVyQ2FjaGVbZHJpdmVyTmFtZV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0NoaWxkOiBpc0NoaWxkLFxuICAgICAgICAgICAgICAgIGNhblJlbmRlclRvOiBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZCh3aW4sIFwiem9pZF9hbGxvd19kZWxlZ2F0ZV9cIiArIG5hbWUpLnRoZW4oKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJDaGlsZDogcmVnaXN0ZXJDaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbF9nZXRHbG9iYWwoKS5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBvbiA9IChfcmVmMyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KS5vbiwgc2VuZCA9IF9yZWYzLnNlbmQsIChnbG9iYWwgPSBnbG9iYWxfZ2V0R2xvYmFsKCkpLnJlY2VpdmVNZXNzYWdlID0gZ2xvYmFsLnJlY2VpdmVNZXNzYWdlIHx8IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjUub24sIHNlbmQgPSBfcmVmNS5zZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoKS5nZXRPclNldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJtZXNzYWdlXCIsIChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZXZlbnQsIF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNC5vbiwgc2VuZCA9IF9yZWY0LnNlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuc291cmNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZXZlbnQub3JpZ2luIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibnVsbFwiID09PSBvcmlnaW4gJiYgKG9yaWdpbiA9IFwiZmlsZTovL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgZGlkIG5vdCBoYXZlIG9yaWdpbiBkb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZXZlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmOC5vbiwgc2VuZCA9IF9yZWY4LnNlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJoZWxsb0xpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBvbihcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZShfcmVmMy5zb3VyY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX3JlZjMub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogZ2V0SW5zdGFuY2VJRCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRBbmNlc3RvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiBzYXlIZWxsbyhwYXJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChmdW5jdGlvbihlcnIpIHt9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYzLCBvbiwgc2VuZCwgZ2xvYmFsO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRfY29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLmluaXQocHJvcHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuZHJpdmVyID0gZnVuY3Rpb24obmFtZSwgZGVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAuZHJpdmVyKG5hbWUsIGRlcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5pdC5pc0NoaWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAuaXNDaGlsZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuY2FuUmVuZGVyVG8gPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5jYW5SZW5kZXJUbyh3aW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuaW5zdGFuY2VzID0gY29tcC5pbnN0YW5jZXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjb21wLnJlZ2lzdGVyQ2hpbGQoKTtcbiAgICAgICAgICAgIGNoaWxkICYmICh3aW5kb3cueHByb3BzID0gaW5pdC54cHJvcHMgPSBjaGlsZC5nZXRQcm9wcygpKTtcbiAgICAgICAgICAgIHJldHVybiBpbml0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3lDb21wb25lbnRzKGVycikge1xuICAgICAgICAgICAgdmFyIGRlc3Ryb3lQcm9taXNlID0gY2xlYW5JbnN0YW5jZXMuYWxsKGVycik7XG4gICAgICAgICAgICBjbGVhbkluc3RhbmNlcyA9IGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybiBkZXN0cm95UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzdHJveUFsbCA9IGRlc3Ryb3lDb21wb25lbnRzO1xuICAgICAgICBmdW5jdGlvbiBjb21wb25lbnRfZGVzdHJveShlcnIpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lBbGwoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuX196b2lkXzlfMF82M19fO1xuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXJzID0gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMiA9IHJlc3BvbnNlTGlzdGVuZXJzLmtleXMoKTsgX2kyIDwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IF9yZXNwb25zZUxpc3RlbmVycyRrZTJbX2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHJlc3BvbnNlTGlzdGVuZXJzLmdldChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyICYmIChsaXN0ZW5lci5jYW5jZWxsZWQgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVycy5kZWwoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgKGxpc3RlbmVyID0gZ2xvYmFsU3RvcmUoKS5nZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIpKSAmJiBsaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5fX3Bvc3Rfcm9ib3RfMTBfMF80Ml9fO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFuWm9pZC5hbGwoZXJyKTtcbiAgICAgICAgfVxuICAgIH0gXSk7XG59KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/zoid/dist/zoid.frameworks.frame.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/open-pluggy-button.tsx":
/*!*******************************************!*\
  !*** ./components/open-pluggy-button.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ OpenPluggyButton; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var use_pluggy_connect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-pluggy-connect */ \"(app-pages-browser)/../lib/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction OpenPluggyButton() {\n    _s();\n    const { init } = (0,use_pluggy_connect__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        connectToken: \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRJZCI6IjBhZDdiMDNiLTUwZWQtNDc1OC04ODhkLTU2MGU1ZDVhYzBkYiIsImRhdGEiOiJjZDBlNjYxYTRlOWQ0N2Y1Y2Y3NWM0ZTI5YmQ4MTc1Yjo0ZGRhNDU4NjRkMDU2ZmY1ZWMzNWM1YTkwNzQ0MjBlZmJiM2E2ZjUyMjcyNThkN2Q3OWUxMGQ4ODQ3NzQ3NDllNTg2YTdhMzVlMTI1ZTRkMjQ1YTIwYjViYmRhNTQxZjdkYzFhNGEwMzhhNmEyNzhhYzFmNGVlZmZkNTFmMjlkNGNkYzgzZWZlMDdmMTg4ZWI4ZTIxYTgwYzM3YmI0MThiOTk3ZWE3MDg2NzYzYWVlZWM1MDg5NzkyMmFmZjI3NmVkYTMzMjlmNjc0NDBlMTdkOGJlMDZkMGYyZmQ4MzUyN2Y1ZTMxNjgxZjE4NDA2ZGVkMjY0YTZkMzQ2MDAwZGY1IiwiaWF0IjoxNzI0MjY3NjgzLCJleHAiOjE3MjQyNjk0ODN9.Wc3R8LQOP9KaI_7hR1EvhVPX73SdbMeF7VqBHnL7HLSnG3bv6WmFtYcyGVSBr_FEvN4q7vchDtJP1vNm0xV39NVbip8CtdYc8hraUiAZm1o-6ra0VVWB_rWciytPc7pX9CL9dhQNIwkVwhNqYNfJ6Pn6IMz_sT4_AA4AjKN2iJcjHA-ADpLJXfHWRbApxLwe-yDUANcR_34yJUm0TgJTX9zuxh9EP6T9scyWxnS40H7PkLu59KK-BNVmDJPXfatCue3wpwhl_vGYF3eP1kMROu-hfzQNBZ7toC7qtDqfzwW5hTmf9x_WH00BIYNaJrBgroA4lRBOCOAFjMB7EwTAdA\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        onClick: init,\n        children: \"Open Pluggy\"\n    }, void 0, false, {\n        fileName: \"/Users/nicolasmontone/pluggy/test/use-pluggy-connect/example-nextjs/components/open-pluggy-button.tsx\",\n        lineNumber: 11,\n        columnNumber: 10\n    }, this);\n}\n_s(OpenPluggyButton, \"RpIxXyos781VhCd7ayqnTllCCOM=\", false, function() {\n    return [\n        use_pluggy_connect__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ];\n});\n_c = OpenPluggyButton;\nvar _c;\n$RefreshReg$(_c, \"OpenPluggyButton\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvb3Blbi1wbHVnZ3ktYnV0dG9uLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVpRDtBQUVsQyxTQUFTQzs7SUFDdEIsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0YsOERBQWdCQSxDQUFDO1FBQ2hDRyxjQUNFO0lBQ0o7SUFFQSxxQkFBTyw4REFBQ0M7UUFBT0MsU0FBU0g7a0JBQU07Ozs7OztBQUNoQztHQVB3QkQ7O1FBQ0xELDBEQUFnQkE7OztLQURYQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL29wZW4tcGx1Z2d5LWJ1dHRvbi50c3g/N2FjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHVzZVBsdWdneUNvbm5lY3QgZnJvbSAndXNlLXBsdWdneS1jb25uZWN0J1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPcGVuUGx1Z2d5QnV0dG9uKCkge1xuICBjb25zdCB7IGluaXQgfSA9IHVzZVBsdWdneUNvbm5lY3Qoe1xuICAgIGNvbm5lY3RUb2tlbjpcbiAgICAgICdleUpoYkdjaU9pSlNVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKamJHbGxiblJKWkNJNklqQmhaRGRpTUROaUxUVXdaV1F0TkRjMU9DMDRPRGhrTFRVMk1HVTFaRFZoWXpCa1lpSXNJbVJoZEdFaU9pSmpaREJsTmpZeFlUUmxPV1EwTjJZMVkyWTNOV00wWlRJNVltUTRNVGMxWWpvMFpHUmhORFU0TmpSa01EVTJabVkxWldNek5XTTFZVGt3TnpRME1qQmxabUppTTJFMlpqVXlNamN5TlRoa04yUTNPV1V4TUdRNE9EUTNOelEzTkRsbE5UZzJZVGRoTXpWbE1USTFaVFJrTWpRMVlUSXdZalZpWW1SaE5UUXhaamRrWXpGaE5HRXdNemhoTm1FeU56aGhZekZtTkdWbFptWmtOVEZtTWpsa05HTmtZemd6WldabE1EZG1NVGc0WldJNFpUSXhZVGd3WXpNM1ltSTBNVGhpT1RrM1pXRTNNRGcyTnpZellXVmxaV00xTURnNU56a3lNbUZtWmpJM05tVmtZVE16TWpsbU5qYzBOREJsTVRka09HSmxNRFprTUdZeVptUTRNelV5TjJZMVpUTXhOamd4WmpFNE5EQTJaR1ZrTWpZMFlUWmtNelEyTURBd1pHWTFJaXdpYVdGMElqb3hOekkwTWpZM05qZ3pMQ0psZUhBaU9qRTNNalF5TmprME9ETjkuV2MzUjhMUU9QOUthSV83aFIxRXZoVlBYNzNTZGJNZUY3VnFCSG5MN0hMU25HM2J2NldtRnRZY3lHVlNCcl9GRXZONHE3dmNoRHRKUDF2Tm0weFYzOU5WYmlwOEN0ZFljOGhyYVVpQVptMW8tNnJhMFZWV0JfcldjaXl0UGM3cFg5Q0w5ZGhRTkl3a1Z3aE5xWU5mSjZQbjZJTXpfc1Q0X0FBNEFqS04yaUpjakhBLUFEcExKWGZIV1JiQXB4THdlLXlEVUFOY1JfMzR5SlVtMFRnSlRYOXp1eGg5RVA2VDlzY3lXeG5TNDBIN1BrTHU1OUtLLUJOVm1ESlBYZmF0Q3VlM3dwd2hsX3ZHWUYzZVAxa01ST3UtaGZ6UU5CWjd0b0M3cXREcWZ6d1c1aFRtZjl4X1dIMDBCSVlOYUpyQmdyb0E0bFJCT0NPQUZqTUI3RXdUQWRBJyxcbiAgfSlcblxuICByZXR1cm4gPGJ1dHRvbiBvbkNsaWNrPXtpbml0fT5PcGVuIFBsdWdneTwvYnV0dG9uPlxufVxuIl0sIm5hbWVzIjpbInVzZVBsdWdneUNvbm5lY3QiLCJPcGVuUGx1Z2d5QnV0dG9uIiwiaW5pdCIsImNvbm5lY3RUb2tlbiIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/open-pluggy-button.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/../lib/index.js":
/*!***********************!*\
  !*** ../lib/index.js ***!
  \***********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar react_1 = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar noop = function() {};\nvar usePluggyConnect = function(options) {\n    var _a = (0, react_1.useState)(null), error = _a[0], setError = _a[1];\n    var _b = (0, react_1.useState)(null), pluggyConnect = _b[0], setPluggyConnect = _b[1];\n    var pluggyConnectBase = (0, react_1.useRef)(null);\n    (0, react_1.useEffect)(function() {\n        var isBrowser = \"object\" !== \"undefined\";\n        if (!isBrowser) return; // Exit the effect if not in the browser\n        function loadPluggyConnect() {\n            return __awaiter(this, void 0, void 0, function() {\n                var PluggyConnect, pluggyConnect_;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            if (!options.connectToken) {\n                                throw new Error(\"use-pluggy-connect: You need a valid connectToken for usePluggyConnect.\");\n                            }\n                            return [\n                                4 /*yield*/ ,\n                                Promise.resolve().then(function() {\n                                    return __importStar(__webpack_require__(/*! pluggy-connect-sdk */ \"(app-pages-browser)/../node_modules/pluggy-connect-sdk/dist/module/index.js\"));\n                                })\n                            ];\n                        case 1:\n                            PluggyConnect = _a.sent().PluggyConnect;\n                            pluggyConnectBase.current = PluggyConnect;\n                            pluggyConnect_ = new PluggyConnect(options);\n                            setPluggyConnect(pluggyConnect_);\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        }\n        loadPluggyConnect();\n    }, [\n        options.connectToken\n    ]);\n    var init = (0, react_1.useCallback)(function() {\n        if (!pluggyConnect) {\n            throw new Error(\"use-pluggy-connect: PluggyConnect instance isn't ready yet.\");\n        }\n        try {\n            var containerElement = document.body || document.documentElement || document.getElementsByTagName(\"div\")[0];\n            pluggyConnect.init(containerElement);\n        } catch (e) {\n            if (e instanceof Error) {\n                console.error(\"Failed to initialize PluggyConnect\", e);\n                setError(e);\n            }\n        }\n    }, [\n        pluggyConnect\n    ]);\n    return {\n        init: init,\n        error: error,\n        ready: Boolean(pluggyConnect),\n        show: pluggyConnect ? pluggyConnect.show : noop,\n        hide: pluggyConnect ? pluggyConnect.hide : noop\n    };\n};\nexports[\"default\"] = usePluggyConnect;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzZDLFNBQVNDLGVBQWUsSUFDeEJELFNBQVNFLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzNDakIsY0FBY1ksSUFBSSxDQUFDRTtRQUN2QixFQUNBLE9BQU9sRCxHQUFHO1lBQ04sSUFBSUEsYUFBYThDLE9BQU87Z0JBQ3BCUSxRQUFRckIsS0FBSyxDQUFDLHNDQUFzQ2pDO2dCQUNwRGtDLFNBQVNsQztZQUNiO1FBQ0o7SUFDSixHQUFHO1FBQUNvQztLQUFjO0lBQ2xCLE9BQU87UUFDSFksTUFBTUE7UUFDTmYsT0FBT0E7UUFDUHNCLE9BQU9DLFFBQVFwQjtRQUNmcUIsTUFBTXJCLGdCQUFnQkEsY0FBY3FCLElBQUksR0FBRzdCO1FBQzNDOEIsTUFBTXRCLGdCQUFnQkEsY0FBY3NCLElBQUksR0FBRzlCO0lBQy9DO0FBQ0o7QUFDQUgsa0JBQWUsR0FBR0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2xpYi9pbmRleC5qcz9mM2RlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIHVzZVBsdWdneUNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfYSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShudWxsKSwgZXJyb3IgPSBfYVswXSwgc2V0RXJyb3IgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobnVsbCksIHBsdWdneUNvbm5lY3QgPSBfYlswXSwgc2V0UGx1Z2d5Q29ubmVjdCA9IF9iWzFdO1xuICAgIHZhciBwbHVnZ3lDb25uZWN0QmFzZSA9ICgwLCByZWFjdF8xLnVzZVJlZikobnVsbCk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpXG4gICAgICAgICAgICByZXR1cm47IC8vIEV4aXQgdGhlIGVmZmVjdCBpZiBub3QgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgZnVuY3Rpb24gbG9hZFBsdWdneUNvbm5lY3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIFBsdWdneUNvbm5lY3QsIHBsdWdneUNvbm5lY3RfO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jb25uZWN0VG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2UtcGx1Z2d5LWNvbm5lY3Q6IFlvdSBuZWVkIGEgdmFsaWQgY29ubmVjdFRva2VuIGZvciB1c2VQbHVnZ3lDb25uZWN0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9faW1wb3J0U3RhcihyZXF1aXJlKCdwbHVnZ3ktY29ubmVjdC1zZGsnKSk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbHVnZ3lDb25uZWN0ID0gKF9hLnNlbnQoKSkuUGx1Z2d5Q29ubmVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnZ3lDb25uZWN0QmFzZS5jdXJyZW50ID0gUGx1Z2d5Q29ubmVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnZ3lDb25uZWN0XyA9IG5ldyBQbHVnZ3lDb25uZWN0KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFBsdWdneUNvbm5lY3QocGx1Z2d5Q29ubmVjdF8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZFBsdWdneUNvbm5lY3QoKTtcbiAgICB9LCBbb3B0aW9ucy5jb25uZWN0VG9rZW5dKTtcbiAgICB2YXIgaW5pdCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGx1Z2d5Q29ubmVjdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXNlLXBsdWdneS1jb25uZWN0OiBQbHVnZ3lDb25uZWN0IGluc3RhbmNlIGlzbid0IHJlYWR5IHlldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKVswXTtcbiAgICAgICAgICAgIHBsdWdneUNvbm5lY3QuaW5pdChjb250YWluZXJFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFBsdWdneUNvbm5lY3QnLCBlKTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtwbHVnZ3lDb25uZWN0XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICByZWFkeTogQm9vbGVhbihwbHVnZ3lDb25uZWN0KSxcbiAgICAgICAgc2hvdzogcGx1Z2d5Q29ubmVjdCA/IHBsdWdneUNvbm5lY3Quc2hvdyA6IG5vb3AsXG4gICAgICAgIGhpZGU6IHBsdWdneUNvbm5lY3QgPyBwbHVnZ3lDb25uZWN0LmhpZGUgOiBub29wLFxuICAgIH07XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUGx1Z2d5Q29ubmVjdDtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsIm9wIiwiVHlwZUVycm9yIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsImV4cG9ydHMiLCJyZWFjdF8xIiwicmVxdWlyZSIsIm5vb3AiLCJ1c2VQbHVnZ3lDb25uZWN0Iiwib3B0aW9ucyIsIl9hIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwiX2IiLCJwbHVnZ3lDb25uZWN0Iiwic2V0UGx1Z2d5Q29ubmVjdCIsInBsdWdneUNvbm5lY3RCYXNlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiaXNCcm93c2VyIiwibG9hZFBsdWdneUNvbm5lY3QiLCJQbHVnZ3lDb25uZWN0IiwicGx1Z2d5Q29ubmVjdF8iLCJjb25uZWN0VG9rZW4iLCJFcnJvciIsImN1cnJlbnQiLCJpbml0IiwidXNlQ2FsbGJhY2siLCJjb250YWluZXJFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNvbnNvbGUiLCJyZWFkeSIsIkJvb2xlYW4iLCJzaG93IiwiaGlkZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz80MjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YmQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnicolasmontone%2Fpluggy%2Ftest%2Fuse-pluggy-connect%2Fexample-nextjs%2Fcomponents%2Fopen-pluggy-button.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);