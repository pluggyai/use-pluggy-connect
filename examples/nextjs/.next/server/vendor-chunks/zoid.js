/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zoid";
exports.ids = ["vendor-chunks/zoid"];
exports.modules = {

/***/ "(ssr)/../node_modules/zoid/dist/zoid.frameworks.frame.js":
/*!**********************************************************!*\
  !*** ../node_modules/zoid/dist/zoid.frameworks.frame.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("!function(root, factory) {\n     true ? module.exports = factory() : 0;\n}(\"undefined\" != typeof self ? self : this, (function() {\n    return function(modules) {\n        var installedModules = {};\n        function __nested_webpack_require_403__(moduleId) {\n            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n            var module = installedModules[moduleId] = {\n                i: moduleId,\n                l: !1,\n                exports: {}\n            };\n            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_403__);\n            module.l = !0;\n            return module.exports;\n        }\n        __nested_webpack_require_403__.m = modules;\n        __nested_webpack_require_403__.c = installedModules;\n        __nested_webpack_require_403__.d = function(exports, name, getter) {\n            __nested_webpack_require_403__.o(exports, name) || Object.defineProperty(exports, name, {\n                enumerable: !0,\n                get: getter\n            });\n        };\n        __nested_webpack_require_403__.r = function(exports) {\n            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n                value: \"Module\"\n            });\n            Object.defineProperty(exports, \"__esModule\", {\n                value: !0\n            });\n        };\n        __nested_webpack_require_403__.t = function(value, mode) {\n            1 & mode && (value = __nested_webpack_require_403__(value));\n            if (8 & mode) return value;\n            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n            var ns = Object.create(null);\n            __nested_webpack_require_403__.r(ns);\n            Object.defineProperty(ns, \"default\", {\n                enumerable: !0,\n                value: value\n            });\n            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_403__.d(ns, key, function(key) {\n                return value[key];\n            }.bind(null, key));\n            return ns;\n        };\n        __nested_webpack_require_403__.n = function(module) {\n            var getter = module && module.__esModule ? function() {\n                return module.default;\n            } : function() {\n                return module;\n            };\n            __nested_webpack_require_403__.d(getter, \"a\", getter);\n            return getter;\n        };\n        __nested_webpack_require_403__.o = function(object, property) {\n            return {}.hasOwnProperty.call(object, property);\n        };\n        __nested_webpack_require_403__.p = \"\";\n        return __nested_webpack_require_403__(__nested_webpack_require_403__.s = 0);\n    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_2811__) {\n        \"use strict\";\n        __nested_webpack_require_2811__.r(__nested_webpack_exports__);\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"PopupOpenError\", (function() {\n            return dom_PopupOpenError;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"create\", (function() {\n            return create;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"destroy\", (function() {\n            return component_destroy;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"destroyComponents\", (function() {\n            return destroyComponents;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"destroyAll\", (function() {\n            return destroyAll;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"PROP_TYPE\", (function() {\n            return PROP_TYPE;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"PROP_SERIALIZATION\", (function() {\n            return PROP_SERIALIZATION;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"CONTEXT\", (function() {\n            return CONTEXT;\n        }));\n        __nested_webpack_require_2811__.d(__nested_webpack_exports__, \"EVENT\", (function() {\n            return EVENT;\n        }));\n        function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n        }\n        function _extends() {\n            return (_extends = Object.assign || function(target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n                    for (var key in source) ({}).hasOwnProperty.call(source, key) && (target[key] = source[key]);\n                }\n                return target;\n            }).apply(this, arguments);\n        }\n        function utils_isPromise(item) {\n            try {\n                if (!item) return !1;\n                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n                var _toString = {}.toString;\n                if (_toString) {\n                    var name = _toString.call(item);\n                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n                }\n                if (\"function\" == typeof item.then) return !0;\n            } catch (err) {\n                return !1;\n            }\n            return !1;\n        }\n        var dispatchedErrors = [];\n        var possiblyUnhandledPromiseHandlers = [];\n        var activeCount = 0;\n        var flushPromise;\n        function flushActive() {\n            if (!activeCount && flushPromise) {\n                var promise = flushPromise;\n                flushPromise = null;\n                promise.resolve();\n            }\n        }\n        function startActive() {\n            activeCount += 1;\n        }\n        function endActive() {\n            activeCount -= 1;\n            flushActive();\n        }\n        var promise_ZalgoPromise = function() {\n            function ZalgoPromise(handler) {\n                var _this = this;\n                this.resolved = void 0;\n                this.rejected = void 0;\n                this.errorHandled = void 0;\n                this.value = void 0;\n                this.error = void 0;\n                this.handlers = void 0;\n                this.dispatching = void 0;\n                this.stack = void 0;\n                this.resolved = !1;\n                this.rejected = !1;\n                this.errorHandled = !1;\n                this.handlers = [];\n                if (handler) {\n                    var _result;\n                    var _error;\n                    var resolved = !1;\n                    var rejected = !1;\n                    var isAsync = !1;\n                    startActive();\n                    try {\n                        handler((function(res) {\n                            if (isAsync) _this.resolve(res); else {\n                                resolved = !0;\n                                _result = res;\n                            }\n                        }), (function(err) {\n                            if (isAsync) _this.reject(err); else {\n                                rejected = !0;\n                                _error = err;\n                            }\n                        }));\n                    } catch (err) {\n                        endActive();\n                        this.reject(err);\n                        return;\n                    }\n                    endActive();\n                    isAsync = !0;\n                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n                }\n            }\n            var _proto = ZalgoPromise.prototype;\n            _proto.resolve = function(result) {\n                if (this.resolved || this.rejected) return this;\n                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n                this.resolved = !0;\n                this.value = result;\n                this.dispatch();\n                return this;\n            };\n            _proto.reject = function(error) {\n                var _this2 = this;\n                if (this.resolved || this.rejected) return this;\n                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n                if (!error) {\n                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n                }\n                this.rejected = !0;\n                this.error = error;\n                this.errorHandled || setTimeout((function() {\n                    _this2.errorHandled || function(err, promise) {\n                        if (-1 === dispatchedErrors.indexOf(err)) {\n                            dispatchedErrors.push(err);\n                            setTimeout((function() {\n                                throw err;\n                            }), 1);\n                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n                        }\n                    }(error, _this2);\n                }), 1);\n                this.dispatch();\n                return this;\n            };\n            _proto.asyncReject = function(error) {\n                this.errorHandled = !0;\n                this.reject(error);\n                return this;\n            };\n            _proto.dispatch = function() {\n                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n                if (!this.dispatching && (resolved || rejected)) {\n                    this.dispatching = !0;\n                    startActive();\n                    var chain = function(firstPromise, secondPromise) {\n                        return firstPromise.then((function(res) {\n                            secondPromise.resolve(res);\n                        }), (function(err) {\n                            secondPromise.reject(err);\n                        }));\n                    };\n                    for (var i = 0; i < handlers.length; i++) {\n                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n                        var _result2 = void 0;\n                        if (resolved) try {\n                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n                        } catch (err) {\n                            promise.reject(err);\n                            continue;\n                        } else if (rejected) {\n                            if (!onError) {\n                                promise.reject(this.error);\n                                continue;\n                            }\n                            try {\n                                _result2 = onError(this.error);\n                            } catch (err) {\n                                promise.reject(err);\n                                continue;\n                            }\n                        }\n                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n                            _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error);\n                            _result2.errorHandled = !0;\n                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n                    }\n                    handlers.length = 0;\n                    this.dispatching = !1;\n                    endActive();\n                }\n            };\n            _proto.then = function(onSuccess, onError) {\n                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n                var promise = new ZalgoPromise;\n                this.handlers.push({\n                    promise: promise,\n                    onSuccess: onSuccess,\n                    onError: onError\n                });\n                this.errorHandled = !0;\n                this.dispatch();\n                return promise;\n            };\n            _proto.catch = function(onError) {\n                return this.then(void 0, onError);\n            };\n            _proto.finally = function(onFinally) {\n                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n                return this.then((function(result) {\n                    return ZalgoPromise.try(onFinally).then((function() {\n                        return result;\n                    }));\n                }), (function(err) {\n                    return ZalgoPromise.try(onFinally).then((function() {\n                        throw err;\n                    }));\n                }));\n            };\n            _proto.timeout = function(time, err) {\n                var _this3 = this;\n                if (this.resolved || this.rejected) return this;\n                var timeout = setTimeout((function() {\n                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n                }), time);\n                return this.then((function(result) {\n                    clearTimeout(timeout);\n                    return result;\n                }));\n            };\n            _proto.toPromise = function() {\n                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n                return Promise.resolve(this);\n            };\n            ZalgoPromise.resolve = function(value) {\n                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n                    return value.then(resolve, reject);\n                })) : (new ZalgoPromise).resolve(value);\n            };\n            ZalgoPromise.reject = function(error) {\n                return (new ZalgoPromise).reject(error);\n            };\n            ZalgoPromise.asyncReject = function(error) {\n                return (new ZalgoPromise).asyncReject(error);\n            };\n            ZalgoPromise.all = function(promises) {\n                var promise = new ZalgoPromise;\n                var count = promises.length;\n                var results = [];\n                if (!count) {\n                    promise.resolve(results);\n                    return promise;\n                }\n                var chain = function(i, firstPromise, secondPromise) {\n                    return firstPromise.then((function(res) {\n                        results[i] = res;\n                        0 == (count -= 1) && promise.resolve(results);\n                    }), (function(err) {\n                        secondPromise.reject(err);\n                    }));\n                };\n                for (var i = 0; i < promises.length; i++) {\n                    var prom = promises[i];\n                    if (prom instanceof ZalgoPromise) {\n                        if (prom.resolved) {\n                            results[i] = prom.value;\n                            count -= 1;\n                            continue;\n                        }\n                    } else if (!utils_isPromise(prom)) {\n                        results[i] = prom;\n                        count -= 1;\n                        continue;\n                    }\n                    chain(i, ZalgoPromise.resolve(prom), promise);\n                }\n                0 === count && promise.resolve(results);\n                return promise;\n            };\n            ZalgoPromise.hash = function(promises) {\n                var result = {};\n                var awaitPromises = [];\n                var _loop = function(key) {\n                    if (promises.hasOwnProperty(key)) {\n                        var value = promises[key];\n                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n                            result[key] = res;\n                        }))) : result[key] = value;\n                    }\n                };\n                for (var key in promises) _loop(key);\n                return ZalgoPromise.all(awaitPromises).then((function() {\n                    return result;\n                }));\n            };\n            ZalgoPromise.map = function(items, method) {\n                return ZalgoPromise.all(items.map(method));\n            };\n            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n                return function(handler) {\n                    possiblyUnhandledPromiseHandlers.push(handler);\n                    return {\n                        cancel: function() {\n                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n                        }\n                    };\n                }(handler);\n            };\n            ZalgoPromise.try = function(method, context, args) {\n                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n                var result;\n                startActive();\n                try {\n                    result = method.apply(context, args || []);\n                } catch (err) {\n                    endActive();\n                    return ZalgoPromise.reject(err);\n                }\n                endActive();\n                return ZalgoPromise.resolve(result);\n            };\n            ZalgoPromise.delay = function(_delay) {\n                return new ZalgoPromise((function(resolve) {\n                    setTimeout(resolve, _delay);\n                }));\n            };\n            ZalgoPromise.isPromise = function(value) {\n                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n            };\n            ZalgoPromise.flush = function() {\n                return function(Zalgo) {\n                    var promise = flushPromise = flushPromise || new Zalgo;\n                    flushActive();\n                    return promise;\n                }(ZalgoPromise);\n            };\n            return ZalgoPromise;\n        }();\n        function isRegex(item) {\n            return \"[object RegExp]\" === {}.toString.call(item);\n        }\n        var WINDOW_TYPE = {\n            IFRAME: \"iframe\",\n            POPUP: \"popup\"\n        };\n        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n        function isAboutProtocol(win) {\n            void 0 === win && (win = window);\n            return \"about:\" === win.location.protocol;\n        }\n        function utils_getParent(win) {\n            void 0 === win && (win = window);\n            if (win) try {\n                if (win.parent && win.parent !== win) return win.parent;\n            } catch (err) {}\n        }\n        function getOpener(win) {\n            void 0 === win && (win = window);\n            if (win && !utils_getParent(win)) try {\n                return win.opener;\n            } catch (err) {}\n        }\n        function canReadFromWindow(win) {\n            try {\n                return !0;\n            } catch (err) {}\n            return !1;\n        }\n        function getActualDomain(win) {\n            void 0 === win && (win = window);\n            var location = win.location;\n            if (!location) throw new Error(\"Can not read window location\");\n            var protocol = location.protocol;\n            if (!protocol) throw new Error(\"Can not read window protocol\");\n            if (\"file:\" === protocol) return \"file://\";\n            if (\"about:\" === protocol) {\n                var parent = utils_getParent(win);\n                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n            }\n            var host = location.host;\n            if (!host) throw new Error(\"Can not read window host\");\n            return protocol + \"//\" + host;\n        }\n        function getDomain(win) {\n            void 0 === win && (win = window);\n            var domain = getActualDomain(win);\n            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n        }\n        function isSameDomain(win) {\n            if (!function(win) {\n                try {\n                    if (win === window) return !0;\n                } catch (err) {}\n                try {\n                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n                    if (desc && !1 === desc.enumerable) return !1;\n                } catch (err) {}\n                try {\n                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n                } catch (err) {}\n                try {\n                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n                } catch (err) {}\n                return !1;\n            }(win)) return !1;\n            try {\n                if (win === window) return !0;\n                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n                if (getDomain(window) === getDomain(win)) return !0;\n            } catch (err) {}\n            return !1;\n        }\n        function assertSameDomain(win) {\n            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n            return win;\n        }\n        function isAncestorParent(parent, child) {\n            if (!parent || !child) return !1;\n            var childParent = utils_getParent(child);\n            return childParent ? childParent === parent : -1 !== function(win) {\n                var result = [];\n                try {\n                    for (;win.parent !== win; ) {\n                        result.push(win.parent);\n                        win = win.parent;\n                    }\n                } catch (err) {}\n                return result;\n            }(child).indexOf(parent);\n        }\n        function getFrames(win) {\n            var result = [];\n            var frames;\n            try {\n                frames = win.frames;\n            } catch (err) {\n                frames = win;\n            }\n            var len;\n            try {\n                len = frames.length;\n            } catch (err) {}\n            if (0 === len) return result;\n            if (len) {\n                for (var i = 0; i < len; i++) {\n                    var frame = void 0;\n                    try {\n                        frame = frames[i];\n                    } catch (err) {\n                        continue;\n                    }\n                    result.push(frame);\n                }\n                return result;\n            }\n            for (var _i = 0; _i < 100; _i++) {\n                var _frame = void 0;\n                try {\n                    _frame = frames[_i];\n                } catch (err) {\n                    return result;\n                }\n                if (!_frame) return result;\n                result.push(_frame);\n            }\n            return result;\n        }\n        function getAllChildFrames(win) {\n            var result = [];\n            for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n                var frame = _getFrames2[_i3];\n                result.push(frame);\n                for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n            }\n            return result;\n        }\n        function getTop(win) {\n            void 0 === win && (win = window);\n            try {\n                if (win.top) return win.top;\n            } catch (err) {}\n            if (utils_getParent(win) === win) return win;\n            try {\n                if (isAncestorParent(window, win) && window.top) return window.top;\n            } catch (err) {}\n            try {\n                if (isAncestorParent(win, window) && window.top) return window.top;\n            } catch (err) {}\n            for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {\n                var frame = _getAllChildFrames4[_i7];\n                try {\n                    if (frame.top) return frame.top;\n                } catch (err) {}\n                if (utils_getParent(frame) === frame) return frame;\n            }\n        }\n        function getAllFramesInWindow(win) {\n            var top = getTop(win);\n            if (!top) throw new Error(\"Can not determine top window\");\n            var result = [].concat(getAllChildFrames(top), [ top ]);\n            -1 === result.indexOf(win) && (result = [].concat(result, [ win ], getAllChildFrames(win)));\n            return result;\n        }\n        var iframeWindows = [];\n        var iframeFrames = [];\n        function isWindowClosed(win, allowMock) {\n            void 0 === allowMock && (allowMock = !0);\n            try {\n                if (win === window) return !1;\n            } catch (err) {\n                return !0;\n            }\n            try {\n                if (!win) return !0;\n            } catch (err) {\n                return !0;\n            }\n            try {\n                if (win.closed) return !0;\n            } catch (err) {\n                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n            }\n            if (allowMock && isSameDomain(win)) try {\n                if (win.mockclosed) return !0;\n            } catch (err) {}\n            try {\n                if (!win.parent || !win.top) return !0;\n            } catch (err) {}\n            var iframeIndex = function(collection, item) {\n                for (var i = 0; i < collection.length; i++) try {\n                    if (collection[i] === item) return i;\n                } catch (err) {}\n                return -1;\n            }(iframeWindows, win);\n            if (-1 !== iframeIndex) {\n                var frame = iframeFrames[iframeIndex];\n                if (frame && function(frame) {\n                    if (!frame.contentWindow) return !0;\n                    if (!frame.parentNode) return !0;\n                    var doc = frame.ownerDocument;\n                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n                        var parent = frame;\n                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n                    }\n                    return !1;\n                }(frame)) return !0;\n            }\n            return !1;\n        }\n        function getAncestor(win) {\n            void 0 === win && (win = window);\n            return getOpener(win = win || window) || utils_getParent(win) || void 0;\n        }\n        function anyMatch(collection1, collection2) {\n            for (var _i17 = 0; _i17 < collection1.length; _i17++) {\n                var item1 = collection1[_i17];\n                for (var _i19 = 0; _i19 < collection2.length; _i19++) if (item1 === collection2[_i19]) return !0;\n            }\n            return !1;\n        }\n        function getDistanceFromTop(win) {\n            void 0 === win && (win = window);\n            var distance = 0;\n            var parent = win;\n            for (;parent; ) (parent = utils_getParent(parent)) && (distance += 1);\n            return distance;\n        }\n        function isSameTopWindow(win1, win2) {\n            var top1 = getTop(win1) || win1;\n            var top2 = getTop(win2) || win2;\n            try {\n                if (top1 && top2) return top1 === top2;\n            } catch (err) {}\n            var allFrames1 = getAllFramesInWindow(win1);\n            var allFrames2 = getAllFramesInWindow(win2);\n            if (anyMatch(allFrames1, allFrames2)) return !0;\n            var opener1 = getOpener(top1);\n            var opener2 = getOpener(top2);\n            return opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2) || opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1), \n            !1;\n        }\n        function matchDomain(pattern, origin) {\n            if (\"string\" == typeof pattern) {\n                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n                if (isRegex(origin)) return !1;\n                if (Array.isArray(origin)) return !1;\n            }\n            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n                return matchDomain(subpattern, origin);\n            })));\n        }\n        function getDomainFromUrl(url) {\n            return url.match(/^(https?|mock|file):\\/\\//) ? url.split(\"/\").slice(0, 3).join(\"/\") : getDomain();\n        }\n        function onCloseWindow(win, callback, delay, maxtime) {\n            void 0 === delay && (delay = 1e3);\n            void 0 === maxtime && (maxtime = 1 / 0);\n            var timeout;\n            !function check() {\n                if (isWindowClosed(win)) {\n                    timeout && clearTimeout(timeout);\n                    return callback();\n                }\n                if (maxtime <= 0) clearTimeout(timeout); else {\n                    maxtime -= delay;\n                    timeout = setTimeout(check, delay);\n                }\n            }();\n            return {\n                cancel: function() {\n                    timeout && clearTimeout(timeout);\n                }\n            };\n        }\n        function isWindow(obj) {\n            try {\n                if (obj === window) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (window.Window && obj instanceof window.Window) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && obj.self === obj) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && obj.parent === obj) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && obj.top === obj) return !0;\n            } catch (err) {\n                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n            }\n            try {\n                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n            } catch (err) {\n                return !0;\n            }\n            try {\n                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n            } catch (err) {}\n            return !1;\n        }\n        function closeWindow(win) {\n            try {\n                win.close();\n            } catch (err) {}\n        }\n        function util_safeIndexOf(collection, item) {\n            for (var i = 0; i < collection.length; i++) try {\n                if (collection[i] === item) return i;\n            } catch (err) {}\n            return -1;\n        }\n        var weakmap_CrossDomainSafeWeakMap = function() {\n            function CrossDomainSafeWeakMap() {\n                this.name = void 0;\n                this.weakmap = void 0;\n                this.keys = void 0;\n                this.values = void 0;\n                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n                if (function() {\n                    if (\"undefined\" == typeof WeakMap) return !1;\n                    if (void 0 === Object.freeze) return !1;\n                    try {\n                        var testWeakMap = new WeakMap;\n                        var testKey = {};\n                        Object.freeze(testKey);\n                        testWeakMap.set(testKey, \"__testvalue__\");\n                        return \"__testvalue__\" === testWeakMap.get(testKey);\n                    } catch (err) {\n                        return !1;\n                    }\n                }()) try {\n                    this.weakmap = new WeakMap;\n                } catch (err) {}\n                this.keys = [];\n                this.values = [];\n            }\n            var _proto = CrossDomainSafeWeakMap.prototype;\n            _proto._cleanupClosedWindows = function() {\n                var weakmap = this.weakmap;\n                var keys = this.keys;\n                for (var i = 0; i < keys.length; i++) {\n                    var value = keys[i];\n                    if (isWindow(value) && isWindowClosed(value)) {\n                        if (weakmap) try {\n                            weakmap.delete(value);\n                        } catch (err) {}\n                        keys.splice(i, 1);\n                        this.values.splice(i, 1);\n                        i -= 1;\n                    }\n                }\n            };\n            _proto.isSafeToReadWrite = function(key) {\n                return !isWindow(key);\n            };\n            _proto.set = function(key, value) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    weakmap.set(key, value);\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var name = this.name;\n                    var entry = key[name];\n                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n                        value: [ key, value ],\n                        writable: !0\n                    });\n                    return;\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                var keys = this.keys;\n                var values = this.values;\n                var index = util_safeIndexOf(keys, key);\n                if (-1 === index) {\n                    keys.push(key);\n                    values.push(value);\n                } else values[index] = value;\n            };\n            _proto.get = function(key) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    if (weakmap.has(key)) return weakmap.get(key);\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var entry = key[this.name];\n                    return entry && entry[0] === key ? entry[1] : void 0;\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                var index = util_safeIndexOf(this.keys, key);\n                if (-1 !== index) return this.values[index];\n            };\n            _proto.delete = function(key) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    weakmap.delete(key);\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var entry = key[this.name];\n                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                var keys = this.keys;\n                var index = util_safeIndexOf(keys, key);\n                if (-1 !== index) {\n                    keys.splice(index, 1);\n                    this.values.splice(index, 1);\n                }\n            };\n            _proto.has = function(key) {\n                if (!key) throw new Error(\"WeakMap expected key\");\n                var weakmap = this.weakmap;\n                if (weakmap) try {\n                    if (weakmap.has(key)) return !0;\n                } catch (err) {\n                    delete this.weakmap;\n                }\n                if (this.isSafeToReadWrite(key)) try {\n                    var entry = key[this.name];\n                    return !(!entry || entry[0] !== key);\n                } catch (err) {}\n                this._cleanupClosedWindows();\n                return -1 !== util_safeIndexOf(this.keys, key);\n            };\n            _proto.getOrSet = function(key, getter) {\n                if (this.has(key)) return this.get(key);\n                var value = getter();\n                this.set(key, value);\n                return value;\n            };\n            return CrossDomainSafeWeakMap;\n        }();\n        function _getPrototypeOf(o) {\n            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {\n                return o.__proto__ || Object.getPrototypeOf(o);\n            })(o);\n        }\n        function _setPrototypeOf(o, p) {\n            return (_setPrototypeOf = Object.setPrototypeOf || function(o, p) {\n                o.__proto__ = p;\n                return o;\n            })(o, p);\n        }\n        function _isNativeReflectConstruct() {\n            if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n            if (Reflect.construct.sham) return !1;\n            if (\"function\" == typeof Proxy) return !0;\n            try {\n                Date.prototype.toString.call(Reflect.construct(Date, [], (function() {})));\n                return !0;\n            } catch (e) {\n                return !1;\n            }\n        }\n        function construct_construct(Parent, args, Class) {\n            return (construct_construct = _isNativeReflectConstruct() ? Reflect.construct : function(Parent, args, Class) {\n                var a = [ null ];\n                a.push.apply(a, args);\n                var instance = new (Function.bind.apply(Parent, a));\n                Class && _setPrototypeOf(instance, Class.prototype);\n                return instance;\n            }).apply(null, arguments);\n        }\n        function wrapNativeSuper_wrapNativeSuper(Class) {\n            var _cache = \"function\" == typeof Map ? new Map : void 0;\n            return (wrapNativeSuper_wrapNativeSuper = function(Class) {\n                if (null === Class || !(fn = Class, -1 !== Function.toString.call(fn).indexOf(\"[native code]\"))) return Class;\n                var fn;\n                if (\"function\" != typeof Class) throw new TypeError(\"Super expression must either be null or a function\");\n                if (void 0 !== _cache) {\n                    if (_cache.has(Class)) return _cache.get(Class);\n                    _cache.set(Class, Wrapper);\n                }\n                function Wrapper() {\n                    return construct_construct(Class, arguments, _getPrototypeOf(this).constructor);\n                }\n                Wrapper.prototype = Object.create(Class.prototype, {\n                    constructor: {\n                        value: Wrapper,\n                        enumerable: !1,\n                        writable: !0,\n                        configurable: !0\n                    }\n                });\n                return _setPrototypeOf(Wrapper, Class);\n            })(Class);\n        }\n        function getFunctionName(fn) {\n            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n        }\n        function setFunctionName(fn, name) {\n            try {\n                delete fn.name;\n                fn.name = name;\n            } catch (err) {}\n            fn.__name__ = fn.displayName = name;\n            return fn;\n        }\n        function base64encode(str) {\n            if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n                return String.fromCharCode(parseInt(p1, 16));\n            })));\n            if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\");\n            throw new Error(\"Can not find window.btoa or Buffer\");\n        }\n        function uniqueID() {\n            var chars = \"0123456789abcdef\";\n            return \"xxxxxxxxxx\".replace(/./g, (function() {\n                return chars.charAt(Math.floor(Math.random() * chars.length));\n            })) + \"_\" + base64encode((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n        }\n        var objectIDs;\n        function serializeArgs(args) {\n            try {\n                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n                        var uid = objectIDs.get(obj);\n                        if (!uid) {\n                            uid = typeof obj + \":\" + uniqueID();\n                            objectIDs.set(obj, uid);\n                        }\n                        return uid;\n                    }(val) + \"]\" : val;\n                }));\n            } catch (err) {\n                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n            }\n        }\n        function getEmptyObject() {\n            return {};\n        }\n        var memoizeGlobalIndex = 0;\n        var memoizeGlobalIndexValidFrom = 0;\n        function memoize(method, options) {\n            void 0 === options && (options = {});\n            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n            var simpleCache;\n            var thisCache;\n            var memoizeIndex = memoizeGlobalIndex;\n            memoizeGlobalIndex += 1;\n            var memoizedFunction = function() {\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n                    simpleCache = null;\n                    thisCache = null;\n                    memoizeIndex = memoizeGlobalIndex;\n                    memoizeGlobalIndex += 1;\n                }\n                var cache;\n                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n                var cacheKey = serializeArgs(args);\n                var cacheResult = cache[cacheKey];\n                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n                    delete cache[cacheKey];\n                    cacheResult = null;\n                }\n                if (cacheResult) return cacheResult.value;\n                var time = Date.now();\n                var value = method.apply(this, arguments);\n                cache[cacheKey] = {\n                    time: time,\n                    value: value\n                };\n                return value;\n            };\n            memoizedFunction.reset = function() {\n                simpleCache = null;\n                thisCache = null;\n            };\n            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n        }\n        memoize.clear = function() {\n            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n        };\n        function memoizePromise(method) {\n            var cache = {};\n            function memoizedPromiseFunction() {\n                var _arguments = arguments, _this = this;\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n                var key = serializeArgs(args);\n                if (cache.hasOwnProperty(key)) return cache[key];\n                cache[key] = promise_ZalgoPromise.try((function() {\n                    return method.apply(_this, _arguments);\n                })).finally((function() {\n                    delete cache[key];\n                }));\n                return cache[key];\n            }\n            memoizedPromiseFunction.reset = function() {\n                cache = {};\n            };\n            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n        }\n        function inlineMemoize(method, logic, args) {\n            void 0 === args && (args = []);\n            var cache = method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {};\n            var key = serializeArgs(args);\n            return cache.hasOwnProperty(key) ? cache[key] : cache[key] = logic.apply(void 0, args);\n        }\n        function src_util_noop() {}\n        function once(method) {\n            var called = !1;\n            return setFunctionName((function() {\n                if (!called) {\n                    called = !0;\n                    return method.apply(this, arguments);\n                }\n            }), getFunctionName(method) + \"::once\");\n        }\n        function stringifyError(err, level) {\n            void 0 === level && (level = 1);\n            if (level >= 3) return \"stringifyError stack overflow\";\n            try {\n                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n                if (\"string\" == typeof err) return err;\n                if (err instanceof Error) {\n                    var stack = err && err.stack;\n                    var message = err && err.message;\n                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n                    if (stack) return stack;\n                    if (message) return message;\n                }\n                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n            } catch (newErr) {\n                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n            }\n        }\n        function stringify(item) {\n            return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n        }\n        function extend(obj, source) {\n            if (!source) return obj;\n            if (Object.assign) return Object.assign(obj, source);\n            for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);\n            return obj;\n        }\n        memoize((function(obj) {\n            if (Object.values) return Object.values(obj);\n            var result = [];\n            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n            return result;\n        }));\n        function identity(item) {\n            return item;\n        }\n        function safeInterval(method, time) {\n            var timeout;\n            !function loop() {\n                timeout = setTimeout((function() {\n                    method();\n                    loop();\n                }), time);\n            }();\n            return {\n                cancel: function() {\n                    clearTimeout(timeout);\n                }\n            };\n        }\n        function defineLazyProp(obj, key, getter) {\n            if (Array.isArray(obj)) {\n                if (\"number\" != typeof key) throw new TypeError(\"Array key must be number\");\n            } else if (\"object\" == typeof obj && null !== obj && \"string\" != typeof key) throw new TypeError(\"Object key must be string\");\n            Object.defineProperty(obj, key, {\n                configurable: !0,\n                enumerable: !0,\n                get: function() {\n                    delete obj[key];\n                    var value = getter();\n                    obj[key] = value;\n                    return value;\n                },\n                set: function(value) {\n                    delete obj[key];\n                    obj[key] = value;\n                }\n            });\n        }\n        function arrayFrom(item) {\n            return [].slice.call(item);\n        }\n        function isObjectObject(obj) {\n            return \"object\" == typeof (item = obj) && null !== item && \"[object Object]\" === {}.toString.call(obj);\n            var item;\n        }\n        function isPlainObject(obj) {\n            if (!isObjectObject(obj)) return !1;\n            var constructor = obj.constructor;\n            if (\"function\" != typeof constructor) return !1;\n            var prototype = constructor.prototype;\n            return !!isObjectObject(prototype) && !!prototype.hasOwnProperty(\"isPrototypeOf\");\n        }\n        function replaceObject(item, replacer, fullKey) {\n            void 0 === fullKey && (fullKey = \"\");\n            if (Array.isArray(item)) {\n                var length = item.length;\n                var result = [];\n                var _loop2 = function(i) {\n                    defineLazyProp(result, i, (function() {\n                        var itemKey = fullKey ? fullKey + \".\" + i : \"\" + i;\n                        var child = replacer(item[i], i, itemKey);\n                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));\n                        return child;\n                    }));\n                };\n                for (var i = 0; i < length; i++) _loop2(i);\n                return result;\n            }\n            if (isPlainObject(item)) {\n                var _result = {};\n                var _loop3 = function(key) {\n                    if (!item.hasOwnProperty(key)) return \"continue\";\n                    defineLazyProp(_result, key, (function() {\n                        var itemKey = fullKey ? fullKey + \".\" + key : \"\" + key;\n                        var child = replacer(item[key], key, itemKey);\n                        (isPlainObject(child) || Array.isArray(child)) && (child = replaceObject(child, replacer, itemKey));\n                        return child;\n                    }));\n                };\n                for (var key in item) _loop3(key);\n                return _result;\n            }\n            throw new Error(\"Pass an object or array\");\n        }\n        function isDefined(value) {\n            return null != value;\n        }\n        function util_isRegex(item) {\n            return \"[object RegExp]\" === {}.toString.call(item);\n        }\n        function util_getOrSet(obj, key, getter) {\n            if (obj.hasOwnProperty(key)) return obj[key];\n            var val = getter();\n            obj[key] = val;\n            return val;\n        }\n        function cleanup(obj) {\n            var tasks = [];\n            var cleaned = !1;\n            var cleanErr;\n            return {\n                set: function(name, item) {\n                    if (!cleaned) {\n                        obj[name] = item;\n                        this.register((function() {\n                            delete obj[name];\n                        }));\n                    }\n                    return item;\n                },\n                register: function(method) {\n                    cleaned ? method(cleanErr) : tasks.push(once((function() {\n                        return method(cleanErr);\n                    })));\n                },\n                all: function(err) {\n                    cleanErr = err;\n                    var results = [];\n                    cleaned = !0;\n                    for (;tasks.length; ) {\n                        var task = tasks.shift();\n                        results.push(task());\n                    }\n                    return promise_ZalgoPromise.all(results).then(src_util_noop);\n                }\n            };\n        }\n        function assertExists(name, thing) {\n            if (null == thing) throw new Error(\"Expected \" + name + \" to be present\");\n            return thing;\n        }\n        var util_ExtendableError = function(_Error) {\n            _inheritsLoose(ExtendableError, _Error);\n            function ExtendableError(message) {\n                var _this6;\n                (_this6 = _Error.call(this, message) || this).name = _this6.constructor.name;\n                \"function\" == typeof Error.captureStackTrace ? Error.captureStackTrace(function(self) {\n                    if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                    return self;\n                }(_this6), _this6.constructor) : _this6.stack = new Error(message).stack;\n                return _this6;\n            }\n            return ExtendableError;\n        }(wrapNativeSuper_wrapNativeSuper(Error));\n        function isDocumentReady() {\n            return Boolean(document.body) && \"complete\" === document.readyState;\n        }\n        function isDocumentInteractive() {\n            return Boolean(document.body) && \"interactive\" === document.readyState;\n        }\n        function urlEncode(str) {\n            return str.replace(/\\?/g, \"%3F\").replace(/&/g, \"%26\").replace(/#/g, \"%23\").replace(/\\+/g, \"%2B\");\n        }\n        memoize((function() {\n            return new promise_ZalgoPromise((function(resolve) {\n                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n                var interval = setInterval((function() {\n                    if (isDocumentReady() || isDocumentInteractive()) {\n                        clearInterval(interval);\n                        return resolve();\n                    }\n                }), 10);\n            }));\n        }));\n        function parseQuery(queryString) {\n            return inlineMemoize(parseQuery, (function() {\n                var params = {};\n                if (!queryString) return params;\n                if (-1 === queryString.indexOf(\"=\")) return params;\n                for (var _i2 = 0, _queryString$split2 = queryString.split(\"&\"); _i2 < _queryString$split2.length; _i2++) {\n                    var pair = _queryString$split2[_i2];\n                    (pair = pair.split(\"=\"))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));\n                }\n                return params;\n            }), [ queryString ]);\n        }\n        function extendQuery(originalQuery, props) {\n            void 0 === props && (props = {});\n            return props && Object.keys(props).length ? function(obj) {\n                void 0 === obj && (obj = {});\n                return Object.keys(obj).filter((function(key) {\n                    return \"string\" == typeof obj[key];\n                })).map((function(key) {\n                    return urlEncode(key) + \"=\" + urlEncode(obj[key]);\n                })).join(\"&\");\n            }(_extends({}, parseQuery(originalQuery), props)) : originalQuery;\n        }\n        function appendChild(container, child) {\n            container.appendChild(child);\n        }\n        function isElement(element) {\n            return element instanceof window.Element || null !== element && \"object\" == typeof element && 1 === element.nodeType && \"object\" == typeof element.style && \"object\" == typeof element.ownerDocument;\n        }\n        function getElementSafe(id, doc) {\n            void 0 === doc && (doc = document);\n            return isElement(id) ? id : \"string\" == typeof id ? doc.querySelector(id) : void 0;\n        }\n        function elementReady(id) {\n            return new promise_ZalgoPromise((function(resolve, reject) {\n                var name = stringify(id);\n                var el = getElementSafe(id);\n                if (el) return resolve(el);\n                if (isDocumentReady()) return reject(new Error(\"Document is ready and element \" + name + \" does not exist\"));\n                var interval = setInterval((function() {\n                    if (el = getElementSafe(id)) {\n                        clearInterval(interval);\n                        return resolve(el);\n                    }\n                    if (isDocumentReady()) {\n                        clearInterval(interval);\n                        return reject(new Error(\"Document is ready and element \" + name + \" does not exist\"));\n                    }\n                }), 10);\n            }));\n        }\n        var dom_PopupOpenError = function(_ExtendableError) {\n            _inheritsLoose(PopupOpenError, _ExtendableError);\n            function PopupOpenError() {\n                return _ExtendableError.apply(this, arguments) || this;\n            }\n            return PopupOpenError;\n        }(util_ExtendableError);\n        var awaitFrameLoadPromises;\n        function awaitFrameLoad(frame) {\n            if ((awaitFrameLoadPromises = awaitFrameLoadPromises || new weakmap_CrossDomainSafeWeakMap).has(frame)) {\n                var _promise = awaitFrameLoadPromises.get(frame);\n                if (_promise) return _promise;\n            }\n            var promise = new promise_ZalgoPromise((function(resolve, reject) {\n                frame.addEventListener(\"load\", (function() {\n                    !function(frame) {\n                        !function() {\n                            for (var i = 0; i < iframeWindows.length; i++) {\n                                var closed = !1;\n                                try {\n                                    closed = iframeWindows[i].closed;\n                                } catch (err) {}\n                                if (closed) {\n                                    iframeFrames.splice(i, 1);\n                                    iframeWindows.splice(i, 1);\n                                }\n                            }\n                        }();\n                        if (frame && frame.contentWindow) try {\n                            iframeWindows.push(frame.contentWindow);\n                            iframeFrames.push(frame);\n                        } catch (err) {}\n                    }(frame);\n                    resolve(frame);\n                }));\n                frame.addEventListener(\"error\", (function(err) {\n                    frame.contentWindow ? resolve(frame) : reject(err);\n                }));\n            }));\n            awaitFrameLoadPromises.set(frame, promise);\n            return promise;\n        }\n        function awaitFrameWindow(frame) {\n            return awaitFrameLoad(frame).then((function(loadedFrame) {\n                if (!loadedFrame.contentWindow) throw new Error(\"Could not find window in iframe\");\n                return loadedFrame.contentWindow;\n            }));\n        }\n        function dom_iframe(options, container) {\n            void 0 === options && (options = {});\n            var style = options.style || {};\n            var frame = function(tag, options, container) {\n                void 0 === tag && (tag = \"div\");\n                void 0 === options && (options = {});\n                tag = tag.toLowerCase();\n                var element = document.createElement(tag);\n                options.style && extend(element.style, options.style);\n                options.class && (element.className = options.class.join(\" \"));\n                options.id && element.setAttribute(\"id\", options.id);\n                if (options.attributes) for (var _i10 = 0, _Object$keys2 = Object.keys(options.attributes); _i10 < _Object$keys2.length; _i10++) {\n                    var key = _Object$keys2[_i10];\n                    element.setAttribute(key, options.attributes[key]);\n                }\n                options.styleSheet && function(el, styleText, doc) {\n                    void 0 === doc && (doc = window.document);\n                    el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));\n                }(element, options.styleSheet);\n                if (options.html) {\n                    if (\"iframe\" === tag) throw new Error(\"Iframe html can not be written unless container provided and iframe in DOM\");\n                    element.innerHTML = options.html;\n                }\n                return element;\n            }(\"iframe\", {\n                attributes: _extends({\n                    allowTransparency: \"true\"\n                }, options.attributes || {}),\n                style: _extends({\n                    backgroundColor: \"transparent\",\n                    border: \"none\"\n                }, style),\n                html: options.html,\n                class: options.class\n            });\n            var isIE = window.navigator.userAgent.match(/MSIE|Edge/i);\n            frame.hasAttribute(\"id\") || frame.setAttribute(\"id\", uniqueID());\n            awaitFrameLoad(frame);\n            container && function(id, doc) {\n                void 0 === doc && (doc = document);\n                var element = getElementSafe(id, doc);\n                if (element) return element;\n                throw new Error(\"Can not find element: \" + stringify(id));\n            }(container).appendChild(frame);\n            (options.url || isIE) && frame.setAttribute(\"src\", options.url || \"about:blank\");\n            return frame;\n        }\n        function addEventListener(obj, event, handler) {\n            obj.addEventListener(event, handler);\n            return {\n                cancel: function() {\n                    obj.removeEventListener(event, handler);\n                }\n            };\n        }\n        function showElement(element) {\n            element.style.setProperty(\"display\", \"\");\n        }\n        function hideElement(element) {\n            element.style.setProperty(\"display\", \"none\", \"important\");\n        }\n        function destroyElement(element) {\n            element && element.parentNode && element.parentNode.removeChild(element);\n        }\n        function isElementClosed(el) {\n            return !(el && el.parentNode && el.ownerDocument && el.ownerDocument.documentElement && el.ownerDocument.documentElement.contains(el));\n        }\n        function onResize(el, handler, _temp) {\n            var _ref2 = void 0 === _temp ? {} : _temp, _ref2$width = _ref2.width, width = void 0 === _ref2$width || _ref2$width, _ref2$height = _ref2.height, height = void 0 === _ref2$height || _ref2$height, _ref2$interval = _ref2.interval, interval = void 0 === _ref2$interval ? 100 : _ref2$interval, _ref2$win = _ref2.win, win = void 0 === _ref2$win ? window : _ref2$win;\n            var currentWidth = el.offsetWidth;\n            var currentHeight = el.offsetHeight;\n            var canceled = !1;\n            handler({\n                width: currentWidth,\n                height: currentHeight\n            });\n            var check = function() {\n                if (!canceled && function(el) {\n                    return Boolean(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n                }(el)) {\n                    var newWidth = el.offsetWidth;\n                    var newHeight = el.offsetHeight;\n                    (width && newWidth !== currentWidth || height && newHeight !== currentHeight) && handler({\n                        width: newWidth,\n                        height: newHeight\n                    });\n                    currentWidth = newWidth;\n                    currentHeight = newHeight;\n                }\n            };\n            var observer;\n            var timeout;\n            win.addEventListener(\"resize\", check);\n            if (void 0 !== win.ResizeObserver) {\n                (observer = new win.ResizeObserver(check)).observe(el);\n                timeout = safeInterval(check, 10 * interval);\n            } else if (void 0 !== win.MutationObserver) {\n                (observer = new win.MutationObserver(check)).observe(el, {\n                    attributes: !0,\n                    childList: !0,\n                    subtree: !0,\n                    characterData: !1\n                });\n                timeout = safeInterval(check, 10 * interval);\n            } else timeout = safeInterval(check, interval);\n            return {\n                cancel: function() {\n                    canceled = !0;\n                    observer.disconnect();\n                    window.removeEventListener(\"resize\", check);\n                    timeout.cancel();\n                }\n            };\n        }\n        function isShadowElement(element) {\n            for (;element.parentNode; ) element = element.parentNode;\n            return \"[object ShadowRoot]\" === element.toString();\n        }\n        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n        var getCurrentScript = memoize((function() {\n            if (currentScript) return currentScript;\n            if (currentScript = function() {\n                try {\n                    var stack = function() {\n                        try {\n                            throw new Error(\"_\");\n                        } catch (err) {\n                            return err.stack || \"\";\n                        }\n                    }();\n                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n                    var scriptLocation = stackDetails && stackDetails[1];\n                    if (!scriptLocation) return;\n                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n                        var script = _Array$prototype$slic2[_i22];\n                        if (script.src && script.src === scriptLocation) return script;\n                    }\n                } catch (err) {}\n            }()) return currentScript;\n            throw new Error(\"Can not determine current script\");\n        }));\n        var currentUID = uniqueID();\n        memoize((function() {\n            var script;\n            try {\n                script = getCurrentScript();\n            } catch (err) {\n                return currentUID;\n            }\n            var uid = script.getAttribute(\"data-uid\");\n            if (uid && \"string\" == typeof uid) return uid;\n            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n            uid = uniqueID();\n            script.setAttribute(\"data-uid-auto\", uid);\n            return uid;\n        }));\n        function toPx(val) {\n            return function(val) {\n                if (\"number\" == typeof val) return val;\n                var match = val.match(/^([0-9]+)(px|%)$/);\n                if (!match) throw new Error(\"Could not match css value from \" + val);\n                return parseInt(match[1], 10);\n            }(val) + \"px\";\n        }\n        function toCSS(val) {\n            return \"number\" == typeof val ? toPx(val) : \"string\" == typeof (str = val) && /^[0-9]+%$/.test(str) ? val : toPx(val);\n            var str;\n        }\n        function global_getGlobal(win) {\n            void 0 === win && (win = window);\n            var globalKey = \"__post_robot_10_0_42__\";\n            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n        }\n        var getObj = function() {\n            return {};\n        };\n        function globalStore(key, defStore) {\n            void 0 === key && (key = \"store\");\n            void 0 === defStore && (defStore = getObj);\n            return util_getOrSet(global_getGlobal(), key, (function() {\n                var store = defStore();\n                return {\n                    has: function(storeKey) {\n                        return store.hasOwnProperty(storeKey);\n                    },\n                    get: function(storeKey, defVal) {\n                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n                    },\n                    set: function(storeKey, val) {\n                        store[storeKey] = val;\n                        return val;\n                    },\n                    del: function(storeKey) {\n                        delete store[storeKey];\n                    },\n                    getOrSet: function(storeKey, getter) {\n                        return util_getOrSet(store, storeKey, getter);\n                    },\n                    reset: function() {\n                        store = defStore();\n                    },\n                    keys: function() {\n                        return Object.keys(store);\n                    }\n                };\n            }));\n        }\n        var WildCard = function() {};\n        function getWildcard() {\n            var global = global_getGlobal();\n            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n            return global.WINDOW_WILDCARD;\n        }\n        function windowStore(key, defStore) {\n            void 0 === key && (key = \"store\");\n            void 0 === defStore && (defStore = getObj);\n            return globalStore(\"windowStore\").getOrSet(key, (function() {\n                var winStore = new weakmap_CrossDomainSafeWeakMap;\n                var getStore = function(win) {\n                    return winStore.getOrSet(win, defStore);\n                };\n                return {\n                    has: function(win) {\n                        return getStore(win).hasOwnProperty(key);\n                    },\n                    get: function(win, defVal) {\n                        var store = getStore(win);\n                        return store.hasOwnProperty(key) ? store[key] : defVal;\n                    },\n                    set: function(win, val) {\n                        getStore(win)[key] = val;\n                        return val;\n                    },\n                    del: function(win) {\n                        delete getStore(win)[key];\n                    },\n                    getOrSet: function(win, getter) {\n                        return util_getOrSet(getStore(win), key, getter);\n                    }\n                };\n            }));\n        }\n        function getInstanceID() {\n            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n        }\n        function resolveHelloPromise(win, _ref) {\n            var domain = _ref.domain;\n            var helloPromises = windowStore(\"helloPromises\");\n            var existingPromise = helloPromises.get(win);\n            existingPromise && existingPromise.resolve({\n                domain: domain\n            });\n            var newPromise = promise_ZalgoPromise.resolve({\n                domain: domain\n            });\n            helloPromises.set(win, newPromise);\n            return newPromise;\n        }\n        function sayHello(win, _ref4) {\n            return (0, _ref4.send)(win, \"postrobot_hello\", {\n                instanceID: getInstanceID()\n            }, {\n                domain: \"*\",\n                timeout: -1\n            }).then((function(_ref5) {\n                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n                resolveHelloPromise(win, {\n                    domain: origin\n                });\n                return {\n                    win: win,\n                    domain: origin,\n                    instanceID: instanceID\n                };\n            }));\n        }\n        function getWindowInstanceID(win, _ref6) {\n            var send = _ref6.send;\n            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n                return sayHello(win, {\n                    send: send\n                }).then((function(_ref7) {\n                    return _ref7.instanceID;\n                }));\n            }));\n        }\n        function markWindowKnown(win) {\n            windowStore(\"knownWindows\").set(win, !0);\n        }\n        function isSerializedType(item) {\n            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n        }\n        function determineType(val) {\n            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n        }\n        function serializeType(type, val) {\n            return {\n                __type__: type,\n                __val__: val\n            };\n        }\n        var _SERIALIZER;\n        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n            return serializeType(\"error\", {\n                message: _ref.message,\n                stack: _ref.stack,\n                code: _ref.code,\n                data: _ref.data\n            });\n        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n            return serializeType(\"regex\", val.source);\n        }, _SERIALIZER.date = function(val) {\n            return serializeType(\"date\", val.toJSON());\n        }, _SERIALIZER.array = function(val) {\n            return val;\n        }, _SERIALIZER.object = function(val) {\n            return val;\n        }, _SERIALIZER.string = function(val) {\n            return val;\n        }, _SERIALIZER.number = function(val) {\n            return val;\n        }, _SERIALIZER.boolean = function(val) {\n            return val;\n        }, _SERIALIZER.null = function(val) {\n            return val;\n        }, _SERIALIZER);\n        var defaultSerializers = {};\n        var _DESERIALIZER;\n        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n        }, _DESERIALIZER.error = function(_ref2) {\n            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n            var error = new Error(_ref2.message);\n            error.code = code;\n            data && (error.data = data);\n            error.stack = stack + \"\\n\\n\" + error.stack;\n            return error;\n        }, _DESERIALIZER.promise = function() {\n            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n        }, _DESERIALIZER.regex = function(val) {\n            return new RegExp(val);\n        }, _DESERIALIZER.date = function(val) {\n            return new Date(val);\n        }, _DESERIALIZER.array = function(val) {\n            return val;\n        }, _DESERIALIZER.object = function(val) {\n            return val;\n        }, _DESERIALIZER.string = function(val) {\n            return val;\n        }, _DESERIALIZER.number = function(val) {\n            return val;\n        }, _DESERIALIZER.boolean = function(val) {\n            return val;\n        }, _DESERIALIZER.null = function(val) {\n            return val;\n        }, _DESERIALIZER);\n        var defaultDeserializers = {};\n        new promise_ZalgoPromise((function(resolve) {\n            if (window.document && window.document.body) return resolve(window.document.body);\n            var interval = setInterval((function() {\n                if (window.document && window.document.body) {\n                    clearInterval(interval);\n                    return resolve(window.document.body);\n                }\n            }), 10);\n        }));\n        function cleanupProxyWindows() {\n            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n                var id = _idToProxyWindow$keys2[_i2];\n                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n            }\n        }\n        function getSerializedWindow(winPromise, _ref) {\n            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n            var windowNamePromise = winPromise.then((function(win) {\n                if (isSameDomain(win)) return assertSameDomain(win).name;\n            }));\n            var windowTypePromise = winPromise.then((function(window) {\n                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n                return getOpener(window) ? WINDOW_TYPE.POPUP : WINDOW_TYPE.IFRAME;\n            }));\n            windowNamePromise.catch(src_util_noop);\n            windowTypePromise.catch(src_util_noop);\n            return {\n                id: id,\n                getType: function() {\n                    return windowTypePromise;\n                },\n                getInstanceID: memoizePromise((function() {\n                    return winPromise.then((function(win) {\n                        return getWindowInstanceID(win, {\n                            send: send\n                        });\n                    }));\n                })),\n                close: function() {\n                    return winPromise.then(closeWindow);\n                },\n                getName: function() {\n                    return winPromise.then((function(win) {\n                        if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n                    }));\n                },\n                focus: function() {\n                    return winPromise.then((function(win) {\n                        win.focus();\n                    }));\n                },\n                isClosed: function() {\n                    return winPromise.then((function(win) {\n                        return isWindowClosed(win);\n                    }));\n                },\n                setLocation: function(href) {\n                    return winPromise.then((function(win) {\n                        var domain = window.location.protocol + \"//\" + window.location.host;\n                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n                        if (isSameDomain(win)) try {\n                            if (win.location && \"function\" == typeof win.location.replace) {\n                                win.location.replace(href);\n                                return;\n                            }\n                        } catch (err) {}\n                        win.location = href;\n                    }));\n                },\n                setName: function(name) {\n                    return winPromise.then((function(win) {\n                        var sameDomain = isSameDomain(win);\n                        var frame = function(win) {\n                            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n                            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n                                var frame = _document$querySelect2[_i21];\n                                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n                            }\n                        }(win);\n                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n                        assertSameDomain(win).name = name;\n                        frame && frame.setAttribute(\"name\", name);\n                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n                    }));\n                }\n            };\n        }\n        var window_ProxyWindow = function() {\n            function ProxyWindow(_ref2) {\n                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n                this.id = void 0;\n                this.isProxyWindow = !0;\n                this.serializedWindow = void 0;\n                this.actualWindow = void 0;\n                this.actualWindowPromise = void 0;\n                this.send = void 0;\n                this.name = void 0;\n                this.actualWindowPromise = new promise_ZalgoPromise;\n                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n                    send: send\n                });\n                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n                win && this.setWindow(win, {\n                    send: send\n                });\n            }\n            var _proto = ProxyWindow.prototype;\n            _proto.getID = function() {\n                return this.serializedWindow.id;\n            };\n            _proto.getType = function() {\n                return this.serializedWindow.getType();\n            };\n            _proto.isPopup = function() {\n                return this.getType().then((function(type) {\n                    return type === WINDOW_TYPE.POPUP;\n                }));\n            };\n            _proto.setLocation = function(href) {\n                var _this = this;\n                return this.serializedWindow.setLocation(href).then((function() {\n                    return _this;\n                }));\n            };\n            _proto.getName = function() {\n                return this.serializedWindow.getName();\n            };\n            _proto.setName = function(name) {\n                var _this2 = this;\n                return this.serializedWindow.setName(name).then((function() {\n                    return _this2;\n                }));\n            };\n            _proto.close = function() {\n                var _this3 = this;\n                return this.serializedWindow.close().then((function() {\n                    return _this3;\n                }));\n            };\n            _proto.focus = function() {\n                var _this4 = this;\n                var isPopupPromise = this.isPopup();\n                var getNamePromise = this.getName();\n                var reopenPromise = promise_ZalgoPromise.hash({\n                    isPopup: isPopupPromise,\n                    name: getNamePromise\n                }).then((function(_ref3) {\n                    var name = _ref3.name;\n                    _ref3.isPopup && name && window.open(\"\", name);\n                }));\n                var focusPromise = this.serializedWindow.focus();\n                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n                    return _this4;\n                }));\n            };\n            _proto.isClosed = function() {\n                return this.serializedWindow.isClosed();\n            };\n            _proto.getWindow = function() {\n                return this.actualWindow;\n            };\n            _proto.setWindow = function(win, _ref4) {\n                var send = _ref4.send;\n                this.actualWindow = win;\n                this.actualWindowPromise.resolve(this.actualWindow);\n                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n                    send: send,\n                    id: this.getID()\n                });\n                windowStore(\"winToProxyWindow\").set(win, this);\n            };\n            _proto.awaitWindow = function() {\n                return this.actualWindowPromise;\n            };\n            _proto.matchWindow = function(win, _ref5) {\n                var _this5 = this;\n                var send = _ref5.send;\n                return promise_ZalgoPromise.try((function() {\n                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n                        proxyInstanceID: _this5.getInstanceID(),\n                        knownWindowInstanceID: getWindowInstanceID(win, {\n                            send: send\n                        })\n                    }).then((function(_ref6) {\n                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n                        match && _this5.setWindow(win, {\n                            send: send\n                        });\n                        return match;\n                    }));\n                }));\n            };\n            _proto.unwrap = function() {\n                return this.actualWindow || this;\n            };\n            _proto.getInstanceID = function() {\n                return this.serializedWindow.getInstanceID();\n            };\n            _proto.shouldClean = function() {\n                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n            };\n            _proto.serialize = function() {\n                return this.serializedWindow;\n            };\n            ProxyWindow.unwrap = function(win) {\n                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n            };\n            ProxyWindow.serialize = function(win, _ref7) {\n                var send = _ref7.send;\n                cleanupProxyWindows();\n                return ProxyWindow.toProxyWindow(win, {\n                    send: send\n                }).serialize();\n            };\n            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n                var send = _ref8.send;\n                cleanupProxyWindows();\n                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n                    serializedWindow: serializedWindow,\n                    send: send\n                });\n            };\n            ProxyWindow.isProxyWindow = function(obj) {\n                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n            };\n            ProxyWindow.toProxyWindow = function(win, _ref9) {\n                var send = _ref9.send;\n                cleanupProxyWindows();\n                if (ProxyWindow.isProxyWindow(win)) return win;\n                var actualWindow = win;\n                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n                    win: actualWindow,\n                    send: send\n                });\n            };\n            return ProxyWindow;\n        }();\n        function addMethod(id, val, name, source, domain) {\n            var methodStore = windowStore(\"methodStore\");\n            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n                val: val,\n                name: name,\n                domain: domain,\n                source: source\n            }); else {\n                proxyWindowMethods.del(id);\n                methodStore.getOrSet(source, (function() {\n                    return {};\n                }))[id] = {\n                    domain: domain,\n                    name: name,\n                    val: val,\n                    source: source\n                };\n            }\n        }\n        function lookupMethod(source, id) {\n            var methodStore = windowStore(\"methodStore\");\n            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n            return methodStore.getOrSet(source, (function() {\n                return {};\n            }))[id] || proxyWindowMethods.get(id);\n        }\n        function function_serializeFunction(destination, domain, val, key, _ref3) {\n            on = (_ref = {\n                on: _ref3.on,\n                send: _ref3.send\n            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n                return on(\"postrobot_method\", {\n                    domain: \"*\"\n                }, (function(_ref2) {\n                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n                    var id = data.id, name = data.name;\n                    var meth = lookupMethod(source, id);\n                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n                    return promise_ZalgoPromise.try((function() {\n                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n                            send: send\n                        }).then((function(match) {\n                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n                        }));\n                    })).then((function() {\n                        return val.apply({\n                            source: source,\n                            origin: origin\n                        }, data.args);\n                    }), (function(err) {\n                        return promise_ZalgoPromise.try((function() {\n                            if (val.onError) return val.onError(err);\n                        })).then((function() {\n                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n                                void 0 === args && (args = []);\n                                return arrayFrom(args).map((function(arg) {\n                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n                                })).join(\", \");\n                            }(data.args) + \") failed\\n\\n\" + err.stack);\n                            throw err;\n                        }));\n                    })).then((function(result) {\n                        return {\n                            result: result,\n                            id: id,\n                            name: name\n                        };\n                    }));\n                }));\n            }));\n            var _ref, on, send;\n            var id = val.__id__ || uniqueID();\n            destination = window_ProxyWindow.unwrap(destination);\n            var name = val.__name__ || val.name || key;\n            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n            if (window_ProxyWindow.isProxyWindow(destination)) {\n                addMethod(id, val, name, destination, domain);\n                destination.awaitWindow().then((function(win) {\n                    addMethod(id, val, name, win, domain);\n                }));\n            } else addMethod(id, val, name, destination, domain);\n            return serializeType(\"cross_domain_function\", {\n                id: id,\n                name: name\n            });\n        }\n        function serializeMessage(destination, domain, obj, _ref) {\n            var _serialize;\n            var on = _ref.on, send = _ref.send;\n            return function(obj, serializers) {\n                void 0 === serializers && (serializers = defaultSerializers);\n                var result = JSON.stringify(obj, (function(key) {\n                    var val = this[key];\n                    if (isSerializedType(this)) return val;\n                    var type = determineType(val);\n                    if (!type) return val;\n                    var serializer = serializers[type] || SERIALIZER[type];\n                    return serializer ? serializer(val, key) : val;\n                }));\n                return void 0 === result ? \"undefined\" : result;\n            }(obj, ((_serialize = {}).promise = function(val, key) {\n                return function(destination, domain, val, key, _ref) {\n                    return serializeType(\"cross_domain_zalgo_promise\", {\n                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n                            return val.then(resolve, reject);\n                        }), key, {\n                            on: _ref.on,\n                            send: _ref.send\n                        })\n                    });\n                }(destination, domain, val, key, {\n                    on: on,\n                    send: send\n                });\n            }, _serialize.function = function(val, key) {\n                return function_serializeFunction(destination, domain, val, key, {\n                    on: on,\n                    send: send\n                });\n            }, _serialize.object = function(val) {\n                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n                    send: send\n                })) : val;\n            }, _serialize));\n        }\n        function deserializeMessage(source, origin, message, _ref2) {\n            var _deserialize;\n            var send = _ref2.send;\n            return function(str, deserializers) {\n                void 0 === deserializers && (deserializers = defaultDeserializers);\n                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n                    if (isSerializedType(this)) return val;\n                    var type;\n                    var value;\n                    if (isSerializedType(val)) {\n                        type = val.__type__;\n                        value = val.__val__;\n                    } else {\n                        type = determineType(val);\n                        value = val;\n                    }\n                    if (!type) return value;\n                    var deserializer = deserializers[type] || DESERIALIZER[type];\n                    return deserializer ? deserializer(value, key) : value;\n                }));\n            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n                return function(source, origin, _ref2) {\n                    return new promise_ZalgoPromise(_ref2.then);\n                }(0, 0, serializedPromise);\n            }, _deserialize.cross_domain_function = function(serializedFunction) {\n                return function(source, origin, _ref4, _ref5) {\n                    var id = _ref4.id, name = _ref4.name;\n                    var send = _ref5.send;\n                    var getDeserializedFunction = function(opts) {\n                        void 0 === opts && (opts = {});\n                        function crossDomainFunctionWrapper() {\n                            var _arguments = arguments;\n                            return window_ProxyWindow.toProxyWindow(source, {\n                                send: send\n                            }).awaitWindow().then((function(win) {\n                                var meth = lookupMethod(win, id);\n                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n                                    source: window,\n                                    origin: getDomain()\n                                }, _arguments);\n                                var _args = [].slice.call(_arguments);\n                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n                                    id: id,\n                                    name: name,\n                                    args: _args\n                                }, {\n                                    domain: origin,\n                                    fireAndForget: !0\n                                }) : send(win, \"postrobot_method\", {\n                                    id: id,\n                                    name: name,\n                                    args: _args\n                                }, {\n                                    domain: origin,\n                                    fireAndForget: !1\n                                }).then((function(res) {\n                                    return res.data.result;\n                                }));\n                            })).catch((function(err) {\n                                throw err;\n                            }));\n                        }\n                        crossDomainFunctionWrapper.__name__ = name;\n                        crossDomainFunctionWrapper.__origin__ = origin;\n                        crossDomainFunctionWrapper.__source__ = source;\n                        crossDomainFunctionWrapper.__id__ = id;\n                        crossDomainFunctionWrapper.origin = origin;\n                        return crossDomainFunctionWrapper;\n                    };\n                    var crossDomainFunctionWrapper = getDeserializedFunction();\n                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n                        fireAndForget: !0\n                    });\n                    return crossDomainFunctionWrapper;\n                }(source, origin, serializedFunction, {\n                    send: send\n                });\n            }, _deserialize.cross_domain_window = function(serializedWindow) {\n                return window_ProxyWindow.deserialize(serializedWindow, {\n                    send: send\n                });\n            }, _deserialize));\n        }\n        var SEND_MESSAGE_STRATEGIES = {};\n        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n            win.postMessage(serializedMessage, domain);\n        };\n        SEND_MESSAGE_STRATEGIES.postrobot_global = function(win, serializedMessage) {\n            if (!function(win) {\n                return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;\n            }(window).match(/MSIE|rv:11|trident|edge\\/12|edge\\/13/i)) throw new Error(\"Global messaging not needed for browser\");\n            if (!isSameDomain(win)) throw new Error(\"Post message through global disabled between different domain windows\");\n            if (!1 !== isSameTopWindow(window, win)) throw new Error(\"Can only use global to communicate between two different windows, not between frames\");\n            var foreignGlobal = global_getGlobal(win);\n            if (!foreignGlobal) throw new Error(\"Can not find postRobot global on foreign window\");\n            foreignGlobal.receiveMessage({\n                source: window,\n                origin: getDomain(),\n                data: serializedMessage\n            });\n        };\n        function send_sendMessage(win, domain, message, _ref2) {\n            var on = _ref2.on, send = _ref2.send;\n            return promise_ZalgoPromise.try((function() {\n                var domainBuffer = windowStore().getOrSet(win, (function() {\n                    return {};\n                }));\n                domainBuffer.buffer = domainBuffer.buffer || [];\n                domainBuffer.buffer.push(message);\n                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_42__ = domainBuffer.buffer || [], \n                    _ref), {\n                        on: on,\n                        send: send\n                    });\n                    var _ref;\n                    delete domainBuffer.buffer;\n                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n                    var errors = [];\n                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n                        var strategyName = strategies[_i2];\n                        try {\n                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n                        } catch (err) {\n                            errors.push(err);\n                        }\n                    }\n                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n                        return i + \". \" + stringifyError(err);\n                    })).join(\"\\n\\n\"));\n                }));\n                return domainBuffer.flush.then((function() {\n                    delete domainBuffer.flush;\n                }));\n            })).then(src_util_noop);\n        }\n        function getResponseListener(hash) {\n            return globalStore(\"responseListeners\").get(hash);\n        }\n        function deleteResponseListener(hash) {\n            globalStore(\"responseListeners\").del(hash);\n        }\n        function isResponseListenerErrored(hash) {\n            return globalStore(\"erroredResponseListeners\").has(hash);\n        }\n        function getRequestListener(_ref) {\n            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n            var requestListeners = windowStore(\"requestListeners\");\n            \"*\" === win && (win = null);\n            \"*\" === domain && (domain = null);\n            if (!name) throw new Error(\"Name required to get request listener\");\n            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n                var winQualifier = _ref3[_i4];\n                if (winQualifier) {\n                    var nameListeners = requestListeners.get(winQualifier);\n                    if (nameListeners) {\n                        var domainListeners = nameListeners[name];\n                        if (domainListeners) {\n                            if (domain && \"string\" == typeof domain) {\n                                if (domainListeners[domain]) return domainListeners[domain];\n                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n                                }\n                            }\n                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n                        }\n                    }\n                }\n            }\n        }\n        function handleRequest(source, origin, message, _ref) {\n            var on = _ref.on, send = _ref.send;\n            var options = getRequestListener({\n                name: message.name,\n                win: source,\n                domain: origin\n            });\n            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n            function sendResponse(ack, data, error) {\n                return promise_ZalgoPromise.flush().then((function() {\n                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n                        return send_sendMessage(source, origin, {\n                            id: uniqueID(),\n                            origin: getDomain(window),\n                            type: \"postrobot_message_response\",\n                            hash: message.hash,\n                            name: message.name,\n                            ack: ack,\n                            data: data,\n                            error: error\n                        }, {\n                            on: on,\n                            send: send\n                        });\n                    } catch (err) {\n                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n                    }\n                }));\n            }\n            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n                if (!message.fireAndForget && !isWindowClosed(source)) try {\n                    return send_sendMessage(source, origin, {\n                        id: uniqueID(),\n                        origin: getDomain(window),\n                        type: \"postrobot_message_ack\",\n                        hash: message.hash,\n                        name: message.name\n                    }, {\n                        on: on,\n                        send: send\n                    });\n                } catch (err) {\n                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n                }\n            })), promise_ZalgoPromise.try((function() {\n                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n                if (!matchDomain(options.domain, origin)) throw new Error(\"Request origin \" + origin + \" does not match domain \" + options.domain.toString());\n                return options.handler({\n                    source: source,\n                    origin: origin,\n                    data: message.data\n                });\n            })).then((function(data) {\n                return sendResponse(\"success\", data);\n            }), (function(error) {\n                return sendResponse(\"error\", null, error);\n            })) ]).then(src_util_noop).catch((function(err) {\n                if (options && options.handleError) return options.handleError(err);\n                throw err;\n            }));\n        }\n        function handleAck(source, origin, message) {\n            if (!isResponseListenerErrored(message.hash)) {\n                var options = getResponseListener(message.hash);\n                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n                try {\n                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n                } catch (err) {\n                    options.promise.reject(err);\n                }\n                options.ack = !0;\n            }\n        }\n        function handleResponse(source, origin, message) {\n            if (!isResponseListenerErrored(message.hash)) {\n                var options = getResponseListener(message.hash);\n                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() : pattern.toString()));\n                var pattern;\n                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n                deleteResponseListener(message.hash);\n                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n                    source: source,\n                    origin: origin,\n                    data: message.data\n                });\n            }\n        }\n        function receive_receiveMessage(event, _ref2) {\n            var on = _ref2.on, send = _ref2.send;\n            var receivedMessages = globalStore(\"receivedMessages\");\n            try {\n                if (!window || window.closed || !event.source) return;\n            } catch (err) {\n                return;\n            }\n            var source = event.source, origin = event.origin;\n            var messages = function(message, source, origin, _ref) {\n                var on = _ref.on, send = _ref.send;\n                var parsedMessage;\n                try {\n                    parsedMessage = deserializeMessage(source, origin, message, {\n                        on: on,\n                        send: send\n                    });\n                } catch (err) {\n                    return;\n                }\n                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n                    var parseMessages = parsedMessage.__post_robot_10_0_42__;\n                    if (Array.isArray(parseMessages)) return parseMessages;\n                }\n            }(event.data, source, origin, {\n                on: on,\n                send: send\n            });\n            if (messages) {\n                markWindowKnown(source);\n                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n                    var message = messages[_i2];\n                    if (receivedMessages.has(message.id)) return;\n                    receivedMessages.set(message.id, !0);\n                    if (isWindowClosed(source) && !message.fireAndForget) return;\n                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n                    try {\n                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n                            on: on,\n                            send: send\n                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n                    } catch (err) {\n                        setTimeout((function() {\n                            throw err;\n                        }), 0);\n                    }\n                }\n            }\n        }\n        function on_on(name, options, handler) {\n            if (!name) throw new Error(\"Expected name\");\n            if (\"function\" == typeof (options = options || {})) {\n                handler = options;\n                options = {};\n            }\n            if (!handler) throw new Error(\"Expected handler\");\n            (options = options || {}).name = name;\n            options.handler = handler || options.handler;\n            var win = options.window;\n            var domain = options.domain;\n            var requestListener = function addRequestListener(_ref4, listener) {\n                var name = _ref4.name, win = _ref4.win, domain = _ref4.domain;\n                var requestListeners = windowStore(\"requestListeners\");\n                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n                if (Array.isArray(win)) {\n                    var listenersCollection = [];\n                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n                        name: name,\n                        domain: domain,\n                        win: _win2[_i8]\n                    }, listener));\n                    return {\n                        cancel: function() {\n                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n                        }\n                    };\n                }\n                if (Array.isArray(domain)) {\n                    var _listenersCollection = [];\n                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n                        name: name,\n                        win: win,\n                        domain: _domain2[_i12]\n                    }, listener));\n                    return {\n                        cancel: function() {\n                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n                        }\n                    };\n                }\n                var existingListener = getRequestListener({\n                    name: name,\n                    win: win,\n                    domain: domain\n                });\n                win && \"*\" !== win || (win = getWildcard());\n                domain = domain || \"*\";\n                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n                var nameListeners = requestListeners.getOrSet(win, (function() {\n                    return {};\n                }));\n                var domainListeners = util_getOrSet(nameListeners, name, (function() {\n                    return {};\n                }));\n                var strDomain = domain.toString();\n                var regexListeners;\n                var regexListener;\n                util_isRegex(domain) ? (regexListeners = util_getOrSet(domainListeners, \"__domain_regex__\", (function() {\n                    return [];\n                }))).push(regexListener = {\n                    regex: domain,\n                    listener: listener\n                }) : domainListeners[strDomain] = listener;\n                return {\n                    cancel: function() {\n                        delete domainListeners[strDomain];\n                        if (regexListener) {\n                            regexListeners.splice(regexListeners.indexOf(regexListener, 1));\n                            regexListeners.length || delete domainListeners.__domain_regex__;\n                        }\n                        Object.keys(domainListeners).length || delete nameListeners[name];\n                        win && !Object.keys(nameListeners).length && requestListeners.del(win);\n                    }\n                };\n            }({\n                name: name,\n                win: win,\n                domain: domain\n            }, {\n                handler: options.handler,\n                handleError: options.errorHandler || function(err) {\n                    throw err;\n                },\n                window: win,\n                domain: domain || \"*\",\n                name: name\n            });\n            return {\n                cancel: function() {\n                    requestListener.cancel();\n                }\n            };\n        }\n        var send_send = function send(win, name, data, options) {\n            var domainMatcher = (options = options || {}).domain || \"*\";\n            var responseTimeout = options.timeout || -1;\n            var childTimeout = options.timeout || 5e3;\n            var fireAndForget = options.fireAndForget || !1;\n            return promise_ZalgoPromise.try((function() {\n                !function(name, win, domain) {\n                    if (!name) throw new Error(\"Expected name\");\n                    if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n                    if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n                }(name, win, domainMatcher);\n                if (function(parent, child) {\n                    var actualParent = getAncestor(child);\n                    if (actualParent) return actualParent === parent;\n                    if (child === parent) return !1;\n                    if (getTop(child) === child) return !1;\n                    for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n                    return !1;\n                }(window, win)) return function(win, timeout, name) {\n                    void 0 === timeout && (timeout = 5e3);\n                    void 0 === name && (name = \"Window\");\n                    var promise = function(win) {\n                        return windowStore(\"helloPromises\").getOrSet(win, (function() {\n                            return new promise_ZalgoPromise;\n                        }));\n                    }(win);\n                    -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n                    return promise;\n                }(win, childTimeout);\n            })).then((function(_temp) {\n                return function(win, targetDomain, actualDomain, _ref) {\n                    var send = _ref.send;\n                    return promise_ZalgoPromise.try((function() {\n                        return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n                            return actualDomain || sayHello(win, {\n                                send: send\n                            }).then((function(_ref2) {\n                                return _ref2.domain;\n                            }));\n                        })).then((function(normalizedDomain) {\n                            if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n                            return normalizedDomain;\n                        }));\n                    }));\n                }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n                    send: send\n                });\n            })).then((function(targetDomain) {\n                var domain = targetDomain;\n                var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n                var promise = new promise_ZalgoPromise;\n                var hash = name + \"_\" + uniqueID();\n                if (!fireAndForget) {\n                    var responseListener = {\n                        name: name,\n                        win: win,\n                        domain: domain,\n                        promise: promise\n                    };\n                    !function(hash, listener) {\n                        globalStore(\"responseListeners\").set(hash, listener);\n                    }(hash, responseListener);\n                    var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n                        return [];\n                    }));\n                    reqPromises.push(promise);\n                    promise.catch((function() {\n                        !function(hash) {\n                            globalStore(\"erroredResponseListeners\").set(hash, !0);\n                        }(hash);\n                        deleteResponseListener(hash);\n                    }));\n                    var totalAckTimeout = function(win) {\n                        return windowStore(\"knownWindows\").get(win, !1);\n                    }(win) ? 1e4 : 2e3;\n                    var totalResTimeout = responseTimeout;\n                    var ackTimeout = totalAckTimeout;\n                    var resTimeout = totalResTimeout;\n                    var interval = safeInterval((function() {\n                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n                        ackTimeout = Math.max(ackTimeout - 500, 0);\n                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n                        return responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout ? promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : void 0 : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n                    }), 500);\n                    promise.finally((function() {\n                        interval.cancel();\n                        reqPromises.splice(reqPromises.indexOf(promise, 1));\n                    })).catch(src_util_noop);\n                }\n                return send_sendMessage(win, domain, {\n                    id: uniqueID(),\n                    origin: getDomain(window),\n                    type: \"postrobot_message_request\",\n                    hash: hash,\n                    name: name,\n                    data: data,\n                    fireAndForget: fireAndForget\n                }, {\n                    on: on_on,\n                    send: send\n                }).then((function() {\n                    return fireAndForget ? promise.resolve() : promise;\n                }), (function(err) {\n                    throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n                }));\n            }));\n        };\n        function setup_serializeMessage(destination, domain, obj) {\n            return serializeMessage(destination, domain, obj, {\n                on: on_on,\n                send: send_send\n            });\n        }\n        function setup_deserializeMessage(source, origin, message) {\n            return deserializeMessage(source, origin, message, {\n                on: on_on,\n                send: send_send\n            });\n        }\n        function setup_toProxyWindow(win) {\n            return window_ProxyWindow.toProxyWindow(win, {\n                send: send_send\n            });\n        }\n        function lib_global_getGlobal(win) {\n            void 0 === win && (win = window);\n            if (!isSameDomain(win)) throw new Error(\"Can not get global for window on different domain\");\n            win.__zoid_9_0_63__ || (win.__zoid_9_0_63__ = {});\n            return win.__zoid_9_0_63__;\n        }\n        function getProxyObject(obj) {\n            return {\n                get: function() {\n                    var _this = this;\n                    return promise_ZalgoPromise.try((function() {\n                        if (_this.source && _this.source !== window) throw new Error(\"Can not call get on proxy object from a remote window\");\n                        return obj;\n                    }));\n                }\n            };\n        }\n        var PROP_TYPE = {\n            STRING: \"string\",\n            OBJECT: \"object\",\n            FUNCTION: \"function\",\n            BOOLEAN: \"boolean\",\n            NUMBER: \"number\",\n            ARRAY: \"array\"\n        };\n        var PROP_SERIALIZATION = {\n            JSON: \"json\",\n            DOTIFY: \"dotify\",\n            BASE64: \"base64\"\n        };\n        var CONTEXT = WINDOW_TYPE;\n        var EVENT = {\n            RENDER: \"zoid-render\",\n            RENDERED: \"zoid-rendered\",\n            DISPLAY: \"zoid-display\",\n            ERROR: \"zoid-error\",\n            CLOSE: \"zoid-close\",\n            DESTROY: \"zoid-destroy\",\n            PROPS: \"zoid-props\",\n            RESIZE: \"zoid-resize\",\n            FOCUS: \"zoid-focus\"\n        };\n        function normalizeChildProp(propsDef, props, key, value, helpers) {\n            if (!propsDef.hasOwnProperty(key)) return value;\n            var prop = propsDef[key];\n            return \"function\" == typeof prop.childDecorate ? prop.childDecorate({\n                value: value,\n                uid: helpers.uid,\n                close: helpers.close,\n                focus: helpers.focus,\n                onError: helpers.onError,\n                onProps: helpers.onProps,\n                resize: helpers.resize,\n                getParent: helpers.getParent,\n                getParentDomain: helpers.getParentDomain,\n                show: helpers.show,\n                hide: helpers.hide\n            }) : value;\n        }\n        function parseChildWindowName(windowName) {\n            return inlineMemoize(parseChildWindowName, (function() {\n                if (!windowName) throw new Error(\"No window name\");\n                var _windowName$split = windowName.split(\"__\"), zoidcomp = _windowName$split[1], name = _windowName$split[2], encodedPayload = _windowName$split[3];\n                if (\"zoid\" !== zoidcomp) throw new Error(\"Window not rendered by zoid - got \" + zoidcomp);\n                if (!name) throw new Error(\"Expected component name\");\n                if (!encodedPayload) throw new Error(\"Expected encoded payload\");\n                try {\n                    return JSON.parse(function(str) {\n                        if (\"function\" == typeof atob) return decodeURIComponent([].map.call(atob(str), (function(c) {\n                            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n                        })).join(\"\"));\n                        if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"base64\").toString(\"utf8\");\n                        throw new Error(\"Can not find window.atob or Buffer\");\n                    }(encodedPayload));\n                } catch (err) {\n                    throw new Error(\"Can not decode window name payload: \" + encodedPayload + \": \" + stringifyError(err));\n                }\n            }), [ windowName ]);\n        }\n        function getChildPayload() {\n            try {\n                return parseChildWindowName(window.name);\n            } catch (err) {}\n        }\n        function child_focus() {\n            return promise_ZalgoPromise.try((function() {\n                window.focus();\n            }));\n        }\n        function child_destroy() {\n            return promise_ZalgoPromise.try((function() {\n                window.close();\n            }));\n        }\n        function props_getQueryParam(prop, key, value) {\n            return promise_ZalgoPromise.try((function() {\n                return \"function\" == typeof prop.queryParam ? prop.queryParam({\n                    value: value\n                }) : \"string\" == typeof prop.queryParam ? prop.queryParam : key;\n            }));\n        }\n        function getQueryValue(prop, key, value) {\n            return promise_ZalgoPromise.try((function() {\n                return \"function\" == typeof prop.queryValue && isDefined(value) ? prop.queryValue({\n                    value: value\n                }) : value;\n            }));\n        }\n        function parentComponent(options, overrides, parentWin) {\n            void 0 === overrides && (overrides = {});\n            void 0 === parentWin && (parentWin = window);\n            var propsDef = options.propsDef, containerTemplate = options.containerTemplate, prerenderTemplate = options.prerenderTemplate, tag = options.tag, name = options.name, attributes = options.attributes, dimensions = options.dimensions, autoResize = options.autoResize, url = options.url, domainMatch = options.domain;\n            var initPromise = new promise_ZalgoPromise;\n            var handledErrors = [];\n            var clean = cleanup();\n            var state = {};\n            var internalState = {\n                visible: !0\n            };\n            var event = overrides.event ? overrides.event : (triggered = {}, handlers = {}, \n            {\n                on: function(eventName, handler) {\n                    var handlerList = handlers[eventName] = handlers[eventName] || [];\n                    handlerList.push(handler);\n                    var cancelled = !1;\n                    return {\n                        cancel: function() {\n                            if (!cancelled) {\n                                cancelled = !0;\n                                handlerList.splice(handlerList.indexOf(handler), 1);\n                            }\n                        }\n                    };\n                },\n                once: function(eventName, handler) {\n                    var listener = this.on(eventName, (function() {\n                        listener.cancel();\n                        handler();\n                    }));\n                    return listener;\n                },\n                trigger: function(eventName) {\n                    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];\n                    var handlerList = handlers[eventName];\n                    var promises = [];\n                    if (handlerList) {\n                        var _loop = function(_i2) {\n                            var handler = handlerList[_i2];\n                            promises.push(promise_ZalgoPromise.try((function() {\n                                return handler.apply(void 0, args);\n                            })));\n                        };\n                        for (var _i2 = 0; _i2 < handlerList.length; _i2++) _loop(_i2);\n                    }\n                    return promise_ZalgoPromise.all(promises).then(src_util_noop);\n                },\n                triggerOnce: function(eventName) {\n                    if (triggered[eventName]) return promise_ZalgoPromise.resolve();\n                    triggered[eventName] = !0;\n                    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];\n                    return this.trigger.apply(this, [ eventName ].concat(args));\n                },\n                reset: function() {\n                    handlers = {};\n                }\n            });\n            var triggered, handlers;\n            var props = overrides.props ? overrides.props : {};\n            var currentProxyWin;\n            var currentProxyContainer;\n            var childComponent;\n            var onErrorOverride = overrides.onError;\n            var getProxyContainerOverride = overrides.getProxyContainer;\n            var showOverride = overrides.show;\n            var hideOverride = overrides.hide;\n            var closeOverride = overrides.close;\n            var renderContainerOverride = overrides.renderContainer;\n            var getProxyWindowOverride = overrides.getProxyWindow;\n            var setProxyWinOverride = overrides.setProxyWin;\n            var openFrameOverride = overrides.openFrame;\n            var openPrerenderFrameOverride = overrides.openPrerenderFrame;\n            var prerenderOverride = overrides.prerender;\n            var openOverride = overrides.open;\n            var openPrerenderOverride = overrides.openPrerender;\n            var watchForUnloadOverride = overrides.watchForUnload;\n            var getInternalStateOverride = overrides.getInternalState;\n            var setInternalStateOverride = overrides.setInternalState;\n            var getPropsForChild = function(domain) {\n                var result = {};\n                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {\n                    var key = _Object$keys2[_i2];\n                    var prop = propsDef[key];\n                    prop && !1 === prop.sendToChild || prop && prop.sameDomain && !matchDomain(domain, getDomain(window)) || (result[key] = props[key]);\n                }\n                return promise_ZalgoPromise.hash(result);\n            };\n            var getInternalState = function() {\n                return promise_ZalgoPromise.try((function() {\n                    return getInternalStateOverride ? getInternalStateOverride() : internalState;\n                }));\n            };\n            var setInternalState = function(newInternalState) {\n                return promise_ZalgoPromise.try((function() {\n                    return setInternalStateOverride ? setInternalStateOverride(newInternalState) : internalState = _extends({}, internalState, newInternalState);\n                }));\n            };\n            var getProxyWindow = function() {\n                return getProxyWindowOverride ? getProxyWindowOverride() : promise_ZalgoPromise.try((function() {\n                    var windowProp = props.window;\n                    if (windowProp) {\n                        var _proxyWin = setup_toProxyWindow(windowProp);\n                        clean.register((function() {\n                            return windowProp.close();\n                        }));\n                        return _proxyWin;\n                    }\n                    return new window_ProxyWindow({\n                        send: send_send\n                    });\n                }));\n            };\n            var getProxyContainer = function(container) {\n                return getProxyContainerOverride ? getProxyContainerOverride(container) : promise_ZalgoPromise.try((function() {\n                    return elementReady(container);\n                })).then((function(containerElement) {\n                    isShadowElement(containerElement) && (containerElement = function(element) {\n                        var shadowHost = function(element) {\n                            var shadowRoot = function(element) {\n                                for (;element.parentNode; ) element = element.parentNode;\n                                if (isShadowElement(element)) return element;\n                            }(element);\n                            if (shadowRoot.host) return shadowRoot.host;\n                        }(element);\n                        if (!shadowHost) throw new Error(\"Element is not in shadow dom\");\n                        if (isShadowElement(shadowHost)) throw new Error(\"Host element is also in shadow dom\");\n                        var slotName = \"shadow-slot-\" + uniqueID();\n                        var slot = document.createElement(\"slot\");\n                        slot.setAttribute(\"name\", slotName);\n                        element.appendChild(slot);\n                        var slotProvider = document.createElement(\"div\");\n                        slotProvider.setAttribute(\"slot\", slotName);\n                        shadowHost.appendChild(slotProvider);\n                        return slotProvider;\n                    }(containerElement));\n                    return getProxyObject(containerElement);\n                }));\n            };\n            var setProxyWin = function(proxyWin) {\n                return setProxyWinOverride ? setProxyWinOverride(proxyWin) : promise_ZalgoPromise.try((function() {\n                    currentProxyWin = proxyWin;\n                }));\n            };\n            var show = function() {\n                return showOverride ? showOverride() : promise_ZalgoPromise.hash({\n                    setState: setInternalState({\n                        visible: !0\n                    }),\n                    showElement: currentProxyContainer ? currentProxyContainer.get().then(showElement) : null\n                }).then(src_util_noop);\n            };\n            var hide = function() {\n                return hideOverride ? hideOverride() : promise_ZalgoPromise.hash({\n                    setState: setInternalState({\n                        visible: !1\n                    }),\n                    showElement: currentProxyContainer ? currentProxyContainer.get().then(hideElement) : null\n                }).then(src_util_noop);\n            };\n            var getUrl = function() {\n                return \"function\" == typeof url ? url({\n                    props: props\n                }) : url;\n            };\n            var getAttributes = function() {\n                return \"function\" == typeof attributes ? attributes({\n                    props: props\n                }) : attributes;\n            };\n            var getChildDomain = function() {\n                return domainMatch && \"string\" == typeof domainMatch ? domainMatch : getDomainFromUrl(getUrl());\n            };\n            var getDomainMatcher = function() {\n                return domainMatch && util_isRegex(domainMatch) ? domainMatch : getChildDomain();\n            };\n            var openFrame = function(context, _ref) {\n                var windowName = _ref.windowName;\n                return openFrameOverride ? openFrameOverride(context, {\n                    windowName: windowName\n                }) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({\n                        attributes: _extends({\n                            name: windowName,\n                            title: name\n                        }, getAttributes().iframe)\n                    }));\n                }));\n            };\n            var openPrerenderFrame = function(context) {\n                return openPrerenderFrameOverride ? openPrerenderFrameOverride(context) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) return getProxyObject(dom_iframe({\n                        attributes: _extends({\n                            name: \"__zoid_prerender_frame__\" + name + \"_\" + uniqueID() + \"__\",\n                            title: \"prerender__\" + name\n                        }, getAttributes().iframe)\n                    }));\n                }));\n            };\n            var openPrerender = function(context, proxyWin, proxyPrerenderFrame) {\n                return openPrerenderOverride ? openPrerenderOverride(context, proxyWin, proxyPrerenderFrame) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) {\n                        if (!proxyPrerenderFrame) throw new Error(\"Expected proxy frame to be passed\");\n                        return proxyPrerenderFrame.get().then((function(prerenderFrame) {\n                            clean.register((function() {\n                                return destroyElement(prerenderFrame);\n                            }));\n                            return awaitFrameWindow(prerenderFrame).then((function(prerenderFrameWindow) {\n                                return assertSameDomain(prerenderFrameWindow);\n                            })).then((function(win) {\n                                return setup_toProxyWindow(win);\n                            }));\n                        }));\n                    }\n                    throw new Error(\"No render context available for \" + context);\n                }));\n            };\n            var focus = function() {\n                return promise_ZalgoPromise.try((function() {\n                    if (currentProxyWin) return promise_ZalgoPromise.all([ event.trigger(EVENT.FOCUS), currentProxyWin.focus() ]).then(src_util_noop);\n                }));\n            };\n            var getWindowRef = function(target, domain, uid, context) {\n                if (domain === getDomain(window)) {\n                    var global = lib_global_getGlobal(window);\n                    global.windows = global.windows || {};\n                    global.windows[uid] = window;\n                    clean.register((function() {\n                        delete global.windows[uid];\n                    }));\n                    return {\n                        type: \"global\",\n                        uid: uid\n                    };\n                }\n                return context === CONTEXT.POPUP ? {\n                    type: \"opener\"\n                } : {\n                    type: \"parent\",\n                    distance: getDistanceFromTop(window)\n                };\n            };\n            var initChild = function(childExports) {\n                return promise_ZalgoPromise.try((function() {\n                    childComponent = childExports;\n                    initPromise.resolve();\n                    clean.register((function() {\n                        return childExports.close.fireAndForget().catch(src_util_noop);\n                    }));\n                }));\n            };\n            var resize = function(_ref2) {\n                var width = _ref2.width, height = _ref2.height;\n                return promise_ZalgoPromise.try((function() {\n                    event.trigger(EVENT.RESIZE, {\n                        width: width,\n                        height: height\n                    });\n                }));\n            };\n            var destroy = function(err) {\n                return promise_ZalgoPromise.try((function() {\n                    return event.trigger(EVENT.DESTROY);\n                })).catch(src_util_noop).then((function() {\n                    return clean.all(err);\n                })).then((function() {\n                    initPromise.asyncReject(err || new Error(\"Component destroyed\"));\n                }));\n            };\n            var close = memoize((function(err) {\n                return promise_ZalgoPromise.try((function() {\n                    if (closeOverride) {\n                        if (isWindowClosed(closeOverride.__source__)) return;\n                        return closeOverride();\n                    }\n                    return promise_ZalgoPromise.try((function() {\n                        return event.trigger(EVENT.CLOSE);\n                    })).then((function() {\n                        return destroy(err || new Error(\"Component closed\"));\n                    }));\n                }));\n            }));\n            var open = function(context, _ref3) {\n                var proxyWin = _ref3.proxyWin, proxyFrame = _ref3.proxyFrame;\n                return openOverride ? openOverride(context, {\n                    proxyWin: proxyWin,\n                    proxyFrame: proxyFrame,\n                    windowName: _ref3.windowName\n                }) : promise_ZalgoPromise.try((function() {\n                    if (context === CONTEXT.IFRAME) {\n                        if (!proxyFrame) throw new Error(\"Expected proxy frame to be passed\");\n                        return proxyFrame.get().then((function(frame) {\n                            return awaitFrameWindow(frame).then((function(win) {\n                                clean.register((function() {\n                                    return destroyElement(frame);\n                                }));\n                                clean.register((function() {\n                                    return function(win) {\n                                        for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n                                    }(win);\n                                }));\n                                return win;\n                            }));\n                        }));\n                    }\n                    throw new Error(\"No render context available for \" + context);\n                })).then((function(win) {\n                    proxyWin.setWindow(win, {\n                        send: send_send\n                    });\n                    return proxyWin;\n                }));\n            };\n            var watchForUnload = function() {\n                return promise_ZalgoPromise.try((function() {\n                    var unloadWindowListener = addEventListener(window, \"unload\", once((function() {\n                        destroy(new Error(\"Window navigated away\"));\n                    })));\n                    var closeParentWindowListener = onCloseWindow(parentWin, destroy, 3e3);\n                    clean.register(closeParentWindowListener.cancel);\n                    clean.register(unloadWindowListener.cancel);\n                    if (watchForUnloadOverride) return watchForUnloadOverride();\n                }));\n            };\n            var checkWindowClose = function(proxyWin) {\n                var closed = !1;\n                return proxyWin.isClosed().then((function(isClosed) {\n                    if (isClosed) {\n                        closed = !0;\n                        return close(new Error(\"Detected component window close\"));\n                    }\n                    return promise_ZalgoPromise.delay(200).then((function() {\n                        return proxyWin.isClosed();\n                    })).then((function(secondIsClosed) {\n                        if (secondIsClosed) {\n                            closed = !0;\n                            return close(new Error(\"Detected component window close\"));\n                        }\n                    }));\n                })).then((function() {\n                    return closed;\n                }));\n            };\n            var onError = function(err) {\n                return onErrorOverride ? onErrorOverride(err) : promise_ZalgoPromise.try((function() {\n                    if (-1 === handledErrors.indexOf(err)) {\n                        handledErrors.push(err);\n                        initPromise.asyncReject(err);\n                        return event.trigger(EVENT.ERROR, err);\n                    }\n                }));\n            };\n            initChild.onError = onError;\n            var renderTemplate = function(renderer, _ref6) {\n                return renderer({\n                    container: _ref6.container,\n                    context: _ref6.context,\n                    uid: _ref6.uid,\n                    doc: _ref6.doc,\n                    frame: _ref6.frame,\n                    prerenderFrame: _ref6.prerenderFrame,\n                    focus: focus,\n                    close: close,\n                    state: state,\n                    props: props,\n                    tag: tag,\n                    dimensions: dimensions,\n                    event: event\n                });\n            };\n            var prerender = function(proxyPrerenderWin, _ref7) {\n                var context = _ref7.context, uid = _ref7.uid;\n                return prerenderOverride ? prerenderOverride(proxyPrerenderWin, {\n                    context: context,\n                    uid: uid\n                }) : promise_ZalgoPromise.try((function() {\n                    if (prerenderTemplate) {\n                        var prerenderWindow = proxyPrerenderWin.getWindow();\n                        if (prerenderWindow && isSameDomain(prerenderWindow) && function(win) {\n                            try {\n                                if (!win.location.href) return !0;\n                                if (\"about:blank\" === win.location.href) return !0;\n                            } catch (err) {}\n                            return !1;\n                        }(prerenderWindow)) {\n                            var doc = (prerenderWindow = assertSameDomain(prerenderWindow)).document;\n                            var el = renderTemplate(prerenderTemplate, {\n                                context: context,\n                                uid: uid,\n                                doc: doc\n                            });\n                            if (el) {\n                                if (el.ownerDocument !== doc) throw new Error(\"Expected prerender template to have been created with document from child window\");\n                                !function(win, el) {\n                                    var tag = el.tagName.toLowerCase();\n                                    if (\"html\" !== tag) throw new Error(\"Expected element to be html, got \" + tag);\n                                    var documentElement = win.document.documentElement;\n                                    for (var _i6 = 0, _arrayFrom2 = arrayFrom(documentElement.children); _i6 < _arrayFrom2.length; _i6++) documentElement.removeChild(_arrayFrom2[_i6]);\n                                    for (var _i8 = 0, _arrayFrom4 = arrayFrom(el.children); _i8 < _arrayFrom4.length; _i8++) documentElement.appendChild(_arrayFrom4[_i8]);\n                                }(prerenderWindow, el);\n                                var _autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, _autoResize$element = autoResize.element, element = void 0 === _autoResize$element ? \"body\" : _autoResize$element;\n                                if ((element = getElementSafe(element, doc)) && (width || height)) {\n                                    var prerenderResizeListener = onResize(element, (function(_ref8) {\n                                        resize({\n                                            width: width ? _ref8.width : void 0,\n                                            height: height ? _ref8.height : void 0\n                                        });\n                                    }), {\n                                        width: width,\n                                        height: height,\n                                        win: prerenderWindow\n                                    });\n                                    event.on(EVENT.RENDERED, prerenderResizeListener.cancel);\n                                }\n                            }\n                        }\n                    }\n                }));\n            };\n            var renderContainer = function(proxyContainer, _ref9) {\n                var proxyFrame = _ref9.proxyFrame, proxyPrerenderFrame = _ref9.proxyPrerenderFrame, context = _ref9.context, uid = _ref9.uid;\n                return renderContainerOverride ? renderContainerOverride(proxyContainer, {\n                    proxyFrame: proxyFrame,\n                    proxyPrerenderFrame: proxyPrerenderFrame,\n                    context: context,\n                    uid: uid\n                }) : promise_ZalgoPromise.hash({\n                    container: proxyContainer.get(),\n                    frame: proxyFrame ? proxyFrame.get() : null,\n                    prerenderFrame: proxyPrerenderFrame ? proxyPrerenderFrame.get() : null,\n                    internalState: getInternalState()\n                }).then((function(_ref10) {\n                    var container = _ref10.container, visible = _ref10.internalState.visible;\n                    var innerContainer = renderTemplate(containerTemplate, {\n                        context: context,\n                        uid: uid,\n                        container: container,\n                        frame: _ref10.frame,\n                        prerenderFrame: _ref10.prerenderFrame,\n                        doc: document\n                    });\n                    if (innerContainer) {\n                        visible || hideElement(innerContainer);\n                        appendChild(container, innerContainer);\n                        var containerWatcher = function(element, handler) {\n                            handler = once(handler);\n                            var cancelled = !1;\n                            var mutationObservers = [];\n                            var interval;\n                            var sacrificialFrame;\n                            var sacrificialFrameWin;\n                            var cancel = function() {\n                                cancelled = !0;\n                                for (var _i18 = 0; _i18 < mutationObservers.length; _i18++) mutationObservers[_i18].disconnect();\n                                interval && interval.cancel();\n                                sacrificialFrameWin && sacrificialFrameWin.removeEventListener(\"unload\", elementClosed);\n                                sacrificialFrame && destroyElement(sacrificialFrame);\n                            };\n                            var elementClosed = function() {\n                                if (!cancelled) {\n                                    handler();\n                                    cancel();\n                                }\n                            };\n                            if (isElementClosed(element)) {\n                                elementClosed();\n                                return {\n                                    cancel: cancel\n                                };\n                            }\n                            if (window.MutationObserver) {\n                                var mutationElement = element.parentElement;\n                                for (;mutationElement; ) {\n                                    var mutationObserver = new window.MutationObserver((function() {\n                                        isElementClosed(element) && elementClosed();\n                                    }));\n                                    mutationObserver.observe(mutationElement, {\n                                        childList: !0\n                                    });\n                                    mutationObservers.push(mutationObserver);\n                                    mutationElement = mutationElement.parentElement;\n                                }\n                            }\n                            (sacrificialFrame = document.createElement(\"iframe\")).setAttribute(\"name\", \"__detect_close_\" + uniqueID() + \"__\");\n                            sacrificialFrame.style.display = \"none\";\n                            awaitFrameWindow(sacrificialFrame).then((function(frameWin) {\n                                (sacrificialFrameWin = assertSameDomain(frameWin)).addEventListener(\"unload\", elementClosed);\n                            }));\n                            element.appendChild(sacrificialFrame);\n                            interval = safeInterval((function() {\n                                isElementClosed(element) && elementClosed();\n                            }), 1e3);\n                            return {\n                                cancel: cancel\n                            };\n                        }(innerContainer, (function() {\n                            return close(new Error(\"Detected container element removed from DOM\"));\n                        }));\n                        clean.register((function() {\n                            return containerWatcher.cancel();\n                        }));\n                        clean.register((function() {\n                            return destroyElement(innerContainer);\n                        }));\n                        return currentProxyContainer = getProxyObject(innerContainer);\n                    }\n                }));\n            };\n            var getHelpers = function() {\n                return {\n                    state: state,\n                    event: event,\n                    close: close,\n                    focus: focus,\n                    resize: resize,\n                    onError: onError,\n                    updateProps: updateProps,\n                    show: show,\n                    hide: hide\n                };\n            };\n            var setProps = function(newProps, isUpdate) {\n                void 0 === isUpdate && (isUpdate = !1);\n                var helpers = getHelpers();\n                !function(propsDef, props, inputProps, helpers, isUpdate) {\n                    void 0 === isUpdate && (isUpdate = !1);\n                    extend(props, inputProps = inputProps || {});\n                    var propNames = isUpdate ? [] : [].concat(Object.keys(propsDef));\n                    for (var _i2 = 0, _Object$keys2 = Object.keys(inputProps); _i2 < _Object$keys2.length; _i2++) {\n                        var key = _Object$keys2[_i2];\n                        -1 === propNames.indexOf(key) && propNames.push(key);\n                    }\n                    var aliases = [];\n                    var state = helpers.state, close = helpers.close, focus = helpers.focus, event = helpers.event, onError = helpers.onError;\n                    for (var _i4 = 0; _i4 < propNames.length; _i4++) {\n                        var _key = propNames[_i4];\n                        var propDef = propsDef[_key];\n                        var value = inputProps[_key];\n                        if (propDef) {\n                            var alias = propDef.alias;\n                            if (alias) {\n                                !isDefined(value) && isDefined(inputProps[alias]) && (value = inputProps[alias]);\n                                aliases.push(alias);\n                            }\n                            propDef.value && (value = propDef.value({\n                                props: props,\n                                state: state,\n                                close: close,\n                                focus: focus,\n                                event: event,\n                                onError: onError\n                            }));\n                            !isDefined(value) && propDef.default && (value = propDef.default({\n                                props: props,\n                                state: state,\n                                close: close,\n                                focus: focus,\n                                event: event,\n                                onError: onError\n                            }));\n                            if (isDefined(value) && (\"array\" === propDef.type ? !Array.isArray(value) : typeof value !== propDef.type)) throw new TypeError(\"Prop is not of type \" + propDef.type + \": \" + _key);\n                            props[_key] = value;\n                        }\n                    }\n                    for (var _i6 = 0; _i6 < aliases.length; _i6++) delete props[aliases[_i6]];\n                    for (var _i8 = 0, _Object$keys4 = Object.keys(props); _i8 < _Object$keys4.length; _i8++) {\n                        var _key2 = _Object$keys4[_i8];\n                        var _propDef = propsDef[_key2];\n                        var _value = props[_key2];\n                        _propDef && isDefined(_value) && _propDef.decorate && (props[_key2] = _propDef.decorate({\n                            value: _value,\n                            props: props,\n                            state: state,\n                            close: close,\n                            focus: focus,\n                            event: event,\n                            onError: onError\n                        }));\n                    }\n                    for (var _i10 = 0, _Object$keys6 = Object.keys(propsDef); _i10 < _Object$keys6.length; _i10++) {\n                        var _key3 = _Object$keys6[_i10];\n                        if (!1 !== propsDef[_key3].required && !isDefined(props[_key3])) throw new Error('Expected prop \"' + _key3 + '\" to be defined');\n                    }\n                }(propsDef, props, newProps, helpers, isUpdate);\n            };\n            var updateProps = function(newProps) {\n                setProps(newProps, !0);\n                return initPromise.then((function() {\n                    var child = childComponent;\n                    var proxyWin = currentProxyWin;\n                    if (child && proxyWin) return getPropsForChild(getDomainMatcher()).then((function(childProps) {\n                        return child.updateProps(childProps).catch((function(err) {\n                            return checkWindowClose(proxyWin).then((function(closed) {\n                                if (!closed) throw err;\n                            }));\n                        }));\n                    }));\n                }));\n            };\n            return {\n                init: function() {\n                    !function() {\n                        event.on(EVENT.RENDER, (function() {\n                            return props.onRender();\n                        }));\n                        event.on(EVENT.DISPLAY, (function() {\n                            return props.onDisplay();\n                        }));\n                        event.on(EVENT.RENDERED, (function() {\n                            return props.onRendered();\n                        }));\n                        event.on(EVENT.CLOSE, (function() {\n                            return props.onClose();\n                        }));\n                        event.on(EVENT.DESTROY, (function() {\n                            return props.onDestroy();\n                        }));\n                        event.on(EVENT.RESIZE, (function() {\n                            return props.onResize();\n                        }));\n                        event.on(EVENT.FOCUS, (function() {\n                            return props.onFocus();\n                        }));\n                        event.on(EVENT.PROPS, (function(newProps) {\n                            return props.onProps(newProps);\n                        }));\n                        event.on(EVENT.ERROR, (function(err) {\n                            return props && props.onError ? props.onError(err) : initPromise.reject(err).then((function() {\n                                setTimeout((function() {\n                                    throw err;\n                                }), 1);\n                            }));\n                        }));\n                        clean.register(event.reset);\n                    }();\n                },\n                render: function(target, container, context) {\n                    return promise_ZalgoPromise.try((function() {\n                        var uid = \"zoid-\" + tag + \"-\" + uniqueID();\n                        var domain = getDomainMatcher();\n                        var childDomain = getChildDomain();\n                        !function(target, domain, container) {\n                            if (target !== window) {\n                                if (!isSameTopWindow(window, target)) throw new Error(\"Can only renderTo an adjacent frame\");\n                                var origin = getDomain();\n                                if (!matchDomain(domain, origin) && !isSameDomain(target)) throw new Error(\"Can not render remotely to \" + domain.toString() + \" - can only render to \" + origin);\n                                if (container && \"string\" != typeof container) throw new Error(\"Container passed to renderTo must be a string selector, got \" + typeof container + \" }\");\n                            }\n                        }(target, domain, container);\n                        var delegatePromise = promise_ZalgoPromise.try((function() {\n                            if (target !== window) return function(context, target) {\n                                var delegateProps = {};\n                                for (var _i4 = 0, _Object$keys4 = Object.keys(props); _i4 < _Object$keys4.length; _i4++) {\n                                    var propName = _Object$keys4[_i4];\n                                    var propDef = propsDef[propName];\n                                    propDef && propDef.allowDelegate && (delegateProps[propName] = props[propName]);\n                                }\n                                var childOverridesPromise = send_send(target, \"zoid_delegate_\" + name, {\n                                    overrides: {\n                                        props: delegateProps,\n                                        event: event,\n                                        close: close,\n                                        onError: onError,\n                                        getInternalState: getInternalState,\n                                        setInternalState: setInternalState\n                                    }\n                                }).then((function(_ref11) {\n                                    var parentComp = _ref11.data.parent;\n                                    clean.register((function(err) {\n                                        if (!isWindowClosed(target)) return parentComp.destroy(err);\n                                    }));\n                                    return parentComp.getDelegateOverrides();\n                                })).catch((function(err) {\n                                    throw new Error(\"Unable to delegate rendering. Possibly the component is not loaded in the target window.\\n\\n\" + stringifyError(err));\n                                }));\n                                getProxyContainerOverride = function() {\n                                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.getProxyContainer.apply(childOverrides, args);\n                                    }));\n                                };\n                                renderContainerOverride = function() {\n                                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.renderContainer.apply(childOverrides, args);\n                                    }));\n                                };\n                                showOverride = function() {\n                                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.show.apply(childOverrides, args);\n                                    }));\n                                };\n                                hideOverride = function() {\n                                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.hide.apply(childOverrides, args);\n                                    }));\n                                };\n                                watchForUnloadOverride = function() {\n                                    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];\n                                    return childOverridesPromise.then((function(childOverrides) {\n                                        return childOverrides.watchForUnload.apply(childOverrides, args);\n                                    }));\n                                };\n                                if (context === CONTEXT.IFRAME) {\n                                    getProxyWindowOverride = function() {\n                                        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.getProxyWindow.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openFrameOverride = function() {\n                                        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.openFrame.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openPrerenderFrameOverride = function() {\n                                        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) args[_key8] = arguments[_key8];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.openPrerenderFrame.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    prerenderOverride = function() {\n                                        for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) args[_key9] = arguments[_key9];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.prerender.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openOverride = function() {\n                                        for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) args[_key10] = arguments[_key10];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.open.apply(childOverrides, args);\n                                        }));\n                                    };\n                                    openPrerenderOverride = function() {\n                                        for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) args[_key11] = arguments[_key11];\n                                        return childOverridesPromise.then((function(childOverrides) {\n                                            return childOverrides.openPrerender.apply(childOverrides, args);\n                                        }));\n                                    };\n                                }\n                                return childOverridesPromise;\n                            }(context, target);\n                        }));\n                        var windowProp = props.window;\n                        var watchForUnloadPromise = watchForUnload();\n                        var buildUrlPromise = function(propsDef, props) {\n                            var params = {};\n                            var keys = Object.keys(props);\n                            return promise_ZalgoPromise.all(keys.map((function(key) {\n                                var prop = propsDef[key];\n                                if (prop) return promise_ZalgoPromise.resolve().then((function() {\n                                    var value = props[key];\n                                    if (value && prop.queryParam) return value;\n                                })).then((function(value) {\n                                    if (null != value) return promise_ZalgoPromise.all([ props_getQueryParam(prop, key, value), getQueryValue(prop, 0, value) ]).then((function(_ref) {\n                                        var queryParam = _ref[0], queryValue = _ref[1];\n                                        var result;\n                                        if (\"boolean\" == typeof queryValue) result = queryValue.toString(); else if (\"string\" == typeof queryValue) result = queryValue.toString(); else if (\"object\" == typeof queryValue && null !== queryValue) {\n                                            if (prop.serialization === PROP_SERIALIZATION.JSON) result = JSON.stringify(queryValue); else if (prop.serialization === PROP_SERIALIZATION.BASE64) result = btoa(JSON.stringify(queryValue)); else if (prop.serialization === PROP_SERIALIZATION.DOTIFY || !prop.serialization) {\n                                                result = function dotify(obj, prefix, newobj) {\n                                                    void 0 === prefix && (prefix = \"\");\n                                                    void 0 === newobj && (newobj = {});\n                                                    prefix = prefix ? prefix + \".\" : prefix;\n                                                    for (var key in obj) obj.hasOwnProperty(key) && null != obj[key] && \"function\" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every((function(val) {\n                                                        return \"object\" != typeof val;\n                                                    })) ? newobj[\"\" + prefix + key + \"[]\"] = obj[key].join(\",\") : obj[key] && \"object\" == typeof obj[key] ? newobj = dotify(obj[key], \"\" + prefix + key, newobj) : newobj[\"\" + prefix + key] = obj[key].toString());\n                                                    return newobj;\n                                                }(queryValue, key);\n                                                for (var _i12 = 0, _Object$keys8 = Object.keys(result); _i12 < _Object$keys8.length; _i12++) {\n                                                    var dotkey = _Object$keys8[_i12];\n                                                    params[dotkey] = result[dotkey];\n                                                }\n                                                return;\n                                            }\n                                        } else \"number\" == typeof queryValue && (result = queryValue.toString());\n                                        params[queryParam] = result;\n                                    }));\n                                }));\n                            }))).then((function() {\n                                return params;\n                            }));\n                        }(propsDef, props).then((function(query) {\n                            return function(url, options) {\n                                var query = options.query || {};\n                                var hash = options.hash || {};\n                                var originalUrl;\n                                var originalHash;\n                                var _url$split = url.split(\"#\");\n                                originalHash = _url$split[1];\n                                var _originalUrl$split = (originalUrl = _url$split[0]).split(\"?\");\n                                originalUrl = _originalUrl$split[0];\n                                var queryString = extendQuery(_originalUrl$split[1], query);\n                                var hashString = extendQuery(originalHash, hash);\n                                queryString && (originalUrl = originalUrl + \"?\" + queryString);\n                                hashString && (originalUrl = originalUrl + \"#\" + hashString);\n                                return originalUrl;\n                            }(function(url) {\n                                if (!(domain = getDomainFromUrl(url), 0 === domain.indexOf(\"mock:\"))) return url;\n                                var domain;\n                                throw new Error(\"Mock urls not supported out of test mode\");\n                            }(getUrl()), {\n                                query: query\n                            });\n                        }));\n                        var onRenderPromise = event.trigger(EVENT.RENDER);\n                        var getProxyContainerPromise = getProxyContainer(container);\n                        var getProxyWindowPromise = getProxyWindow();\n                        var buildWindowNamePromise = getProxyWindowPromise.then((function(proxyWin) {\n                            return function(_temp) {\n                                var _ref4 = void 0 === _temp ? {} : _temp, proxyWin = _ref4.proxyWin, childDomain = _ref4.childDomain, domain = _ref4.domain, context = (void 0 === _ref4.target && window, \n                                _ref4.context), uid = _ref4.uid;\n                                return function(proxyWin, childDomain, domain, uid) {\n                                    return getPropsForChild(domain).then((function(childProps) {\n                                        var value = setup_serializeMessage(proxyWin, domain, childProps);\n                                        var propRef = childDomain === getDomain() ? {\n                                            type: \"uid\",\n                                            uid: uid\n                                        } : {\n                                            type: \"raw\",\n                                            value: value\n                                        };\n                                        if (\"uid\" === propRef.type) {\n                                            var global = lib_global_getGlobal(window);\n                                            global.props = global.props || {};\n                                            global.props[uid] = value;\n                                            clean.register((function() {\n                                                delete global.props[uid];\n                                            }));\n                                        }\n                                        return propRef;\n                                    }));\n                                }(proxyWin, childDomain, domain, uid).then((function(propsRef) {\n                                    return {\n                                        uid: uid,\n                                        context: context,\n                                        tag: tag,\n                                        version: \"9_0_63\",\n                                        childDomain: childDomain,\n                                        parentDomain: getDomain(window),\n                                        parent: getWindowRef(0, childDomain, uid, context),\n                                        props: propsRef,\n                                        exports: setup_serializeMessage(proxyWin, domain, (win = proxyWin, {\n                                            init: initChild,\n                                            close: close,\n                                            checkClose: function() {\n                                                return checkWindowClose(win);\n                                            },\n                                            resize: resize,\n                                            onError: onError,\n                                            show: show,\n                                            hide: hide\n                                        }))\n                                    };\n                                    var win;\n                                }));\n                            }({\n                                proxyWin: (_ref5 = {\n                                    proxyWin: proxyWin,\n                                    childDomain: childDomain,\n                                    domain: domain,\n                                    target: target,\n                                    context: context,\n                                    uid: uid\n                                }).proxyWin,\n                                childDomain: _ref5.childDomain,\n                                domain: _ref5.domain,\n                                target: _ref5.target,\n                                context: _ref5.context,\n                                uid: _ref5.uid\n                            }).then((function(childPayload) {\n                                return \"__zoid__\" + name + \"__\" + base64encode(JSON.stringify(childPayload)) + \"__\";\n                            }));\n                            var _ref5;\n                        }));\n                        var openFramePromise = buildWindowNamePromise.then((function(windowName) {\n                            return openFrame(context, {\n                                windowName: windowName\n                            });\n                        }));\n                        var openPrerenderFramePromise = openPrerenderFrame(context);\n                        var renderContainerPromise = promise_ZalgoPromise.hash({\n                            proxyContainer: getProxyContainerPromise,\n                            proxyFrame: openFramePromise,\n                            proxyPrerenderFrame: openPrerenderFramePromise\n                        }).then((function(_ref12) {\n                            return renderContainer(_ref12.proxyContainer, {\n                                context: context,\n                                uid: uid,\n                                proxyFrame: _ref12.proxyFrame,\n                                proxyPrerenderFrame: _ref12.proxyPrerenderFrame\n                            });\n                        })).then((function(proxyContainer) {\n                            return proxyContainer;\n                        }));\n                        var openPromise = promise_ZalgoPromise.hash({\n                            windowName: buildWindowNamePromise,\n                            proxyFrame: openFramePromise,\n                            proxyWin: getProxyWindowPromise\n                        }).then((function(_ref13) {\n                            var proxyWin = _ref13.proxyWin;\n                            return windowProp ? proxyWin : open(context, {\n                                windowName: _ref13.windowName,\n                                proxyWin: proxyWin,\n                                proxyFrame: _ref13.proxyFrame\n                            });\n                        }));\n                        var openPrerenderPromise = promise_ZalgoPromise.hash({\n                            proxyWin: openPromise,\n                            proxyPrerenderFrame: openPrerenderFramePromise\n                        }).then((function(_ref14) {\n                            return openPrerender(context, _ref14.proxyWin, _ref14.proxyPrerenderFrame);\n                        }));\n                        var setStatePromise = openPromise.then((function(proxyWin) {\n                            currentProxyWin = proxyWin;\n                            return setProxyWin(proxyWin);\n                        }));\n                        var prerenderPromise = promise_ZalgoPromise.hash({\n                            proxyPrerenderWin: openPrerenderPromise,\n                            state: setStatePromise\n                        }).then((function(_ref15) {\n                            return prerender(_ref15.proxyPrerenderWin, {\n                                context: context,\n                                uid: uid\n                            });\n                        }));\n                        var setWindowNamePromise = promise_ZalgoPromise.hash({\n                            proxyWin: openPromise,\n                            windowName: buildWindowNamePromise\n                        }).then((function(_ref16) {\n                            if (windowProp) return _ref16.proxyWin.setName(_ref16.windowName);\n                        }));\n                        var loadUrlPromise = promise_ZalgoPromise.hash({\n                            proxyWin: openPromise,\n                            builtUrl: buildUrlPromise,\n                            windowName: setWindowNamePromise,\n                            prerender: prerenderPromise\n                        }).then((function(_ref17) {\n                            return _ref17.proxyWin.setLocation(_ref17.builtUrl);\n                        }));\n                        var watchForClosePromise = openPromise.then((function(proxyWin) {\n                            !function watchForClose(proxyWin, context) {\n                                var cancelled = !1;\n                                clean.register((function() {\n                                    cancelled = !0;\n                                }));\n                                return promise_ZalgoPromise.delay(2e3).then((function() {\n                                    return proxyWin.isClosed();\n                                })).then((function(isClosed) {\n                                    return isClosed ? close(new Error(\"Detected \" + context + \" close\")) : cancelled ? void 0 : watchForClose(proxyWin, context);\n                                }));\n                            }(proxyWin, context);\n                        }));\n                        var onDisplayPromise = promise_ZalgoPromise.hash({\n                            container: renderContainerPromise,\n                            prerender: prerenderPromise\n                        }).then((function() {\n                            return event.trigger(EVENT.DISPLAY);\n                        }));\n                        var openBridgePromise = openPromise.then((function(proxyWin) {}));\n                        var runTimeoutPromise = loadUrlPromise.then((function() {\n                            return promise_ZalgoPromise.try((function() {\n                                var timeout = props.timeout;\n                                if (timeout) return initPromise.timeout(timeout, new Error(\"Loading component timed out after \" + timeout + \" milliseconds\"));\n                            }));\n                        }));\n                        var onRenderedPromise = initPromise.then((function() {\n                            return event.trigger(EVENT.RENDERED);\n                        }));\n                        return promise_ZalgoPromise.hash({\n                            initPromise: initPromise,\n                            buildUrlPromise: buildUrlPromise,\n                            onRenderPromise: onRenderPromise,\n                            getProxyContainerPromise: getProxyContainerPromise,\n                            openFramePromise: openFramePromise,\n                            openPrerenderFramePromise: openPrerenderFramePromise,\n                            renderContainerPromise: renderContainerPromise,\n                            openPromise: openPromise,\n                            openPrerenderPromise: openPrerenderPromise,\n                            setStatePromise: setStatePromise,\n                            prerenderPromise: prerenderPromise,\n                            loadUrlPromise: loadUrlPromise,\n                            buildWindowNamePromise: buildWindowNamePromise,\n                            setWindowNamePromise: setWindowNamePromise,\n                            watchForClosePromise: watchForClosePromise,\n                            onDisplayPromise: onDisplayPromise,\n                            openBridgePromise: openBridgePromise,\n                            runTimeoutPromise: runTimeoutPromise,\n                            onRenderedPromise: onRenderedPromise,\n                            delegatePromise: delegatePromise,\n                            watchForUnloadPromise: watchForUnloadPromise\n                        });\n                    })).catch((function(err) {\n                        return promise_ZalgoPromise.all([ onError(err), destroy(err) ]).then((function() {\n                            throw err;\n                        }), (function() {\n                            throw err;\n                        }));\n                    })).then(src_util_noop);\n                },\n                destroy: destroy,\n                setProps: setProps,\n                getHelpers: getHelpers,\n                getDelegateOverrides: function() {\n                    return promise_ZalgoPromise.try((function() {\n                        return {\n                            getProxyContainer: getProxyContainer,\n                            show: show,\n                            hide: hide,\n                            renderContainer: renderContainer,\n                            getProxyWindow: getProxyWindow,\n                            watchForUnload: watchForUnload,\n                            openFrame: openFrame,\n                            openPrerenderFrame: openPrerenderFrame,\n                            prerender: prerender,\n                            open: open,\n                            openPrerender: openPrerender,\n                            setProxyWin: setProxyWin\n                        };\n                    }));\n                }\n            };\n        }\n        var react = {\n            register: function(tag, propsDef, init, _ref) {\n                var React = _ref.React, ReactDOM = _ref.ReactDOM;\n                return function(_React$Component) {\n                    _inheritsLoose(_class, _React$Component);\n                    function _class() {\n                        return _React$Component.apply(this, arguments) || this;\n                    }\n                    var _proto = _class.prototype;\n                    _proto.render = function() {\n                        return React.createElement(\"div\", null);\n                    };\n                    _proto.componentDidMount = function() {\n                        var el = ReactDOM.findDOMNode(this);\n                        var parent = init(extend({}, this.props));\n                        parent.render(el, CONTEXT.IFRAME);\n                        this.setState({\n                            parent: parent\n                        });\n                    };\n                    _proto.componentDidUpdate = function() {\n                        this.state && this.state.parent && this.state.parent.updateProps(extend({}, this.props)).catch(src_util_noop);\n                    };\n                    return _class;\n                }(React.Component);\n            }\n        };\n        var vue = {\n            register: function(tag, propsDef, init, Vue) {\n                return Vue.component(tag, {\n                    render: function(createElement) {\n                        return createElement(\"div\");\n                    },\n                    inheritAttrs: !1,\n                    mounted: function() {\n                        var el = this.$el;\n                        this.parent = init(_extends({}, this.$attrs));\n                        this.parent.render(el, CONTEXT.IFRAME);\n                    },\n                    watch: {\n                        $attrs: {\n                            handler: function() {\n                                this.parent && this.$attrs && this.parent.updateProps(_extends({}, this.$attrs)).catch(src_util_noop);\n                            },\n                            deep: !0\n                        }\n                    }\n                });\n            }\n        };\n        var angular = {\n            register: function(tag, propsDef, init, ng) {\n                return ng.module(tag, []).directive(tag.replace(/-([a-z])/g, (function(g) {\n                    return g[1].toUpperCase();\n                })), (function() {\n                    var scope = {};\n                    for (var _i2 = 0, _Object$keys2 = Object.keys(propsDef); _i2 < _Object$keys2.length; _i2++) scope[_Object$keys2[_i2]] = \"=\";\n                    scope.props = \"=\";\n                    return {\n                        scope: scope,\n                        restrict: \"E\",\n                        controller: [ \"$scope\", \"$element\", function($scope, $element) {\n                            function safeApply() {\n                                if (\"$apply\" !== $scope.$root.$$phase && \"$digest\" !== $scope.$root.$$phase) try {\n                                    $scope.$apply();\n                                } catch (err) {}\n                            }\n                            var getProps = function() {\n                                return replaceObject($scope.props, (function(item) {\n                                    return \"function\" == typeof item ? function() {\n                                        var result = item.apply(this, arguments);\n                                        safeApply();\n                                        return result;\n                                    } : item;\n                                }));\n                            };\n                            var instance = init(getProps());\n                            instance.render($element[0], CONTEXT.IFRAME);\n                            $scope.$watch((function() {\n                                instance.updateProps(getProps()).catch(src_util_noop);\n                            }));\n                        } ]\n                    };\n                }));\n            }\n        };\n        var angular2 = {\n            register: function(tag, propsDef, init, _ref) {\n                var NgModule = _ref.NgModule, ElementRef = _ref.ElementRef, NgZone = _ref.NgZone;\n                var getProps = function(component) {\n                    return replaceObject(_extends({}, component.internalProps, component.props), (function(item) {\n                        return \"function\" == typeof item ? function() {\n                            var _arguments = arguments, _this = this;\n                            return component.zone.run((function() {\n                                return item.apply(_this, _arguments);\n                            }));\n                        } : item;\n                    }));\n                };\n                var ComponentInstance = (0, _ref.Component)({\n                    selector: tag,\n                    template: \"<div></div>\",\n                    inputs: [ \"props\" ]\n                }).Class({\n                    constructor: [ ElementRef, NgZone, function(elementRef, zone) {\n                        this._props = {};\n                        this.elementRef = elementRef;\n                        this.zone = zone;\n                    } ],\n                    ngOnInit: function() {\n                        var targetElement = this.elementRef.nativeElement;\n                        this.parent = init(getProps(this));\n                        this.parent.render(targetElement, CONTEXT.IFRAME);\n                    },\n                    ngDoCheck: function() {\n                        if (this.parent && !function(obj1, obj2) {\n                            var checked = {};\n                            for (var key in obj1) if (obj1.hasOwnProperty(key)) {\n                                checked[key] = !0;\n                                if (obj1[key] !== obj2[key]) return !1;\n                            }\n                            for (var _key in obj2) if (!checked[_key]) return !1;\n                            return !0;\n                        }(this._props, this.props)) {\n                            this._props = _extends({}, this.props);\n                            this.parent.updateProps(getProps(this));\n                        }\n                    }\n                });\n                return NgModule({\n                    declarations: [ ComponentInstance ],\n                    exports: [ ComponentInstance ]\n                }).Class({\n                    constructor: function() {}\n                });\n            }\n        };\n        function defaultContainerTemplate(_ref) {\n            var uid = _ref.uid, frame = _ref.frame, prerenderFrame = _ref.prerenderFrame, doc = _ref.doc, props = _ref.props, event = _ref.event, _ref$dimensions = _ref.dimensions, width = _ref$dimensions.width, height = _ref$dimensions.height;\n            if (frame && prerenderFrame) {\n                var div = doc.createElement(\"div\");\n                div.setAttribute(\"id\", uid);\n                var style = doc.createElement(\"style\");\n                props.cspNonce && style.setAttribute(\"nonce\", props.cspNonce);\n                style.appendChild(doc.createTextNode(\"\\n            #\" + uid + \" {\\n                display: inline-block;\\n                position: relative;\\n                width: \" + width + \";\\n                height: \" + height + \";\\n            }\\n\\n            #\" + uid + \" > iframe {\\n                display: inline-block;\\n                position: absolute;\\n                width: 100%;\\n                height: 100%;\\n                top: 0;\\n                left: 0;\\n                transition: opacity .2s ease-in-out;\\n            }\\n\\n            #\" + uid + \" > iframe.zoid-invisible {\\n                opacity: 0;\\n            }\\n\\n            #\" + uid + \" > iframe.zoid-visible {\\n                opacity: 1;\\n        }\\n        \"));\n                div.appendChild(frame);\n                div.appendChild(prerenderFrame);\n                div.appendChild(style);\n                prerenderFrame.classList.add(\"zoid-visible\");\n                frame.classList.add(\"zoid-invisible\");\n                event.on(EVENT.RENDERED, (function() {\n                    prerenderFrame.classList.remove(\"zoid-visible\");\n                    prerenderFrame.classList.add(\"zoid-invisible\");\n                    frame.classList.remove(\"zoid-invisible\");\n                    frame.classList.add(\"zoid-visible\");\n                    setTimeout((function() {\n                        destroyElement(prerenderFrame);\n                    }), 1);\n                }));\n                event.on(EVENT.RESIZE, (function(_ref2) {\n                    var newWidth = _ref2.width, newHeight = _ref2.height;\n                    \"number\" == typeof newWidth && (div.style.width = toCSS(newWidth));\n                    \"number\" == typeof newHeight && (div.style.height = toCSS(newHeight));\n                }));\n                return div;\n            }\n        }\n        function defaultPrerenderTemplate(_ref) {\n            var doc = _ref.doc, props = _ref.props;\n            var html = doc.createElement(\"html\");\n            var body = doc.createElement(\"body\");\n            var style = doc.createElement(\"style\");\n            var spinner = doc.createElement(\"div\");\n            spinner.classList.add(\"spinner\");\n            props.cspNonce && style.setAttribute(\"nonce\", props.cspNonce);\n            html.appendChild(body);\n            body.appendChild(spinner);\n            body.appendChild(style);\n            style.appendChild(doc.createTextNode(\"\\n            html, body {\\n                width: 100%;\\n                height: 100%;\\n            }\\n\\n            .spinner {\\n                position: fixed;\\n                max-height: 60vmin;\\n                max-width: 60vmin;\\n                height: 40px;\\n                width: 40px;\\n                top: 50%;\\n                left: 50%;\\n                box-sizing: border-box;\\n                border: 3px solid rgba(0, 0, 0, .2);\\n                border-top-color: rgba(33, 128, 192, 0.8);\\n                border-radius: 100%;\\n                animation: rotation .7s infinite linear;\\n            }\\n\\n            @keyframes rotation {\\n                from {\\n                    transform: translateX(-50%) translateY(-50%) rotate(0deg);\\n                }\\n                to {\\n                    transform: translateX(-50%) translateY(-50%) rotate(359deg);\\n                }\\n            }\\n        \"));\n            return html;\n        }\n        var props_defaultNoop = function() {\n            return src_util_noop;\n        };\n        var props_decorateOnce = function(_ref) {\n            return once(_ref.value);\n        };\n        var cleanInstances = cleanup();\n        var cleanZoid = cleanup();\n        function component_component(opts) {\n            var options = function(options) {\n                var tag = options.tag, url = options.url, domain = options.domain, bridgeUrl = options.bridgeUrl, _options$props = options.props, propsDef = void 0 === _options$props ? {} : _options$props, _options$dimensions = options.dimensions, dimensions = void 0 === _options$dimensions ? {} : _options$dimensions, _options$autoResize = options.autoResize, autoResize = void 0 === _options$autoResize ? {} : _options$autoResize, _options$allowedParen = options.allowedParentDomains, allowedParentDomains = void 0 === _options$allowedParen ? \"*\" : _options$allowedParen, _options$attributes = options.attributes, attributes = void 0 === _options$attributes ? {} : _options$attributes, _options$defaultConte = options.defaultContext, defaultContext = void 0 === _options$defaultConte ? CONTEXT.IFRAME : _options$defaultConte, _options$containerTem = options.containerTemplate, containerTemplate = void 0 === _options$containerTem ? defaultContainerTemplate : _options$containerTem, _options$prerenderTem = options.prerenderTemplate, prerenderTemplate = void 0 === _options$prerenderTem ? defaultPrerenderTemplate : _options$prerenderTem, validate = options.validate, _options$eligible = options.eligible, eligible = void 0 === _options$eligible ? function() {\n                    return {\n                        eligible: !0\n                    };\n                } : _options$eligible, _options$logger = options.logger, logger = void 0 === _options$logger ? {\n                    info: src_util_noop\n                } : _options$logger;\n                var name = tag.replace(/-/g, \"_\");\n                var _dimensions$width = dimensions.width, width = void 0 === _dimensions$width ? \"300px\" : _dimensions$width, _dimensions$height = dimensions.height, height = void 0 === _dimensions$height ? \"150px\" : _dimensions$height;\n                propsDef = _extends({}, {\n                    window: {\n                        type: \"object\",\n                        sendToChild: !1,\n                        required: !1,\n                        allowDelegate: !0,\n                        validate: function(_ref2) {\n                            var value = _ref2.value;\n                            if (!isWindow(value) && !window_ProxyWindow.isProxyWindow(value)) throw new Error(\"Expected Window or ProxyWindow\");\n                            if (isWindow(value)) {\n                                if (isWindowClosed(value)) throw new Error(\"Window is closed\");\n                                if (!isSameDomain(value)) throw new Error(\"Window is not same domain\");\n                            }\n                        },\n                        decorate: function(_ref3) {\n                            return setup_toProxyWindow(_ref3.value);\n                        }\n                    },\n                    timeout: {\n                        type: \"number\",\n                        required: !1,\n                        sendToChild: !1\n                    },\n                    close: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref4) {\n                            return _ref4.close;\n                        }\n                    },\n                    focus: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref5) {\n                            return _ref5.focus;\n                        }\n                    },\n                    resize: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref6) {\n                            return _ref6.resize;\n                        }\n                    },\n                    uid: {\n                        type: \"string\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref7) {\n                            return _ref7.uid;\n                        }\n                    },\n                    cspNonce: {\n                        type: \"string\",\n                        required: !1\n                    },\n                    getParent: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref8) {\n                            return _ref8.getParent;\n                        }\n                    },\n                    getParentDomain: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref9) {\n                            return _ref9.getParentDomain;\n                        }\n                    },\n                    show: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref10) {\n                            return _ref10.show;\n                        }\n                    },\n                    hide: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref11) {\n                            return _ref11.hide;\n                        }\n                    },\n                    onDisplay: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onRendered: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onRender: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onClose: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onDestroy: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop,\n                        decorate: props_decorateOnce\n                    },\n                    onResize: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop\n                    },\n                    onFocus: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        allowDelegate: !0,\n                        default: props_defaultNoop\n                    },\n                    onError: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        childDecorate: function(_ref12) {\n                            return _ref12.onError;\n                        }\n                    },\n                    onProps: {\n                        type: \"function\",\n                        required: !1,\n                        sendToChild: !1,\n                        default: props_defaultNoop,\n                        childDecorate: function(_ref13) {\n                            return _ref13.onProps;\n                        }\n                    }\n                }, propsDef);\n                if (!containerTemplate) throw new Error(\"Container template required\");\n                return {\n                    name: name,\n                    tag: tag,\n                    url: url,\n                    domain: domain,\n                    bridgeUrl: bridgeUrl,\n                    propsDef: propsDef,\n                    dimensions: {\n                        width: width,\n                        height: height\n                    },\n                    autoResize: autoResize,\n                    allowedParentDomains: allowedParentDomains,\n                    attributes: attributes,\n                    defaultContext: defaultContext,\n                    containerTemplate: containerTemplate,\n                    prerenderTemplate: prerenderTemplate,\n                    validate: validate,\n                    logger: logger,\n                    eligible: eligible\n                };\n            }(opts);\n            var name = options.name, tag = options.tag, defaultContext = options.defaultContext, propsDef = options.propsDef, eligible = options.eligible;\n            var global = lib_global_getGlobal();\n            var driverCache = {};\n            var instances = [];\n            var isChild = function() {\n                var payload = getChildPayload();\n                return Boolean(payload && payload.tag === tag && payload.childDomain === getDomain());\n            };\n            var registerChild = memoize((function() {\n                if (isChild()) {\n                    if (window.xprops) {\n                        delete global.components[tag];\n                        throw new Error(\"Can not register \" + name + \" as child - child already registered\");\n                    }\n                    var child = function(options) {\n                        var propsDef = options.propsDef, autoResize = options.autoResize, allowedParentDomains = options.allowedParentDomains;\n                        var onPropHandlers = [];\n                        var childPayload = getChildPayload();\n                        var props;\n                        if (!childPayload) throw new Error(\"No child payload found\");\n                        if (\"9_0_63\" !== childPayload.version) throw new Error(\"Parent window has zoid version \" + childPayload.version + \", child window has version 9_0_63\");\n                        var uid = childPayload.uid, parentDomain = childPayload.parentDomain, exports = childPayload.exports, context = childPayload.context, propsRef = childPayload.props;\n                        var parentComponentWindow = function(ref) {\n                            var type = ref.type;\n                            if (\"opener\" === type) return assertExists(\"opener\", getOpener(window));\n                            if (\"parent\" === type && \"number\" == typeof ref.distance) return assertExists(\"parent\", function(win, n) {\n                                void 0 === n && (n = 1);\n                                return function(win, n) {\n                                    void 0 === n && (n = 1);\n                                    var parent = win;\n                                    for (var i = 0; i < n; i++) {\n                                        if (!parent) return;\n                                        parent = utils_getParent(parent);\n                                    }\n                                    return parent;\n                                }(win, getDistanceFromTop(win) - n);\n                            }(window, ref.distance));\n                            if (\"global\" === type && ref.uid && \"string\" == typeof ref.uid) {\n                                var uid = ref.uid;\n                                var ancestor = getAncestor(window);\n                                if (!ancestor) throw new Error(\"Can not find ancestor window\");\n                                for (var _i2 = 0, _getAllFramesInWindow2 = getAllFramesInWindow(ancestor); _i2 < _getAllFramesInWindow2.length; _i2++) {\n                                    var frame = _getAllFramesInWindow2[_i2];\n                                    if (isSameDomain(frame)) {\n                                        var global = lib_global_getGlobal(frame);\n                                        if (global && global.windows && global.windows[uid]) return global.windows[uid];\n                                    }\n                                }\n                            }\n                            throw new Error(\"Unable to find \" + type + \" parent component window\");\n                        }(childPayload.parent);\n                        var parent = setup_deserializeMessage(parentComponentWindow, parentDomain, exports);\n                        var show = parent.show, hide = parent.hide, close = parent.close;\n                        var getParent = function() {\n                            return parentComponentWindow;\n                        };\n                        var getParentDomain = function() {\n                            return parentDomain;\n                        };\n                        var onProps = function(handler) {\n                            onPropHandlers.push(handler);\n                        };\n                        var onError = function(err) {\n                            return promise_ZalgoPromise.try((function() {\n                                if (parent && parent.onError) return parent.onError(err);\n                                throw err;\n                            }));\n                        };\n                        var resize = function(_ref2) {\n                            return parent.resize.fireAndForget({\n                                width: _ref2.width,\n                                height: _ref2.height\n                            });\n                        };\n                        var setProps = function(newProps, origin, isUpdate) {\n                            void 0 === isUpdate && (isUpdate = !1);\n                            var normalizedProps = function(parentComponentWindow, propsDef, props, origin, helpers, isUpdate) {\n                                void 0 === isUpdate && (isUpdate = !1);\n                                var result = {};\n                                for (var _i2 = 0, _Object$keys2 = Object.keys(props); _i2 < _Object$keys2.length; _i2++) {\n                                    var key = _Object$keys2[_i2];\n                                    var prop = propsDef[key];\n                                    if (!prop || !prop.sameDomain || origin === getDomain(window) && isSameDomain(parentComponentWindow)) {\n                                        var value = normalizeChildProp(propsDef, 0, key, props[key], helpers);\n                                        result[key] = value;\n                                        prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);\n                                    }\n                                }\n                                if (!isUpdate) for (var _i4 = 0, _Object$keys4 = Object.keys(propsDef); _i4 < _Object$keys4.length; _i4++) {\n                                    var _key = _Object$keys4[_i4];\n                                    props.hasOwnProperty(_key) || (result[_key] = normalizeChildProp(propsDef, 0, _key, void 0, helpers));\n                                }\n                                return result;\n                            }(parentComponentWindow, propsDef, newProps, origin, {\n                                show: show,\n                                hide: hide,\n                                close: close,\n                                focus: child_focus,\n                                onError: onError,\n                                resize: resize,\n                                onProps: onProps,\n                                getParent: getParent,\n                                getParentDomain: getParentDomain,\n                                uid: uid\n                            }, isUpdate);\n                            props ? extend(props, normalizedProps) : props = normalizedProps;\n                            for (var _i4 = 0; _i4 < onPropHandlers.length; _i4++) (0, onPropHandlers[_i4])(props);\n                        };\n                        var updateProps = function(newProps) {\n                            return promise_ZalgoPromise.try((function() {\n                                return setProps(newProps, parentDomain, !0);\n                            }));\n                        };\n                        return {\n                            init: function() {\n                                return promise_ZalgoPromise.try((function() {\n                                    !function(allowedParentDomains, domain) {\n                                        if (!matchDomain(allowedParentDomains, domain)) throw new Error(\"Can not be rendered by domain: \" + domain);\n                                    }(allowedParentDomains, parentDomain);\n                                    markWindowKnown(parentComponentWindow);\n                                    !function() {\n                                        window.addEventListener(\"beforeunload\", (function() {\n                                            parent.checkClose.fireAndForget();\n                                        }));\n                                        window.addEventListener(\"unload\", (function() {\n                                            parent.checkClose.fireAndForget();\n                                        }));\n                                        onCloseWindow(parentComponentWindow, (function() {\n                                            child_destroy();\n                                        }));\n                                    }();\n                                    return parent.init({\n                                        updateProps: updateProps,\n                                        close: child_destroy\n                                    });\n                                })).then((function() {\n                                    return (_autoResize$width = autoResize.width, width = void 0 !== _autoResize$width && _autoResize$width, \n                                    _autoResize$height = autoResize.height, height = void 0 !== _autoResize$height && _autoResize$height, \n                                    _autoResize$element = autoResize.element, elementReady(void 0 === _autoResize$element ? \"body\" : _autoResize$element).catch(src_util_noop).then((function(element) {\n                                        return {\n                                            width: width,\n                                            height: height,\n                                            element: element\n                                        };\n                                    }))).then((function(_ref3) {\n                                        var width = _ref3.width, height = _ref3.height, element = _ref3.element;\n                                        element && (width || height) && context !== CONTEXT.POPUP && onResize(element, (function(_ref4) {\n                                            resize({\n                                                width: width ? _ref4.width : void 0,\n                                                height: height ? _ref4.height : void 0\n                                            });\n                                        }), {\n                                            width: width,\n                                            height: height\n                                        });\n                                    }));\n                                    var _autoResize$width, width, _autoResize$height, height, _autoResize$element;\n                                })).catch((function(err) {\n                                    onError(err);\n                                }));\n                            },\n                            getProps: function() {\n                                if (props) return props;\n                                setProps(function(parentComponentWindow, domain, _ref) {\n                                    var type = _ref.type, uid = _ref.uid;\n                                    var props;\n                                    if (\"raw\" === type) props = _ref.value; else if (\"uid\" === type) {\n                                        if (!isSameDomain(parentComponentWindow)) throw new Error(\"Parent component window is on a different domain - expected \" + getDomain() + \" - can not retrieve props\");\n                                        var global = lib_global_getGlobal(parentComponentWindow);\n                                        props = assertExists(\"props\", global && global.props[uid]);\n                                    }\n                                    if (!props) throw new Error(\"Could not find props\");\n                                    return setup_deserializeMessage(parentComponentWindow, domain, props);\n                                }(parentComponentWindow, parentDomain, propsRef), parentDomain);\n                                return props;\n                            }\n                        };\n                    }(options);\n                    child.init();\n                    return child;\n                }\n            }));\n            var init = function init(props) {\n                var instance;\n                var _eligible = eligible({\n                    props: props = props || {}\n                }), eligibility = _eligible.eligible, reason = _eligible.reason;\n                var onDestroy = props.onDestroy;\n                props.onDestroy = function() {\n                    instance && eligibility && instances.splice(instances.indexOf(instance), 1);\n                    if (onDestroy) return onDestroy.apply(void 0, arguments);\n                };\n                var parent = parentComponent(options);\n                parent.init();\n                eligibility ? parent.setProps(props) : props.onDestroy && props.onDestroy();\n                cleanInstances.register((function(err) {\n                    parent.destroy(err || new Error(\"zoid destroyed all components\"));\n                }));\n                var _render = function(target, container, context) {\n                    return promise_ZalgoPromise.try((function() {\n                        if (!eligibility) {\n                            var err = new Error(reason || name + \" component is not eligible\");\n                            return parent.destroy(err).then((function() {\n                                throw err;\n                            }));\n                        }\n                        if (!isWindow(target)) throw new Error(\"Must pass window to renderTo\");\n                        return function(props, context) {\n                            return promise_ZalgoPromise.try((function() {\n                                if (props.window) return setup_toProxyWindow(props.window).getType();\n                                if (context) {\n                                    if (context !== CONTEXT.IFRAME && context !== CONTEXT.POPUP) throw new Error(\"Unrecognized context: \" + context);\n                                    return context;\n                                }\n                                return defaultContext;\n                            }));\n                        }(props, context);\n                    })).then((function(finalContext) {\n                        container = function(context, container) {\n                            if (container) {\n                                if (\"string\" != typeof container && !isElement(container)) throw new TypeError(\"Expected string or element selector to be passed\");\n                                return container;\n                            }\n                            if (context === CONTEXT.POPUP) return \"body\";\n                            throw new Error(\"Expected element to be passed to render iframe\");\n                        }(finalContext, container);\n                        return parent.render(target, container, finalContext);\n                    })).catch((function(err) {\n                        return parent.destroy(err).then((function() {\n                            throw err;\n                        }));\n                    }));\n                };\n                instance = _extends({}, parent.getHelpers(), {\n                    isEligible: function() {\n                        return eligibility;\n                    },\n                    clone: function(_temp) {\n                        var _ref3$decorate = (void 0 === _temp ? {} : _temp).decorate;\n                        return init((void 0 === _ref3$decorate ? identity : _ref3$decorate)(props));\n                    },\n                    render: function(container, context) {\n                        return _render(window, container, context);\n                    },\n                    renderTo: function(target, container, context) {\n                        return _render(target, container, context);\n                    }\n                });\n                eligibility && instances.push(instance);\n                return instance;\n            };\n            registerChild();\n            !function() {\n                var allowDelegateListener = on_on(\"zoid_allow_delegate_\" + name, (function() {\n                    return !0;\n                }));\n                var delegateListener = on_on(\"zoid_delegate_\" + name, (function(_ref) {\n                    return {\n                        parent: parentComponent(options, _ref.data.overrides, _ref.source)\n                    };\n                }));\n                cleanZoid.register(allowDelegateListener.cancel);\n                cleanZoid.register(delegateListener.cancel);\n            }();\n            global.components = global.components || {};\n            if (global.components[tag]) throw new Error(\"Can not register multiple components with the same tag: \" + tag);\n            global.components[tag] = !0;\n            return {\n                init: init,\n                instances: instances,\n                driver: function(driverName, dep) {\n                    var drivers = {\n                        react: react,\n                        angular: angular,\n                        vue: vue,\n                        angular2: angular2\n                    };\n                    if (!drivers[driverName]) throw new Error(\"Could not find driver for framework: \" + driverName);\n                    driverCache[driverName] || (driverCache[driverName] = drivers[driverName].register(tag, propsDef, init, dep));\n                    return driverCache[driverName];\n                },\n                isChild: isChild,\n                canRenderTo: function(win) {\n                    return send_send(win, \"zoid_allow_delegate_\" + name).then((function(_ref2) {\n                        return _ref2.data;\n                    })).catch((function() {\n                        return !1;\n                    }));\n                },\n                registerChild: registerChild\n            };\n        }\n        function create(options) {\n            !function() {\n                if (!global_getGlobal().initialized) {\n                    global_getGlobal().initialized = !0;\n                    on = (_ref3 = {\n                        on: on_on,\n                        send: send_send\n                    }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n                        return receive_receiveMessage(message, {\n                            on: on,\n                            send: send\n                        });\n                    };\n                    !function(_ref5) {\n                        var on = _ref5.on, send = _ref5.send;\n                        globalStore().getOrSet(\"postMessageListener\", (function() {\n                            return addEventListener(window, \"message\", (function(event) {\n                                !function(event, _ref4) {\n                                    var on = _ref4.on, send = _ref4.send;\n                                    promise_ZalgoPromise.try((function() {\n                                        var source = event.source || event.sourceElement;\n                                        var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n                                        var data = event.data;\n                                        \"null\" === origin && (origin = \"file://\");\n                                        if (source) {\n                                            if (!origin) throw new Error(\"Post message did not have origin domain\");\n                                            receive_receiveMessage({\n                                                source: source,\n                                                origin: origin,\n                                                data: data\n                                            }, {\n                                                on: on,\n                                                send: send\n                                            });\n                                        }\n                                    }));\n                                }(event, {\n                                    on: on,\n                                    send: send\n                                });\n                            }));\n                        }));\n                    }({\n                        on: on_on,\n                        send: send_send\n                    });\n                    !function(_ref8) {\n                        var on = _ref8.on, send = _ref8.send;\n                        globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n                            var listener = on(\"postrobot_hello\", {\n                                domain: \"*\"\n                            }, (function(_ref3) {\n                                resolveHelloPromise(_ref3.source, {\n                                    domain: _ref3.origin\n                                });\n                                return {\n                                    instanceID: getInstanceID()\n                                };\n                            }));\n                            var parent = getAncestor();\n                            parent && sayHello(parent, {\n                                send: send\n                            }).catch((function(err) {}));\n                            return listener;\n                        }));\n                    }({\n                        on: on_on,\n                        send: send_send\n                    });\n                }\n                var _ref3, on, send, global;\n            }();\n            var comp = component_component(options);\n            var init = function(props) {\n                return comp.init(props);\n            };\n            init.driver = function(name, dep) {\n                return comp.driver(name, dep);\n            };\n            init.isChild = function() {\n                return comp.isChild();\n            };\n            init.canRenderTo = function(win) {\n                return comp.canRenderTo(win);\n            };\n            init.instances = comp.instances;\n            var child = comp.registerChild();\n            child && (window.xprops = init.xprops = child.getProps());\n            return init;\n        }\n        function destroyComponents(err) {\n            var destroyPromise = cleanInstances.all(err);\n            cleanInstances = cleanup();\n            return destroyPromise;\n        }\n        var destroyAll = destroyComponents;\n        function component_destroy(err) {\n            destroyAll();\n            delete window.__zoid_9_0_63__;\n            !function() {\n                !function() {\n                    var responseListeners = globalStore(\"responseListeners\");\n                    for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n                        var hash = _responseListeners$ke2[_i2];\n                        var listener = responseListeners.get(hash);\n                        listener && (listener.cancelled = !0);\n                        responseListeners.del(hash);\n                    }\n                }();\n                (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n                var listener;\n                delete window.__post_robot_10_0_42__;\n            }();\n            return cleanZoid.all(err);\n        }\n    } ]);\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3pvaWQvZGlzdC96b2lkLmZyYW1ld29ya3MuZnJhbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQXVELGdDQUFnQyxDQUF1SjtBQUNsUCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDhCQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhCQUFtQjtBQUMzQixRQUFRLDhCQUFtQjtBQUMzQixRQUFRLDhCQUFtQjtBQUMzQixZQUFZLDhCQUFtQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSw4QkFBbUI7QUFDM0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsUUFBUSw4QkFBbUI7QUFDM0IsaUNBQWlDLDhCQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkVBQTZFLDhCQUFtQjtBQUNoRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsUUFBUSw4QkFBbUI7QUFDM0I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWSw4QkFBbUI7QUFDL0I7QUFDQTtBQUNBLFFBQVEsOEJBQW1CO0FBQzNCLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVEsOEJBQW1CO0FBQzNCLGVBQWUsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3RELEtBQUssb0JBQW9CLDBCQUFtQixFQUFFLCtCQUFtQjtBQUNqRTtBQUNBLFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pELFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pEO0FBQ0EsU0FBUztBQUNULFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pEO0FBQ0EsU0FBUztBQUNULFFBQVEsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2pEO0FBQ0EsU0FBUztB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Q0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxFQUFFO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGFBQWE7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0k7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixrQ0FBa0M7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLDZCQUE2QjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrSUFBa0ksc0NBQXNDO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtRQUErUSxzREFBc0Q7QUFDclU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTLHFDQUFxQztBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLHdFQUF3RTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHVFQUF1RTtBQUN2RSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtFQUErRSxxQ0FBcUM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxzQ0FBc0M7QUFDbko7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYscUNBQXFDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxNQUFNO0FBQ04sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtbmV4dGpzLy4uL25vZGVfbW9kdWxlcy96b2lkL2Rpc3Qvem9pZC5mcmFtZXdvcmtzLmZyYW1lLmpzPzI2YWEiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcInpvaWRcIiwgW10sIGZhY3RvcnkpIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMuem9pZCA9IGZhY3RvcnkoKSA6IHJvb3Quem9pZCA9IGZhY3RvcnkoKTtcbn0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB0aGlzLCAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZHVsZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiAgICAgICAgICAgICAgICBpOiBtb2R1bGVJZCxcbiAgICAgICAgICAgICAgICBsOiAhMSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuICAgICAgICAgICAgbW9kdWxlLmwgPSAhMDtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiTW9kdWxlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiAgICAgICAgICAgIDEgJiBtb2RlICYmICh2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpKTtcbiAgICAgICAgICAgIGlmICg4ICYgbW9kZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgaWYgKDQgJiBtb2RlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoMiAmIG1vZGUgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdmFsdWUpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5zO1xuICAgICAgICB9O1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCBcImFcIiwgZ2V0dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuICAgICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiAgICB9KFsgZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBvcHVwT3BlbkVycm9yXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21fUG9wdXBPcGVuRXJyb3I7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JlYXRlXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGU7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveVwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50X2Rlc3Ryb3k7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveUNvbXBvbmVudHNcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lDb21wb25lbnRzO1xuICAgICAgICB9KSk7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc3Ryb3lBbGxcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lBbGw7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUFJPUF9UWVBFXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBQUk9QX1RZUEU7XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUFJPUF9TRVJJQUxJWkFUSU9OXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBQUk9QX1NFUklBTElaQVRJT047XG4gICAgICAgIH0pKTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ09OVEVYVFwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQ09OVEVYVDtcbiAgICAgICAgfSkpO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFVkVOVFwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gRVZFTlQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgICAgICAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0aWxzX2lzUHJvbWlzZShpdGVtKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBQcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5XaW5kb3cgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LmNvbnN0cnVjdG9yICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuY29uc3RydWN0b3IpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB2YXIgX3RvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKF90b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF90b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgZ2xvYmFsXVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBET01XaW5kb3ddXCIgPT09IG5hbWUpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50aGVuKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpc3BhdGNoZWRFcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzID0gW107XG4gICAgICAgIHZhciBhY3RpdmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBmbHVzaFByb21pc2U7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoQWN0aXZlKCkge1xuICAgICAgICAgICAgaWYgKCFhY3RpdmVDb3VudCAmJiBmbHVzaFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBmbHVzaFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWN0aXZlKCkge1xuICAgICAgICAgICAgYWN0aXZlQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmRBY3RpdmUoKSB7XG4gICAgICAgICAgICBhY3RpdmVDb3VudCAtPSAxO1xuICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvbWlzZV9aYWxnb1Byb21pc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFphbGdvUHJvbWlzZShoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITE7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZXNvbHZlKHJlcyk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0ID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlamVjdChlcnIpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPyB0aGlzLnJlc29sdmUoX3Jlc3VsdCkgOiByZWplY3RlZCAmJiB0aGlzLnJlamVjdChfZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcHJvdG8gPSBaYWxnb1Byb21pc2UucHJvdG90eXBlO1xuICAgICAgICAgICAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKHJlc3VsdCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8ucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKGVycm9yKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWplY3QgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZXJyID0gZXJyb3IgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCByZWplY3QgdG8gYmUgY2FsbGVkIHdpdGggRXJyb3IsIGdvdCBcIiArIF9lcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkIHx8IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXJyb3JIYW5kbGVkIHx8IGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBkaXNwYXRjaGVkRXJyb3JzLmluZGV4T2YoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzW2pdKGVyciwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0oZXJyb3IsIF90aGlzMik7XG4gICAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZWQsIHJlamVjdGVkID0gdGhpcy5yZWplY3RlZCwgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwYXRjaGluZyAmJiAocmVzb2x2ZWQgfHwgcmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oZmlyc3RQcm9taXNlLCBzZWNvbmRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2hhbmRsZXJzJGkgPSBoYW5kbGVyc1tpXSwgb25TdWNjZXNzID0gX2hhbmRsZXJzJGkub25TdWNjZXNzLCBvbkVycm9yID0gX2hhbmRsZXJzJGkub25FcnJvciwgcHJvbWlzZSA9IF9oYW5kbGVycyRpLnByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdDIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvblN1Y2Nlc3MgPyBvblN1Y2Nlc3ModGhpcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIudmFsdWUpIDogcHJvbWlzZS5yZWplY3QoX3Jlc3VsdDIuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyLmVycm9ySGFuZGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHV0aWxzX2lzUHJvbWlzZShfcmVzdWx0MikgPyBfcmVzdWx0MiBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAoX3Jlc3VsdDIucmVzb2x2ZWQgfHwgX3Jlc3VsdDIucmVqZWN0ZWQpID8gX3Jlc3VsdDIucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIudmFsdWUpIDogcHJvbWlzZS5yZWplY3QoX3Jlc3VsdDIuZXJyb3IpIDogY2hhaW4oX3Jlc3VsdDIsIHByb21pc2UpIDogcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gITE7XG4gICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvblN1Y2Nlc3MgJiYgIW9uU3VjY2Vzcy5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3Igc3VjY2VzcyBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25FcnJvciAmJiAhb25FcnJvci5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3IgZXJyb3IgaGFuZGxlclwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbihvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIG9uRXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24ob25GaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uRmluYWxseSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRmluYWxseSAmJiAhb25GaW5hbGx5LmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UuZmluYWxseSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lLCBlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMucmVzb2x2ZWQgfHwgX3RoaXMzLnJlamVjdGVkIHx8IF90aGlzMy5yZWplY3QoZXJyIHx8IG5ldyBFcnJvcihcIlByb21pc2UgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZSArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgIH0pLCB0aW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFByb21pc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb3VsZCBub3QgZmluZCBQcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSA/IHZhbHVlIDogdXRpbHNfaXNQcm9taXNlKHZhbHVlKSA/IG5ldyBaYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pKSA6IChuZXcgWmFsZ29Qcm9taXNlKS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLmFzeW5jUmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihpLCBmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAwID09IChjb3VudCAtPSAxKSAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9tID0gcHJvbWlzZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9tIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbS5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWxzX2lzUHJvbWlzZShwcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb207XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhaW4oaSwgWmFsZ29Qcm9taXNlLnJlc29sdmUocHJvbSksIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAwID09PSBjb3VudCAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmhhc2ggPSBmdW5jdGlvbihwcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYXdhaXRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvbWlzZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBhd2FpdFByb21pc2VzLnB1c2godmFsdWUudGhlbigoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpIDogcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb21pc2VzKSBfbG9vcChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGF3YWl0UHJvbWlzZXMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UubWFwID0gZnVuY3Rpb24oaXRlbXMsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGl0ZW1zLm1hcChtZXRob2QpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5zcGxpY2UocG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfShoYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBaYWxnb1Byb21pc2UudHJ5ID0gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG1ldGhvZCAmJiAhbWV0aG9kLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudHJ5IGV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFphbGdvUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uKF9kZWxheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgX2RlbGF5KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB8fCB1dGlsc19pc1Byb21pc2UodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFphbGdvUHJvbWlzZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihaYWxnbykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZSA9IGZsdXNoUHJvbWlzZSB8fCBuZXcgWmFsZ287XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH0oWmFsZ29Qcm9taXNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlO1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVnZXgoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFdJTkRPV19UWVBFID0ge1xuICAgICAgICAgICAgSUZSQU1FOiBcImlmcmFtZVwiLFxuICAgICAgICAgICAgUE9QVVA6IFwicG9wdXBcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgSUVfV0lOX0FDQ0VTU19FUlJPUiA9IFwiQ2FsbCB3YXMgcmVqZWN0ZWQgYnkgY2FsbGVlLlxcclxcblwiO1xuICAgICAgICBmdW5jdGlvbiBpc0Fib3V0UHJvdG9jb2wod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIHJldHVybiBcImFib3V0OlwiID09PSB3aW4ubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXRpbHNfZ2V0UGFyZW50KHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICBpZiAod2luKSB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4ucGFyZW50ICYmIHdpbi5wYXJlbnQgIT09IHdpbikgcmV0dXJuIHdpbi5wYXJlbnQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3BlbmVyKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICBpZiAod2luICYmICF1dGlsc19nZXRQYXJlbnQod2luKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luLm9wZW5lcjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbERvbWFpbih3aW4pIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gd2luLmxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBsb2NhdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgaWYgKCFwcm90b2NvbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBwcm90b2NvbFwiKTtcbiAgICAgICAgICAgIGlmIChcImZpbGU6XCIgPT09IHByb3RvY29sKSByZXR1cm4gXCJmaWxlOi8vXCI7XG4gICAgICAgICAgICBpZiAoXCJhYm91dDpcIiA9PT0gcHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdXRpbHNfZ2V0UGFyZW50KHdpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBjYW5SZWFkRnJvbVdpbmRvdygpID8gZ2V0QWN0dWFsRG9tYWluKHBhcmVudCkgOiBcImFib3V0Oi8vXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG4gICAgICAgICAgICBpZiAoIWhvc3QpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgaG9zdFwiKTtcbiAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RG9tYWluKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0QWN0dWFsRG9tYWluKHdpbik7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluICYmIHdpbi5tb2NrRG9tYWluICYmIDAgPT09IHdpbi5tb2NrRG9tYWluLmluZGV4T2YoXCJtb2NrOlwiKSA/IHdpbi5tb2NrRG9tYWluIDogZG9tYWluO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU2FtZURvbWFpbih3aW4pIHtcbiAgICAgICAgICAgIGlmICghZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW4sIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmICExID09PSBkZXNjLmVudW1lcmFibGUpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdHVhbERvbWFpbih3aW4pID09PSBnZXRBY3R1YWxEb21haW4od2luZG93KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9KHdpbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RG9tYWluKHdpbmRvdykgPT09IGdldERvbWFpbih3aW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0U2FtZURvbWFpbih3aW4pIHtcbiAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHdpbmRvdyB0byBiZSBzYW1lIGRvbWFpblwiKTtcbiAgICAgICAgICAgIHJldHVybiB3aW47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3RvclBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHZhciBjaGlsZFBhcmVudCA9IHV0aWxzX2dldFBhcmVudChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRQYXJlbnQgPyBjaGlsZFBhcmVudCA9PT0gcGFyZW50IDogLTEgIT09IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDt3aW4ucGFyZW50ICE9PSB3aW47ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2luLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4gPSB3aW4ucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KGNoaWxkKS5pbmRleE9mKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVzKHdpbikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgdmFyIGZyYW1lcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhbWVzID0gd2luLmZyYW1lcztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGZyYW1lcyA9IHdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAoMCA9PT0gbGVuKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDEwMDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gZnJhbWVzW19pXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfZnJhbWUpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX2ZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfZ2V0RnJhbWVzMiA9IGdldEZyYW1lcyh3aW4pOyBfaTMgPCBfZ2V0RnJhbWVzMi5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEZyYW1lczJbX2kzXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzMiA9IGdldEFsbENoaWxkRnJhbWVzKGZyYW1lKTsgX2k1IDwgX2dldEFsbENoaWxkRnJhbWVzMi5sZW5ndGg7IF9pNSsrKSByZXN1bHQucHVzaChfZ2V0QWxsQ2hpbGRGcmFtZXMyW19pNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRUb3Aod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbi50b3ApIHJldHVybiB3aW4udG9wO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgaWYgKHV0aWxzX2dldFBhcmVudCh3aW4pID09PSB3aW4pIHJldHVybiB3aW47XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbmRvdywgd2luKSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luLCB3aW5kb3cpICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzNCA9IGdldEFsbENoaWxkRnJhbWVzKHdpbik7IF9pNyA8IF9nZXRBbGxDaGlsZEZyYW1lczQubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRBbGxDaGlsZEZyYW1lczRbX2k3XTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUudG9wKSByZXR1cm4gZnJhbWUudG9wO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfZ2V0UGFyZW50KGZyYW1lKSA9PT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBbGxGcmFtZXNJbldpbmRvdyh3aW4pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBnZXRUb3Aod2luKTtcbiAgICAgICAgICAgIGlmICghdG9wKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRldGVybWluZSB0b3Agd2luZG93XCIpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLmNvbmNhdChnZXRBbGxDaGlsZEZyYW1lcyh0b3ApLCBbIHRvcCBdKTtcbiAgICAgICAgICAgIC0xID09PSByZXN1bHQuaW5kZXhPZih3aW4pICYmIChyZXN1bHQgPSBbXS5jb25jYXQocmVzdWx0LCBbIHdpbiBdLCBnZXRBbGxDaGlsZEZyYW1lcyh3aW4pKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZnJhbWVXaW5kb3dzID0gW107XG4gICAgICAgIHZhciBpZnJhbWVGcmFtZXMgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3dDbG9zZWQod2luLCBhbGxvd01vY2spIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYWxsb3dNb2NrICYmIChhbGxvd01vY2sgPSAhMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbikgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAod2luLmNsb3NlZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFlcnIgfHwgZXJyLm1lc3NhZ2UgIT09IElFX1dJTl9BQ0NFU1NfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsb3dNb2NrICYmIGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW4ubW9ja2Nsb3NlZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbi5wYXJlbnQgfHwgIXdpbi50b3ApIHJldHVybiAhMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIHZhciBpZnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfShpZnJhbWVXaW5kb3dzLCB3aW4pO1xuICAgICAgICAgICAgaWYgKC0xICE9PSBpZnJhbWVJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGlmcmFtZUZyYW1lc1tpZnJhbWVJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWUuY29udGVudFdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLnBhcmVudE5vZGUpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGZyYW1lLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCAmJiAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhmcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3BhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQ7ICkgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudC5ob3N0IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHBhcmVudC5ob3N0KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9KGZyYW1lKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbiA9IHdpbiB8fCB3aW5kb3cpIHx8IHV0aWxzX2dldFBhcmVudCh3aW4pIHx8IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbnlNYXRjaChjb2xsZWN0aW9uMSwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMTcgPSAwOyBfaTE3IDwgY29sbGVjdGlvbjEubGVuZ3RoOyBfaTE3KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbTEgPSBjb2xsZWN0aW9uMVtfaTE3XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE5ID0gMDsgX2kxOSA8IGNvbGxlY3Rpb24yLmxlbmd0aDsgX2kxOSsrKSBpZiAoaXRlbTEgPT09IGNvbGxlY3Rpb24yW19pMTldKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VGcm9tVG9wKHdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHdpbjtcbiAgICAgICAgICAgIGZvciAoO3BhcmVudDsgKSAocGFyZW50ID0gdXRpbHNfZ2V0UGFyZW50KHBhcmVudCkpICYmIChkaXN0YW5jZSArPSAxKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1NhbWVUb3BXaW5kb3cod2luMSwgd2luMikge1xuICAgICAgICAgICAgdmFyIHRvcDEgPSBnZXRUb3Aod2luMSkgfHwgd2luMTtcbiAgICAgICAgICAgIHZhciB0b3AyID0gZ2V0VG9wKHdpbjIpIHx8IHdpbjI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AxICYmIHRvcDIpIHJldHVybiB0b3AxID09PSB0b3AyO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgdmFyIGFsbEZyYW1lczEgPSBnZXRBbGxGcmFtZXNJbldpbmRvdyh3aW4xKTtcbiAgICAgICAgICAgIHZhciBhbGxGcmFtZXMyID0gZ2V0QWxsRnJhbWVzSW5XaW5kb3cod2luMik7XG4gICAgICAgICAgICBpZiAoYW55TWF0Y2goYWxsRnJhbWVzMSwgYWxsRnJhbWVzMikpIHJldHVybiAhMDtcbiAgICAgICAgICAgIHZhciBvcGVuZXIxID0gZ2V0T3BlbmVyKHRvcDEpO1xuICAgICAgICAgICAgdmFyIG9wZW5lcjIgPSBnZXRPcGVuZXIodG9wMik7XG4gICAgICAgICAgICByZXR1cm4gb3BlbmVyMSAmJiBhbnlNYXRjaChnZXRBbGxGcmFtZXNJbldpbmRvdyhvcGVuZXIxKSwgYWxsRnJhbWVzMikgfHwgb3BlbmVyMiAmJiBhbnlNYXRjaChnZXRBbGxGcmFtZXNJbldpbmRvdyhvcGVuZXIyKSwgYWxsRnJhbWVzMSksIFxuICAgICAgICAgICAgITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hEb21haW4ocGF0dGVybiwgb3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBvcmlnaW4pIHJldHVybiBcIipcIiA9PT0gcGF0dGVybiB8fCBvcmlnaW4gPT09IHBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnZXgob3JpZ2luKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1JlZ2V4KHBhdHRlcm4pID8gaXNSZWdleChvcmlnaW4pID8gcGF0dGVybi50b1N0cmluZygpID09PSBvcmlnaW4udG9TdHJpbmcoKSA6ICFBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgQm9vbGVhbihvcmlnaW4ubWF0Y2gocGF0dGVybikpIDogISFBcnJheS5pc0FycmF5KHBhdHRlcm4pICYmIChBcnJheS5pc0FycmF5KG9yaWdpbikgPyBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSA9PT0gSlNPTi5zdHJpbmdpZnkob3JpZ2luKSA6ICFpc1JlZ2V4KG9yaWdpbikgJiYgcGF0dGVybi5zb21lKChmdW5jdGlvbihzdWJwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoRG9tYWluKHN1YnBhdHRlcm4sIG9yaWdpbik7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERvbWFpbkZyb21VcmwodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLm1hdGNoKC9eKGh0dHBzP3xtb2NrfGZpbGUpOlxcL1xcLy8pID8gdXJsLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAzKS5qb2luKFwiL1wiKSA6IGdldERvbWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uQ2xvc2VXaW5kb3cod2luLCBjYWxsYmFjaywgZGVsYXksIG1heHRpbWUpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVsYXkgJiYgKGRlbGF5ID0gMWUzKTtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gbWF4dGltZSAmJiAobWF4dGltZSA9IDEgLyAwKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICAgICAgIWZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heHRpbWUgPD0gMCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4dGltZSAtPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuV2luZG93ICYmIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouc2VsZiA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnBhcmVudCA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnRvcCA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgXCJfX3VubGlrZWx5X3ZhbHVlX19cIiA9PT0gb2JqLl9fY3Jvc3NfZG9tYWluX3V0aWxzX3dpbmRvd19jaGVja19fKSByZXR1cm4gITE7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInBvc3RNZXNzYWdlXCIgaW4gb2JqICYmIFwic2VsZlwiIGluIG9iaiAmJiBcImxvY2F0aW9uXCIgaW4gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvc2VXaW5kb3cod2luKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0aWxfc2FmZUluZGV4T2YoY29sbGVjdGlvbiwgaXRlbSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiX193ZWFrbWFwX1wiICsgKDFlOSAqIE1hdGgucmFuZG9tKCkgPj4+IDApICsgXCJfX1wiO1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gT2JqZWN0LmZyZWV6ZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RXZWFrTWFwID0gbmV3IFdlYWtNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEtleSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0ZXN0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RXZWFrTWFwLnNldCh0ZXN0S2V5LCBcIl9fdGVzdHZhbHVlX19cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJfX3Rlc3R2YWx1ZV9fXCIgPT09IHRlc3RXZWFrTWFwLmdldCh0ZXN0S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCkpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IG5ldyBXZWFrTWFwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9wcm90byA9IENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlO1xuICAgICAgICAgICAgX3Byb3RvLl9jbGVhbnVwQ2xvc2VkV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3codmFsdWUpICYmIGlzV2luZG93Q2xvc2VkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmlzU2FmZVRvUmVhZFdyaXRlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc1dpbmRvdyhrZXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdID0gdmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG4gICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gd2Vha21hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpbmRleCkgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSAmJiAoZW50cnlbMF0gPSBlbnRyeVsxXSA9IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZihrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldE9yU2V0ID0gZnVuY3Rpb24oa2V5LCBnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgICAgICAgICAgfSkobyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgICAgICAgIHJldHVybiAoX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKG8sIHApIHtcbiAgICAgICAgICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9KShvLCBwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFJlZmxlY3QgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gITE7XG4gICAgICAgICAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuICExO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgUHJveHkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgKGZ1bmN0aW9uKCkge30pKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25zdHJ1Y3RfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29uc3RydWN0X2NvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0IDogZnVuY3Rpb24oUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gWyBudWxsIF07XG4gICAgICAgICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpKTtcbiAgICAgICAgICAgICAgICBDbGFzcyAmJiBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgICAgfSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwTmF0aXZlU3VwZXJfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgICAgICB2YXIgX2NhY2hlID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBNYXAgPyBuZXcgTWFwIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuICh3cmFwTmF0aXZlU3VwZXJfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24oQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gQ2xhc3MgfHwgIShmbiA9IENsYXNzLCAtMSAhPT0gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpKSByZXR1cm4gQ2xhc3M7XG4gICAgICAgICAgICAgICAgdmFyIGZuO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIENsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gX2NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICAgICAgICAgICAgfSkoQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuLm5hbWUgfHwgZm4uX19uYW1lX18gfHwgZm4uZGlzcGxheU5hbWUgfHwgXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm4sIG5hbWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGZuLm5hbWU7XG4gICAgICAgICAgICAgICAgZm4ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBmbi5fX25hbWVfXyA9IGZuLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlNjRlbmNvZGUoc3RyKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBidG9hKSByZXR1cm4gYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAoZnVuY3Rpb24obSwgcDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwMSwgMTYpKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgd2luZG93LmJ0b2Egb3IgQnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlEKCkge1xuICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eHh4XCIucmVwbGFjZSgvLi9nLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0pKSArIFwiX1wiICsgYmFzZTY0ZW5jb2RlKChuZXcgRGF0ZSkudG9JU09TdHJpbmcoKS5zbGljZSgxMSwgMTkpLnJlcGxhY2UoXCJUXCIsIFwiLlwiKSkucmVwbGFjZSgvW15hLXpBLVowLTldL2csIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iamVjdElEcztcbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplQXJncyhhcmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShbXS5zbGljZS5jYWxsKGFyZ3MpLCAoZnVuY3Rpb24oc3Via2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJtZW1vaXplW1wiICsgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMgPSBvYmplY3RJRHMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IG9iaiB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBvYmogJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvYmopIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9IG9iamVjdElEcy5nZXQob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkID0gdHlwZW9mIG9iaiArIFwiOlwiICsgdW5pcXVlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMuc2V0KG9iaiwgdWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1aWQ7XG4gICAgICAgICAgICAgICAgICAgIH0odmFsKSArIFwiXVwiIDogdmFsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50cyBub3Qgc2VyaWFsaXphYmxlIC0tIGNhbiBub3QgYmUgdXNlZCB0byBtZW1vaXplXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEVtcHR5T2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZW1vaXplR2xvYmFsSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gMDtcbiAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZShtZXRob2QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgPSBvcHRpb25zLnRoaXNOYW1lc3BhY2UsIHRoaXNOYW1lc3BhY2UgPSB2b2lkIDAgIT09IF9vcHRpb25zJHRoaXNOYW1lc3BhYyAmJiBfb3B0aW9ucyR0aGlzTmFtZXNwYWMsIGNhY2hlVGltZSA9IG9wdGlvbnMudGltZTtcbiAgICAgICAgICAgIHZhciBzaW1wbGVDYWNoZTtcbiAgICAgICAgICAgIHZhciB0aGlzQ2FjaGU7XG4gICAgICAgICAgICB2YXIgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG4gICAgICAgICAgICB2YXIgbWVtb2l6ZWRGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobWVtb2l6ZUluZGV4IDwgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlO1xuICAgICAgICAgICAgICAgIGNhY2hlID0gdGhpc05hbWVzcGFjZSA/ICh0aGlzQ2FjaGUgPSB0aGlzQ2FjaGUgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCkuZ2V0T3JTZXQodGhpcywgZ2V0RW1wdHlPYmplY3QpIDogc2ltcGxlQ2FjaGUgPSBzaW1wbGVDYWNoZSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemVBcmdzKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZVJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQgJiYgY2FjaGVUaW1lICYmIERhdGUubm93KCkgLSBjYWNoZVJlc3VsdC50aW1lIDwgY2FjaGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVzdWx0KSByZXR1cm4gY2FjaGVSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWVtb2l6ZWRGdW5jdGlvbi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNpbXBsZUNhY2hlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRGdW5jdGlvbiwgKG9wdGlvbnMubmFtZSB8fCBnZXRGdW5jdGlvbk5hbWUobWV0aG9kKSkgKyBcIjo6bWVtb2l6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBtZW1vaXplUHJvbWlzZShtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgY2FjaGVba2V5XSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0pKS5maW5hbGx5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHt9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24sIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6OnByb21pc2VNZW1vaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbmxpbmVNZW1vaXplKG1ldGhvZCwgbG9naWMsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYXJncyAmJiAoYXJncyA9IFtdKTtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IG1ldGhvZC5fX2lubGluZV9tZW1vaXplX2NhY2hlX18gPSBtZXRob2QuX19pbmxpbmVfbWVtb2l6ZV9jYWNoZV9fIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGtleSA9IHNlcmlhbGl6ZUFyZ3MoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNhY2hlW2tleV0gOiBjYWNoZVtrZXldID0gbG9naWMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzcmNfdXRpbF9ub29wKCkge31cbiAgICAgICAgZnVuY3Rpb24gb25jZShtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBjYWxsZWQgPSAhMTtcbiAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6Om9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyLCBsZXZlbCkge1xuICAgICAgICAgICAgdm9pZCAwID09PSBsZXZlbCAmJiAobGV2ZWwgPSAxKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSAzKSByZXR1cm4gXCJzdHJpbmdpZnlFcnJvciBzdGFjayBvdmVyZmxvd1wiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikgcmV0dXJuIFwiPHVua25vd24gZXJyb3I6IFwiICsge30udG9TdHJpbmcuY2FsbChlcnIpICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGVycikgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyICYmIGVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBtZXNzYWdlKSByZXR1cm4gLTEgIT09IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPyBzdGFjayA6IG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjaykgcmV0dXJuIHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLnRvU3RyaW5nICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyLnRvU3RyaW5nID8gZXJyLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvciB3aGlsZSBzdHJpbmdpZnlpbmcgZXJyb3I6IFwiICsgc3RyaW5naWZ5RXJyb3IobmV3RXJyLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbSA/IGl0ZW0gOiBpdGVtICYmIGl0ZW0udG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRvU3RyaW5nID8gaXRlbS50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHRlbmQob2JqLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5hc3NpZ24pIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgc291cmNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChvYmpba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcykgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHJlc3VsdC5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gaWRlbnRpdHkoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2FmZUludGVydmFsKG1ldGhvZCwgdGltZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICAhZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCgpO1xuICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgfSksIHRpbWUpO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWZpbmVMYXp5UHJvcChvYmosIGtleSwgZ2V0dGVyKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIGtleSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5IGtleSBtdXN0IGJlIG51bWJlclwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2Ygb2JqICYmIG51bGwgIT09IG9iaiAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBrZXkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qga2V5IG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheUZyb20oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgKGl0ZW0gPSBvYmopICYmIG51bGwgIT09IGl0ZW0gJiYgXCJbb2JqZWN0IE9iamVjdF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3RPYmplY3Qob2JqKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY29uc3RydWN0b3IpIHJldHVybiAhMTtcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICByZXR1cm4gISFpc09iamVjdE9iamVjdChwcm90b3R5cGUpICYmICEhcHJvdG90eXBlLmhhc093blByb3BlcnR5KFwiaXNQcm90b3R5cGVPZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlT2JqZWN0KGl0ZW0sIHJlcGxhY2VyLCBmdWxsS2V5KSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGZ1bGxLZXkgJiYgKGZ1bGxLZXkgPSBcIlwiKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMYXp5UHJvcChyZXN1bHQsIGksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gZnVsbEtleSA/IGZ1bGxLZXkgKyBcIi5cIiArIGkgOiBcIlwiICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHJlcGxhY2VyKGl0ZW1baV0sIGksIGl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlzUGxhaW5PYmplY3QoY2hpbGQpIHx8IEFycmF5LmlzQXJyYXkoY2hpbGQpKSAmJiAoY2hpbGQgPSByZXBsYWNlT2JqZWN0KGNoaWxkLCByZXBsYWNlciwgaXRlbUtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBfbG9vcDIoaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMYXp5UHJvcChfcmVzdWx0LCBrZXksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gZnVsbEtleSA/IGZ1bGxLZXkgKyBcIi5cIiArIGtleSA6IFwiXCIgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSByZXBsYWNlcihpdGVtW2tleV0sIGtleSwgaXRlbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNQbGFpbk9iamVjdChjaGlsZCkgfHwgQXJyYXkuaXNBcnJheShjaGlsZCkpICYmIChjaGlsZCA9IHJlcGxhY2VPYmplY3QoY2hpbGQsIHJlcGxhY2VyLCBpdGVtS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtKSBfbG9vcDMoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3MgYW4gb2JqZWN0IG9yIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGwgIT0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXRpbF9pc1JlZ2V4KGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHV0aWxfZ2V0T3JTZXQob2JqLCBrZXksIGdldHRlcikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gb2JqW2tleV07XG4gICAgICAgICAgICB2YXIgdmFsID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cChvYmopIHtcbiAgICAgICAgICAgIHZhciB0YXNrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNsZWFuZWQgPSAhMTtcbiAgICAgICAgICAgIHZhciBjbGVhbkVycjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xlYW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW25hbWVdID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWQgPyBtZXRob2QoY2xlYW5FcnIpIDogdGFza3MucHVzaChvbmNlKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QoY2xlYW5FcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWxsOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5FcnIgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7dGFza3MubGVuZ3RoOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0YXNrKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc2VydEV4aXN0cyhuYW1lLCB0aGluZykge1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gdGhpbmcpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiICsgbmFtZSArIFwiIHRvIGJlIHByZXNlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0aWxfRXh0ZW5kYWJsZUVycm9yID0gZnVuY3Rpb24oX0Vycm9yKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHNMb29zZShFeHRlbmRhYmxlRXJyb3IsIF9FcnJvcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBFeHRlbmRhYmxlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczY7XG4gICAgICAgICAgICAgICAgKF90aGlzNiA9IF9FcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXMpLm5hbWUgPSBfdGhpczYuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBzZWxmKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH0oX3RoaXM2KSwgX3RoaXM2LmNvbnN0cnVjdG9yKSA6IF90aGlzNi5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEV4dGVuZGFibGVFcnJvcjtcbiAgICAgICAgfSh3cmFwTmF0aXZlU3VwZXJfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG4gICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRSZWFkeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiY29tcGxldGVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudC5ib2R5KSAmJiBcImludGVyYWN0aXZlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXJsRW5jb2RlKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXD8vZywgXCIlM0ZcIikucmVwbGFjZSgvJi9nLCBcIiUyNlwiKS5yZXBsYWNlKC8jL2csIFwiJTIzXCIpLnJlcGxhY2UoL1xcKy9nLCBcIiUyQlwiKTtcbiAgICAgICAgfVxuICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCAxMCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gcGFyc2VRdWVyeShxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZU1lbW9pemUocGFyc2VRdWVyeSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5U3RyaW5nKSByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gcXVlcnlTdHJpbmcuaW5kZXhPZihcIj1cIikpIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3F1ZXJ5U3RyaW5nJHNwbGl0MiA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKTsgX2kyIDwgX3F1ZXJ5U3RyaW5nJHNwbGl0Mi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gX3F1ZXJ5U3RyaW5nJHNwbGl0MltfaTJdO1xuICAgICAgICAgICAgICAgICAgICAocGFpciA9IHBhaXIuc3BsaXQoXCI9XCIpKVswXSAmJiBwYWlyWzFdICYmIChwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9KSwgWyBxdWVyeVN0cmluZyBdKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleHRlbmRRdWVyeShvcmlnaW5hbFF1ZXJ5LCBwcm9wcykge1xuICAgICAgICAgICAgdm9pZCAwID09PSBwcm9wcyAmJiAocHJvcHMgPSB7fSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHMgJiYgT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb2JqICYmIChvYmogPSB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH0pKS5tYXAoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsRW5jb2RlKGtleSkgKyBcIj1cIiArIHVybEVuY29kZShvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfSkpLmpvaW4oXCImXCIpO1xuICAgICAgICAgICAgfShfZXh0ZW5kcyh7fSwgcGFyc2VRdWVyeShvcmlnaW5hbFF1ZXJ5KSwgcHJvcHMpKSA6IG9yaWdpbmFsUXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCB8fCBudWxsICE9PSBlbGVtZW50ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGVsZW1lbnQgJiYgMSA9PT0gZWxlbWVudC5ub2RlVHlwZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlbGVtZW50LnN0eWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2FmZShpZCwgZG9jKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGRvYyAmJiAoZG9jID0gZG9jdW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGlzRWxlbWVudChpZCkgPyBpZCA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGlkID8gZG9jLnF1ZXJ5U2VsZWN0b3IoaWQpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWFkeShpZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBzdHJpbmdpZnkoaWQpO1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGdldEVsZW1lbnRTYWZlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHJldHVybiByZXNvbHZlKGVsKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiRG9jdW1lbnQgaXMgcmVhZHkgYW5kIGVsZW1lbnQgXCIgKyBuYW1lICsgXCIgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsID0gZ2V0RWxlbWVudFNhZmUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyByZWFkeSBhbmQgZWxlbWVudCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgMTApO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb21fUG9wdXBPcGVuRXJyb3IgPSBmdW5jdGlvbihfRXh0ZW5kYWJsZUVycm9yKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHNMb29zZShQb3B1cE9wZW5FcnJvciwgX0V4dGVuZGFibGVFcnJvcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQb3B1cE9wZW5FcnJvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX0V4dGVuZGFibGVFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUG9wdXBPcGVuRXJyb3I7XG4gICAgICAgIH0odXRpbF9FeHRlbmRhYmxlRXJyb3IpO1xuICAgICAgICB2YXIgYXdhaXRGcmFtZUxvYWRQcm9taXNlcztcbiAgICAgICAgZnVuY3Rpb24gYXdhaXRGcmFtZUxvYWQoZnJhbWUpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXRGcmFtZUxvYWRQcm9taXNlcyA9IGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcCkuaGFzKGZyYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBfcHJvbWlzZSA9IGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuZ2V0KGZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb21pc2UpIHJldHVybiBfcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWZyYW1lV2luZG93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VkID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSBpZnJhbWVXaW5kb3dzW2ldLmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVGcmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lV2luZG93cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuY29udGVudFdpbmRvdykgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVXaW5kb3dzLnB1c2goZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lRnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB9KGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmNvbnRlbnRXaW5kb3cgPyByZXNvbHZlKGZyYW1lKSA6IHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuc2V0KGZyYW1lLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGF3YWl0RnJhbWVXaW5kb3coZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdEZyYW1lTG9hZChmcmFtZSkudGhlbigoZnVuY3Rpb24obG9hZGVkRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZEZyYW1lLmNvbnRlbnRXaW5kb3cpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdpbmRvdyBpbiBpZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZEZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9tX2lmcmFtZShvcHRpb25zLCBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0aW9ucyAmJiAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGUgfHwge307XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbih0YWcsIG9wdGlvbnMsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdGFnICYmICh0YWcgPSBcImRpdlwiKTtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHlsZSAmJiBleHRlbmQoZWxlbWVudC5zdHlsZSwgb3B0aW9ucy5zdHlsZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jbGFzcyAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmlkICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgb3B0aW9ucy5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgZm9yICh2YXIgX2kxMCA9IDAsIF9PYmplY3Qka2V5czIgPSBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpOyBfaTEwIDwgX09iamVjdCRrZXlzMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzMltfaTEwXTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVTaGVldCAmJiBmdW5jdGlvbihlbCwgc3R5bGVUZXh0LCBkb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBkb2MgJiYgKGRvYyA9IHdpbmRvdy5kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlU2hlZXQgPyBlbC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZVRleHQgOiBlbC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc3R5bGVUZXh0KSk7XG4gICAgICAgICAgICAgICAgfShlbGVtZW50LCBvcHRpb25zLnN0eWxlU2hlZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiaWZyYW1lXCIgPT09IHRhZykgdGhyb3cgbmV3IEVycm9yKFwiSWZyYW1lIGh0bWwgY2FuIG5vdCBiZSB3cml0dGVuIHVubGVzcyBjb250YWluZXIgcHJvdmlkZWQgYW5kIGlmcmFtZSBpbiBET01cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH0oXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUcmFuc3BhcmVuY3k6IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9KSxcbiAgICAgICAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIH0sIHN0eWxlKSxcbiAgICAgICAgICAgICAgICBodG1sOiBvcHRpb25zLmh0bWwsXG4gICAgICAgICAgICAgICAgY2xhc3M6IG9wdGlvbnMuY2xhc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzSUUgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRXxFZGdlL2kpO1xuICAgICAgICAgICAgZnJhbWUuaGFzQXR0cmlidXRlKFwiaWRcIikgfHwgZnJhbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgdW5pcXVlSUQoKSk7XG4gICAgICAgICAgICBhd2FpdEZyYW1lTG9hZChmcmFtZSk7XG4gICAgICAgICAgICBjb250YWluZXIgJiYgZnVuY3Rpb24oaWQsIGRvYykge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZG9jICYmIChkb2MgPSBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBnZXRFbGVtZW50U2FmZShpZCwgZG9jKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGVsZW1lbnQ6IFwiICsgc3RyaW5naWZ5KGlkKSk7XG4gICAgICAgICAgICB9KGNvbnRhaW5lcikuYXBwZW5kQ2hpbGQoZnJhbWUpO1xuICAgICAgICAgICAgKG9wdGlvbnMudXJsIHx8IGlzSUUpICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcInNyY1wiLCBvcHRpb25zLnVybCB8fCBcImFib3V0OmJsYW5rXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIob2JqLCBldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaG93RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoaWRlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRWxlbWVudENsb3NlZChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICEoZWwgJiYgZWwucGFyZW50Tm9kZSAmJiBlbC5vd25lckRvY3VtZW50ICYmIGVsLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGVsLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZXNpemUoZWwsIGhhbmRsZXIsIF90ZW1wKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjIgPSB2b2lkIDAgPT09IF90ZW1wID8ge30gOiBfdGVtcCwgX3JlZjIkd2lkdGggPSBfcmVmMi53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9yZWYyJHdpZHRoIHx8IF9yZWYyJHdpZHRoLCBfcmVmMiRoZWlnaHQgPSBfcmVmMi5oZWlnaHQsIGhlaWdodCA9IHZvaWQgMCA9PT0gX3JlZjIkaGVpZ2h0IHx8IF9yZWYyJGhlaWdodCwgX3JlZjIkaW50ZXJ2YWwgPSBfcmVmMi5pbnRlcnZhbCwgaW50ZXJ2YWwgPSB2b2lkIDAgPT09IF9yZWYyJGludGVydmFsID8gMTAwIDogX3JlZjIkaW50ZXJ2YWwsIF9yZWYyJHdpbiA9IF9yZWYyLndpbiwgd2luID0gdm9pZCAwID09PSBfcmVmMiR3aW4gPyB3aW5kb3cgOiBfcmVmMiR3aW47XG4gICAgICAgICAgICB2YXIgY3VycmVudFdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHZhciBjYW5jZWxlZCA9ICExO1xuICAgICAgICAgICAgaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGN1cnJlbnRIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZCAmJiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0oZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAod2lkdGggJiYgbmV3V2lkdGggIT09IGN1cnJlbnRXaWR0aCB8fCBoZWlnaHQgJiYgbmV3SGVpZ2h0ICE9PSBjdXJyZW50SGVpZ2h0KSAmJiBoYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9ic2VydmVyO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBjaGVjayk7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSB3aW4uUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAob2JzZXJ2ZXIgPSBuZXcgd2luLlJlc2l6ZU9ic2VydmVyKGNoZWNrKSkub2JzZXJ2ZShlbCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNhZmVJbnRlcnZhbChjaGVjaywgMTAgKiBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gd2luLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAob2JzZXJ2ZXIgPSBuZXcgd2luLk11dGF0aW9uT2JzZXJ2ZXIoY2hlY2spKS5vYnNlcnZlKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogITFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2FmZUludGVydmFsKGNoZWNrLCAxMCAqIGludGVydmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB0aW1lb3V0ID0gc2FmZUludGVydmFsKGNoZWNrLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNTaGFkb3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvciAoO2VsZW1lbnQucGFyZW50Tm9kZTsgKSBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBTaGFkb3dSb290XVwiID09PSBlbGVtZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiBudWxsO1xuICAgICAgICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIuc3RhY2sgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tEZXRhaWxzID0gLy4qYXQgW14oXSpcXCgoLiopOiguKyk6KC4rKVxcKSQvZ2kuZXhlYyhzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRMb2NhdGlvbiA9IHN0YWNrRGV0YWlscyAmJiBzdGFja0RldGFpbHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NyaXB0TG9jYXRpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMiA9IDAsIF9BcnJheSRwcm90b3R5cGUkc2xpYzIgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKS5yZXZlcnNlKCk7IF9pMjIgPCBfQXJyYXkkcHJvdG90eXBlJHNsaWMyLmxlbmd0aDsgX2kyMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gX0FycmF5JHByb3RvdHlwZSRzbGljMltfaTIyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjICYmIHNjcmlwdC5zcmMgPT09IHNjcmlwdExvY2F0aW9uKSByZXR1cm4gc2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgfSgpKSByZXR1cm4gY3VycmVudFNjcmlwdDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGN1cnJlbnQgc2NyaXB0XCIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBjdXJyZW50VUlEID0gdW5pcXVlSUQoKTtcbiAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFVJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWRcIik7XG4gICAgICAgICAgICBpZiAodWlkICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcbiAgICAgICAgICAgIGlmICgodWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIikpICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcbiAgICAgICAgICAgIHVpZCA9IHVuaXF1ZUlEKCk7XG4gICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiLCB1aWQpO1xuICAgICAgICAgICAgcmV0dXJuIHVpZDtcbiAgICAgICAgfSkpO1xuICAgICAgICBmdW5jdGlvbiB0b1B4KHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiB2YWwpIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKC9eKFswLTldKykocHh8JSkkLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IG1hdGNoIGNzcyB2YWx1ZSBmcm9tIFwiICsgdmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICAgIH0odmFsKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0NTUyh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiID09IHR5cGVvZiB2YWwgPyB0b1B4KHZhbCkgOiBcInN0cmluZ1wiID09IHR5cGVvZiAoc3RyID0gdmFsKSAmJiAvXlswLTldKyUkLy50ZXN0KHN0cikgPyB2YWwgOiB0b1B4KHZhbCk7XG4gICAgICAgICAgICB2YXIgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdsb2JhbF9nZXRHbG9iYWwod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxLZXkgPSBcIl9fcG9zdF9yb2JvdF8xMF8wXzQyX19cIjtcbiAgICAgICAgICAgIHJldHVybiB3aW4gIT09IHdpbmRvdyA/IHdpbltnbG9iYWxLZXldIDogd2luW2dsb2JhbEtleV0gPSB3aW5bZ2xvYmFsS2V5XSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0T2JqID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGdsb2JhbFN0b3JlKGtleSwgZGVmU3RvcmUpIHtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuICAgICAgICAgICAgdm9pZCAwID09PSBkZWZTdG9yZSAmJiAoZGVmU3RvcmUgPSBnZXRPYmopO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2xvYmFsX2dldEdsb2JhbCgpLCBrZXksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBkZWZTdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oc3RvcmVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShzdG9yZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmVLZXksIGRlZlZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KSA/IHN0b3JlW3N0b3JlS2V5XSA6IGRlZlZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihzdG9yZUtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtzdG9yZUtleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKHN0b3JlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVbc3RvcmVLZXldO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRPclNldDogZnVuY3Rpb24oc3RvcmVLZXksIGdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoc3RvcmUsIHN0b3JlS2V5LCBnZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IGRlZlN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFdpbGRDYXJkID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0V2lsZGNhcmQoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpO1xuICAgICAgICAgICAgZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCA9IGdsb2JhbC5XSU5ET1dfV0lMRENBUkQgfHwgbmV3IFdpbGRDYXJkO1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5XSU5ET1dfV0lMRENBUkQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2luZG93U3RvcmUoa2V5LCBkZWZTdG9yZSkge1xuICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG4gICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJ3aW5kb3dTdG9yZVwiKS5nZXRPclNldChrZXksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luU3RvcmUgPSBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuICAgICAgICAgICAgICAgIHZhciBnZXRTdG9yZSA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luU3RvcmUuZ2V0T3JTZXQod2luLCBkZWZTdG9yZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0b3JlKHdpbikuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih3aW4sIGRlZlZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2V0U3RvcmUod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpID8gc3RvcmVba2V5XSA6IGRlZlZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih3aW4sIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RvcmUod2luKVtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnZXRTdG9yZSh3aW4pW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbih3aW4sIGdldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2V0U3RvcmUod2luKSwga2V5LCBnZXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZUlEKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiaW5zdGFuY2VcIikuZ2V0T3JTZXQoXCJpbnN0YW5jZUlEXCIsIHVuaXF1ZUlEKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwgX3JlZikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuICAgICAgICAgICAgdmFyIGhlbGxvUHJvbWlzZXMgPSB3aW5kb3dTdG9yZShcImhlbGxvUHJvbWlzZXNcIik7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQcm9taXNlID0gaGVsbG9Qcm9taXNlcy5nZXQod2luKTtcbiAgICAgICAgICAgIGV4aXN0aW5nUHJvbWlzZSAmJiBleGlzdGluZ1Byb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5ld1Byb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWxsb1Byb21pc2VzLnNldCh3aW4sIG5ld1Byb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2F5SGVsbG8od2luLCBfcmVmNCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVmNC5zZW5kKSh3aW4sIFwicG9zdHJvYm90X2hlbGxvXCIsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG4gICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNSkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBfcmVmNS5vcmlnaW4sIGluc3RhbmNlSUQgPSBfcmVmNS5kYXRhLmluc3RhbmNlSUQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGluc3RhbmNlSURcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCBfcmVmNikge1xuICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luZG93SW5zdGFuY2VJRFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYXlIZWxsbyh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy5pbnN0YW5jZUlEO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXJrV2luZG93S25vd24od2luKSB7XG4gICAgICAgICAgICB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5zZXQod2luLCAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNTZXJpYWxpemVkVHlwZShpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgaXRlbSAmJiBudWxsICE9PSBpdGVtICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0uX190eXBlX187XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5lVHlwZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHZhbCA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSB2YWwgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkodmFsKSA/IFwiYXJyYXlcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJmdW5jdGlvblwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsID8gdmFsIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yXCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbC50aGVuID8gXCJwcm9taXNlXCIgOiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcInJlZ2V4XCIgOiBcIltvYmplY3QgRGF0ZV1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJkYXRlXCIgOiBcIm9iamVjdFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsID8gXCJzdHJpbmdcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCA/IFwibnVtYmVyXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdmFsID8gXCJib29sZWFuXCIgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplVHlwZSh0eXBlLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX190eXBlX186IHR5cGUsXG4gICAgICAgICAgICAgICAgX192YWxfXzogdmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfU0VSSUFMSVpFUjtcbiAgICAgICAgdmFyIFNFUklBTElaRVIgPSAoKF9TRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBfcmVmLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgc3RhY2s6IF9yZWYuc3RhY2ssXG4gICAgICAgICAgICAgICAgY29kZTogX3JlZi5jb2RlLFxuICAgICAgICAgICAgICAgIGRhdGE6IF9yZWYuZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIF9TRVJJQUxJWkVSLnByb21pc2UgPSBmdW5jdGlvbigpIHt9LCBfU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJyZWdleFwiLCB2YWwuc291cmNlKTtcbiAgICAgICAgfSwgX1NFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJkYXRlXCIsIHZhbC50b0pTT04oKSk7XG4gICAgICAgIH0sIF9TRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sIF9TRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSwgX1NFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfU0VSSUFMSVpFUik7XG4gICAgICAgIHZhciBkZWZhdWx0U2VyaWFsaXplcnMgPSB7fTtcbiAgICAgICAgdmFyIF9ERVNFUklBTElaRVI7XG4gICAgICAgIHZhciBERVNFUklBTElaRVIgPSAoKF9ERVNFUklBTElaRVIgPSB7fSkuZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHNlcmlhbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkOyBub3RoaW5nIHRvIGRlc2VyaWFsaXplXCIpO1xuICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IF9yZWYyLnN0YWNrLCBjb2RlID0gX3JlZjIuY29kZSwgZGF0YSA9IF9yZWYyLmRhdGE7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoX3JlZjIubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIGRhdGEgJiYgKGVycm9yLmRhdGEgPSBkYXRhKTtcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2sgKyBcIlxcblxcblwiICsgZXJyb3Iuc3RhY2s7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH0sIF9ERVNFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5kYXRlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sIF9ERVNFUklBTElaRVIuc3RyaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sIF9ERVNFUklBTElaRVIpO1xuICAgICAgICB2YXIgZGVmYXVsdERlc2VyaWFsaXplcnMgPSB7fTtcbiAgICAgICAgbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCAxMCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cFByb3h5V2luZG93cygpIHtcbiAgICAgICAgICAgIHZhciBpZFRvUHJveHlXaW5kb3cgPSBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pZFRvUHJveHlXaW5kb3cka2V5czIgPSBpZFRvUHJveHlXaW5kb3cua2V5cygpOyBfaTIgPCBfaWRUb1Byb3h5V2luZG93JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfaWRUb1Byb3h5V2luZG93JGtleXMyW19pMl07XG4gICAgICAgICAgICAgICAgaWRUb1Byb3h5V2luZG93LmdldChpZCkuc2hvdWxkQ2xlYW4oKSAmJiBpZFRvUHJveHlXaW5kb3cuZGVsKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkV2luZG93KHdpblByb21pc2UsIF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kLCBfcmVmJGlkID0gX3JlZi5pZCwgaWQgPSB2b2lkIDAgPT09IF9yZWYkaWQgPyB1bmlxdWVJRCgpIDogX3JlZiRpZDtcbiAgICAgICAgICAgIHZhciB3aW5kb3dOYW1lUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgd2luZG93VHlwZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbmRvdykge1xuICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW5kb3cpKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgY2xvc2VkLCBjYW4gbm90IGRldGVybWluZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRPcGVuZXIod2luZG93KSA/IFdJTkRPV19UWVBFLlBPUFVQIDogV0lORE9XX1RZUEUuSUZSQU1FO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgd2luZG93TmFtZVByb21pc2UuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICB3aW5kb3dUeXBlUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93VHlwZVByb21pc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRJbnN0YW5jZUlEOiBtZW1vaXplUHJvbWlzZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKGNsb3NlV2luZG93KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIGlzU2FtZURvbWFpbih3aW4pID8gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgOiB3aW5kb3dOYW1lUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93Q2xvc2VkKHdpbik7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldExvY2F0aW9uOiBmdW5jdGlvbihocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGhyZWYuaW5kZXhPZihcIi9cIikpIGhyZWYgPSBcIlwiICsgZG9tYWluICsgaHJlZjsgZWxzZSBpZiAoIWhyZWYubWF0Y2goL15odHRwcz86XFwvXFwvLykgJiYgMCAhPT0gaHJlZi5pbmRleE9mKGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHVybCB0byBiZSBodHRwIG9yIGh0dHBzIHVybCwgb3IgYWJzb2x1dGUgcGF0aCwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoaHJlZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubG9jYXRpb24gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW4ubG9jYXRpb24ucmVwbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbiA9IGhyZWY7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZURvbWFpbiA9IGlzU2FtZURvbWFpbih3aW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLmZyYW1lRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIxID0gMCwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIik7IF9pMjEgPCBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyLmxlbmd0aDsgX2kyMSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9kb2N1bWVudCRxdWVyeVNlbGVjdDJbX2kyMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5jb250ZW50V2luZG93ICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgPT09IHdpbikgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZXQgbmFtZSBmb3IgY3Jvc3MtZG9tYWluIHdpbmRvdzogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dfUHJveHlXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFByb3h5V2luZG93KF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kLCB3aW4gPSBfcmVmMi53aW4sIHNlcmlhbGl6ZWRXaW5kb3cgPSBfcmVmMi5zZXJpYWxpemVkV2luZG93O1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb3h5V2luZG93ID0gITA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSBzZXJpYWxpemVkV2luZG93IHx8IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKS5zZXQodGhpcy5nZXRJRCgpLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB3aW4gJiYgdGhpcy5zZXRXaW5kb3cod2luLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcHJvdG8gPSBQcm94eVdpbmRvdy5wcm90b3R5cGU7XG4gICAgICAgICAgICBfcHJvdG8uZ2V0SUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXRUeXBlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmlzUG9wdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkudGhlbigoZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gV0lORE9XX1RZUEUuUE9QVVA7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uKGhyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TG9jYXRpb24oaHJlZikudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldE5hbWUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LnNldE5hbWUobmFtZSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuY2xvc2UoKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGlzUG9wdXBQcm9taXNlID0gdGhpcy5pc1BvcHVwKCk7XG4gICAgICAgICAgICAgICAgdmFyIGdldE5hbWVQcm9taXNlID0gdGhpcy5nZXROYW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlb3BlblByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaXNQb3B1cDogaXNQb3B1cFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldE5hbWVQcm9taXNlXG4gICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBfcmVmMy5pc1BvcHVwICYmIG5hbWUgJiYgd2luZG93Lm9wZW4oXCJcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHZhciBmb2N1c1Byb21pc2UgPSB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcmVvcGVuUHJvbWlzZSwgZm9jdXNQcm9taXNlIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uaXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmlzQ2xvc2VkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvdztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uc2V0V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmNCkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjQuc2VuZDtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHdpbjtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UucmVzb2x2ZSh0aGlzLmFjdHVhbFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SUQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5zZXQod2luLCB0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uYXdhaXRXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5tYXRjaFdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY1LnNlbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuYWN0dWFsV2luZG93ID8gd2luID09PSBfdGhpczUuYWN0dWFsV2luZG93IDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eUluc3RhbmNlSUQ6IF90aGlzNS5nZXRJbnN0YW5jZUlEKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBrbm93bldpbmRvd0luc3RhbmNlSUQ6IGdldFdpbmRvd0luc3RhbmNlSUQod2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IF9yZWY2LnByb3h5SW5zdGFuY2VJRCA9PT0gX3JlZjYua25vd25XaW5kb3dJbnN0YW5jZUlEO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggJiYgX3RoaXM1LnNldFdpbmRvdyh3aW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8udW53cmFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93IHx8IHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3Byb3RvLmdldEluc3RhbmNlSUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldEluc3RhbmNlSUQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfcHJvdG8uc2hvdWxkQ2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFjdHVhbFdpbmRvdyAmJiBpc1dpbmRvd0Nsb3NlZCh0aGlzLmFjdHVhbFdpbmRvdykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFByb3h5V2luZG93LnVud3JhcCA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikgPyB3aW4udW53cmFwKCkgOiB3aW47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUHJveHlXaW5kb3cuc2VyaWFsaXplID0gZnVuY3Rpb24od2luLCBfcmVmNykge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjcuc2VuZDtcbiAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm94eVdpbmRvdy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3csIF9yZWY4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmOC5zZW5kO1xuICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuZ2V0KHNlcmlhbGl6ZWRXaW5kb3cuaWQpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRXaW5kb3c6IHNlcmlhbGl6ZWRXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmICFpc1dpbmRvdyhvYmopICYmIG9iai5pc1Byb3h5V2luZG93KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmOSkge1xuICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjkuc2VuZDtcbiAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgaWYgKFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luKSkgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsV2luZG93ID0gd2luO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcIndpblRvUHJveHlXaW5kb3dcIikuZ2V0KGFjdHVhbFdpbmRvdykgfHwgbmV3IFByb3h5V2luZG93KHtcbiAgICAgICAgICAgICAgICAgICAgd2luOiBhY3R1YWxXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3c7XG4gICAgICAgIH0oKTtcbiAgICAgICAgZnVuY3Rpb24gYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHNvdXJjZSwgZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuICAgICAgICAgICAgdmFyIHByb3h5V2luZG93TWV0aG9kcyA9IGdsb2JhbFN0b3JlKFwicHJveHlXaW5kb3dNZXRob2RzXCIpO1xuICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHNvdXJjZSkpIHByb3h5V2luZG93TWV0aG9kcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICB9KTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJveHlXaW5kb3dNZXRob2RzLmRlbChpZCk7XG4gICAgICAgICAgICAgICAgbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9KSlbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29rdXBNZXRob2Qoc291cmNlLCBpZCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZFN0b3JlID0gd2luZG93U3RvcmUoXCJtZXRob2RTdG9yZVwiKTtcbiAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RTdG9yZS5nZXRPclNldChzb3VyY2UsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9KSlbaWRdIHx8IHByb3h5V2luZG93TWV0aG9kcy5nZXQoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCBfcmVmMykge1xuICAgICAgICAgICAgb24gPSAoX3JlZiA9IHtcbiAgICAgICAgICAgICAgICBvbjogX3JlZjMub24sXG4gICAgICAgICAgICAgICAgc2VuZDogX3JlZjMuc2VuZFxuICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmLnNlbmQsIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImZ1bmN0aW9uQ2FsbHNcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbihcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiXG4gICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfcmVmMi5zb3VyY2UsIG9yaWdpbiA9IF9yZWYyLm9yaWdpbiwgZGF0YSA9IF9yZWYyLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGRhdGEuaWQsIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGgpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1ldGhvZCAnXCIgKyBuYW1lICsgXCInIHdpdGggaWQ6IFwiICsgZGF0YS5pZCArIFwiIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kU291cmNlID0gbWV0aC5zb3VyY2UsIGRvbWFpbiA9IG1ldGguZG9tYWluLCB2YWwgPSBtZXRoLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kICdcIiArIGRhdGEubmFtZSArIFwiJyBkb21haW4gXCIgKyBKU09OLnN0cmluZ2lmeSh1dGlsX2lzUmVnZXgobWV0aC5kb21haW4pID8gbWV0aC5kb21haW4uc291cmNlIDogbWV0aC5kb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3cobWV0aG9kU291cmNlKSkgcmV0dXJuIG1ldGhvZFNvdXJjZS5tYXRjaFdpbmRvdyhzb3VyY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBjYWxsICdcIiArIGRhdGEubmFtZSArIFwiJyBmYWlsZWQgLSBwcm94eSB3aW5kb3cgZG9lcyBub3QgbWF0Y2ggc291cmNlIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmFwcGx5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0YS5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwub25FcnJvcikgcmV0dXJuIHZhbC5vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICYmIChlcnIuc3RhY2sgPSBcIlJlbW90ZSBjYWxsIHRvIFwiICsgbmFtZSArIFwiKFwiICsgZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGFyZ3MgJiYgKGFyZ3MgPSBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZyb20oYXJncykubWFwKChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBhcmcgPyBcIidcIiArIGFyZyArIFwiJ1wiIDogdm9pZCAwID09PSBhcmcgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gYXJnID8gXCJudWxsXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgYXJnID8gYXJnLnRvU3RyaW5nKCkgOiBBcnJheS5pc0FycmF5KGFyZykgPyBcIlsgLi4uIF1cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGFyZyA/IFwieyAuLi4gfVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBhcmcgPyBcIigpID0+IHsgLi4uIH1cIiA6IFwiPFwiICsgdHlwZW9mIGFyZyArIFwiPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZGF0YS5hcmdzKSArIFwiKSBmYWlsZWRcXG5cXG5cIiArIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIF9yZWYsIG9uLCBzZW5kO1xuICAgICAgICAgICAgdmFyIGlkID0gdmFsLl9faWRfXyB8fCB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSB3aW5kb3dfUHJveHlXaW5kb3cudW53cmFwKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdmFsLl9fbmFtZV9fIHx8IHZhbC5uYW1lIHx8IGtleTtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIG5hbWUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuYW1lLmluZGV4T2YgJiYgMCA9PT0gbmFtZS5pbmRleE9mKFwiYW5vbnltb3VzOjpcIikgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoXCJhbm9ueW1vdXM6OlwiLCBrZXkgKyBcIjo6XCIpKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgZGVzdGluYXRpb24sIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHdpbiwgZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2UgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5fZnVuY3Rpb25cIiwge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwgX3JlZikge1xuICAgICAgICAgICAgdmFyIF9zZXJpYWxpemU7XG4gICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHNlcmlhbGl6ZXJzICYmIChzZXJpYWxpemVycyA9IGRlZmF1bHRTZXJpYWxpemVycyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KG9iaiwgKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc1t0eXBlXSB8fCBTRVJJQUxJWkVSW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplciA/IHNlcmlhbGl6ZXIodmFsLCBrZXkpIDogdmFsO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSByZXN1bHQgPyBcInVuZGVmaW5lZFwiIDogcmVzdWx0O1xuICAgICAgICAgICAgfShvYmosICgoX3NlcmlhbGl6ZSA9IHt9KS5wcm9taXNlID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5femFsZ29fcHJvbWlzZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVuOiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCAoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IF9yZWYub24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogX3JlZi5zZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3codmFsKSB8fCB3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh2YWwpID8gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl93aW5kb3dcIiwgd2luZG93X1Byb3h5V2luZG93LnNlcmlhbGl6ZSh2YWwsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pKSA6IHZhbDtcbiAgICAgICAgICAgIH0sIF9zZXJpYWxpemUpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgX2Rlc2VyaWFsaXplO1xuICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGVzZXJpYWxpemVycykge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVzZXJpYWxpemVycyAmJiAoZGVzZXJpYWxpemVycyA9IGRlZmF1bHREZXNlcmlhbGl6ZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gc3RyKSByZXR1cm4gSlNPTi5wYXJzZShzdHIsIChmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZhbC5fX3R5cGVfXztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsLl9fdmFsX187XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZXJzW3R5cGVdIHx8IERFU0VSSUFMSVpFUlt0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplciA/IGRlc2VyaWFsaXplcih2YWx1ZSwga2V5KSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0obWVzc2FnZSwgKChfZGVzZXJpYWxpemUgPSB7fSkuY3Jvc3NfZG9tYWluX3phbGdvX3Byb21pc2UgPSBmdW5jdGlvbihzZXJpYWxpemVkUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZShfcmVmMi50aGVuKTtcbiAgICAgICAgICAgICAgICB9KDAsIDAsIHNlcmlhbGl6ZWRQcm9taXNlKTtcbiAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fZnVuY3Rpb24gPSBmdW5jdGlvbihzZXJpYWxpemVkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIF9yZWY0LCBfcmVmNSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmNC5pZCwgbmFtZSA9IF9yZWY0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldERlc2VyaWFsaXplZEZ1bmN0aW9uID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHNvdXJjZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBsb29rdXBNZXRob2Qod2luLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRoICYmIG1ldGgudmFsICE9PSBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcikgcmV0dXJuIG1ldGgudmFsLmFwcGx5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmdzID0gW10uc2xpY2UuY2FsbChfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMuZmlyZUFuZEZvcmdldCA/IHNlbmQod2luLCBcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IF9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICExXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX25hbWVfXyA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX29yaWdpbl9fID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19zb3VyY2VfXyA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9faWRfXyA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5maXJlQW5kRm9yZ2V0ID0gZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcjtcbiAgICAgICAgICAgICAgICB9KHNvdXJjZSwgb3JpZ2luLCBzZXJpYWxpemVkRnVuY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX2Rlc2VyaWFsaXplLmNyb3NzX2RvbWFpbl93aW5kb3cgPSBmdW5jdGlvbihzZXJpYWxpemVkV2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkV2luZG93LCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyA9IHt9O1xuICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUy5wb3N0cm9ib3RfcG9zdF9tZXNzYWdlID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAwID09PSBkb21haW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChkb21haW4gPSBcIipcIik7XG4gICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2Uoc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgIH07XG4gICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTLnBvc3Ryb2JvdF9nbG9iYWwgPSBmdW5jdGlvbih3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoIWZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAod2luID0gd2luIHx8IHdpbmRvdykubmF2aWdhdG9yLm1vY2tVc2VyQWdlbnQgfHwgd2luLm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgICAgICB9KHdpbmRvdykubWF0Y2goL01TSUV8cnY6MTF8dHJpZGVudHxlZGdlXFwvMTJ8ZWRnZVxcLzEzL2kpKSB0aHJvdyBuZXcgRXJyb3IoXCJHbG9iYWwgbWVzc2FnaW5nIG5vdCBuZWVkZWQgZm9yIGJyb3dzZXJcIik7XG4gICAgICAgICAgICBpZiAoIWlzU2FtZURvbWFpbih3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgdGhyb3VnaCBnbG9iYWwgZGlzYWJsZWQgYmV0d2VlbiBkaWZmZXJlbnQgZG9tYWluIHdpbmRvd3NcIik7XG4gICAgICAgICAgICBpZiAoITEgIT09IGlzU2FtZVRvcFdpbmRvdyh3aW5kb3csIHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IHVzZSBnbG9iYWwgdG8gY29tbXVuaWNhdGUgYmV0d2VlbiB0d28gZGlmZmVyZW50IHdpbmRvd3MsIG5vdCBiZXR3ZWVuIGZyYW1lc1wiKTtcbiAgICAgICAgICAgIHZhciBmb3JlaWduR2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCh3aW4pO1xuICAgICAgICAgICAgaWYgKCFmb3JlaWduR2xvYmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgcG9zdFJvYm90IGdsb2JhbCBvbiBmb3JlaWduIHdpbmRvd1wiKTtcbiAgICAgICAgICAgIGZvcmVpZ25HbG9iYWwucmVjZWl2ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKCksXG4gICAgICAgICAgICAgICAgZGF0YTogc2VyaWFsaXplZE1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCBtZXNzYWdlLCBfcmVmMikge1xuICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbkJ1ZmZlciA9IHdpbmRvd1N0b3JlKCkuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlciA9IGRvbWFpbkJ1ZmZlci5idWZmZXIgfHwgW107XG4gICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5mbHVzaCA9IGRvbWFpbkJ1ZmZlci5mbHVzaCB8fCBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gc2VyaWFsaXplTWVzc2FnZSh3aW4sIGRvbWFpbiwgKChfcmVmID0ge30pLl9fcG9zdF9yb2JvdF8xMF8wXzQyX18gPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdLCBcbiAgICAgICAgICAgICAgICAgICAgX3JlZiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSBPYmplY3Qua2V5cyhTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc3RyYXRlZ2llcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ3lOYW1lID0gc3RyYXRlZ2llc1tfaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tzdHJhdGVneU5hbWVdKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSBzdHJhdGVnaWVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHBvc3Qtcm9ib3QgbWVzc2FnaW5nIHN0cmF0ZWdpZXMgZmFpbGVkOlxcblxcblwiICsgZXJyb3JzLm1hcCgoZnVuY3Rpb24oZXJyLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIFwiLiBcIiArIHN0cmluZ2lmeUVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiXFxuXFxuXCIpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkJ1ZmZlci5mbHVzaC50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkJ1ZmZlci5mbHVzaDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmdldChoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWxldGVSZXNwb25zZUxpc3RlbmVyKGhhc2gpIHtcbiAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZGVsKGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQoaGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLmhhcyhoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRSZXF1ZXN0TGlzdGVuZXIoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0TGlzdGVuZXJzXCIpO1xuICAgICAgICAgICAgXCIqXCIgPT09IHdpbiAmJiAod2luID0gbnVsbCk7XG4gICAgICAgICAgICBcIipcIiA9PT0gZG9tYWluICYmIChkb21haW4gPSBudWxsKTtcbiAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBnZXQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9yZWYzID0gWyB3aW4sIGdldFdpbGRjYXJkKCkgXTsgX2k0IDwgX3JlZjMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgICAgIHZhciB3aW5RdWFsaWZpZXIgPSBfcmVmM1tfaTRdO1xuICAgICAgICAgICAgICAgIGlmICh3aW5RdWFsaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzLmdldCh3aW5RdWFsaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkxpc3RlbmVycyA9IG5hbWVMaXN0ZW5lcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tkb21haW5dKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW2RvbWFpbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXykgZm9yICh2YXIgX2k2ID0gMCwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMiA9IGRvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fOyBfaTYgPCBfZG9tYWluTGlzdGVuZXJzJF9fRE8yLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZG9tYWluTGlzdGVuZXJzJF9fRE8zID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMltfaTZdLCBsaXN0ZW5lciA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzMubGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hEb21haW4oX2RvbWFpbkxpc3RlbmVycyRfX0RPMy5yZWdleCwgZG9tYWluKSkgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnNbXCIqXCJdKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW1wiKlwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCBfcmVmKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBfcmVmLm9uLCBzZW5kID0gX3JlZi5zZW5kO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcbiAgICAgICAgICAgICAgICB3aW46IHNvdXJjZSxcbiAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbG9nTmFtZSA9IFwicG9zdHJvYm90X21ldGhvZFwiID09PSBtZXNzYWdlLm5hbWUgJiYgbWVzc2FnZS5kYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIG1lc3NhZ2UuZGF0YS5uYW1lID8gbWVzc2FnZS5kYXRhLm5hbWUgKyBcIigpXCIgOiBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBzZW5kUmVzcG9uc2UoYWNrLCBkYXRhLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2s6IGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIHJlc3BvbnNlIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgYWNrIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSwgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBvcHRpb25zLmRvbWFpbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5oYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcInN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcImVycm9yXCIsIG51bGwsIGVycm9yKTtcbiAgICAgICAgICAgIH0pKSBdKS50aGVuKHNyY191dGlsX25vb3ApLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUVycm9yKSByZXR1cm4gb3B0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgYWNrIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgb3B0aW9ucy5kb21haW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWNrID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgcmVzcG9uc2UgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4ob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIChwYXR0ZXJuID0gb3B0aW9ucy5kb21haW4sIFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGF0dGVybikgPyBcIihcIiArIHBhdHRlcm4uam9pbihcIiB8IFwiKSArIFwiKVwiIDogaXNSZWdleChwYXR0ZXJuKSA/IFwiUmVnRXhwKFwiICsgcGF0dGVybi50b1N0cmluZygpIDogcGF0dGVybi50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICBkZWxldGVSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgXCJlcnJvclwiID09PSBtZXNzYWdlLmFjayA/IG9wdGlvbnMucHJvbWlzZS5yZWplY3QobWVzc2FnZS5lcnJvcikgOiBcInN1Y2Nlc3NcIiA9PT0gbWVzc2FnZS5hY2sgJiYgb3B0aW9ucy5wcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UoZXZlbnQsIF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBfcmVmMi5vbiwgc2VuZCA9IF9yZWYyLnNlbmQ7XG4gICAgICAgICAgICB2YXIgcmVjZWl2ZWRNZXNzYWdlcyA9IGdsb2JhbFN0b3JlKFwicmVjZWl2ZWRNZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cgfHwgd2luZG93LmNsb3NlZCB8fCAhZXZlbnQuc291cmNlKSByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlLCBvcmlnaW4gPSBldmVudC5vcmlnaW47XG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBmdW5jdGlvbihtZXNzYWdlLCBzb3VyY2UsIG9yaWdpbiwgX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkTWVzc2FnZSA9IGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBwYXJzZWRNZXNzYWdlICYmIG51bGwgIT09IHBhcnNlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlTWVzc2FnZXMgPSBwYXJzZWRNZXNzYWdlLl9fcG9zdF9yb2JvdF8xMF8wXzQyX187XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlTWVzc2FnZXMpKSByZXR1cm4gcGFyc2VNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KGV2ZW50LmRhdGEsIHNvdXJjZSwgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgb246IG9uLFxuICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgbWFya1dpbmRvd0tub3duKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVzc2FnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW19pMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlLmlkKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLnNldChtZXNzYWdlLmlkLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZChzb3VyY2UpICYmICFtZXNzYWdlLmZpcmVBbmRGb3JnZXQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gbWVzc2FnZS5vcmlnaW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChvcmlnaW4gPSBcImZpbGU6Ly9cIik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVxdWVzdChzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIiA9PT0gbWVzc2FnZS50eXBlICYmIGhhbmRsZUFjayhzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uX29uKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGhhbmRsZXJcIik7XG4gICAgICAgICAgICAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgb3B0aW9ucy5oYW5kbGVyID0gaGFuZGxlciB8fCBvcHRpb25zLmhhbmRsZXI7XG4gICAgICAgICAgICB2YXIgd2luID0gb3B0aW9ucy53aW5kb3c7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gb3B0aW9ucy5kb21haW47XG4gICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyID0gZnVuY3Rpb24gYWRkUmVxdWVzdExpc3RlbmVyKF9yZWY0LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjQubmFtZSwgd2luID0gX3JlZjQud2luLCBkb21haW4gPSBfcmVmNC5kb21haW47XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gYWRkIHJlcXVlc3QgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfd2luMiA9IHdpbjsgX2k4IDwgX3dpbjIubGVuZ3RoOyBfaTgrKykgbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW46IF93aW4yW19pOF1cbiAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBsaXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxMCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uW19pMTBdLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2RvbWFpbjIgPSBkb21haW47IF9pMTIgPCBfZG9tYWluMi5sZW5ndGg7IF9pMTIrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfZG9tYWluMltfaTEyXVxuICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IF9saXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxNCsrKSBfbGlzdGVuZXJzQ29sbGVjdGlvbltfaTE0XS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nTGlzdGVuZXIgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW4gJiYgXCIqXCIgIT09IHdpbiB8fCAod2luID0gZ2V0V2lsZGNhcmQoKSk7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluIHx8IFwiKlwiO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0xpc3RlbmVyKSB0aHJvdyB3aW4gJiYgZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiB3aW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSkgOiBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluTGlzdGVuZXJzID0gdXRpbF9nZXRPclNldChuYW1lTGlzdGVuZXJzLCBuYW1lLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ckRvbWFpbiA9IGRvbWFpbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciByZWdleExpc3RlbmVycztcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhMaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICB1dGlsX2lzUmVnZXgoZG9tYWluKSA/IChyZWdleExpc3RlbmVycyA9IHV0aWxfZ2V0T3JTZXQoZG9tYWluTGlzdGVuZXJzLCBcIl9fZG9tYWluX3JlZ2V4X19cIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfSkpKS5wdXNoKHJlZ2V4TGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIH0pIDogZG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkxpc3RlbmVyc1tzdHJEb21haW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleExpc3RlbmVycy5zcGxpY2UocmVnZXhMaXN0ZW5lcnMuaW5kZXhPZihyZWdleExpc3RlbmVyLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhMaXN0ZW5lcnMubGVuZ3RoIHx8IGRlbGV0ZSBkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRvbWFpbkxpc3RlbmVycykubGVuZ3RoIHx8IGRlbGV0ZSBuYW1lTGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luICYmICFPYmplY3Qua2V5cyhuYW1lTGlzdGVuZXJzKS5sZW5ndGggJiYgcmVxdWVzdExpc3RlbmVycy5kZWwod2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogb3B0aW9ucy5oYW5kbGVyLFxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiBvcHRpb25zLmVycm9ySGFuZGxlciB8fCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd2luZG93OiB3aW4sXG4gICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4gfHwgXCIqXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW5kX3NlbmQgPSBmdW5jdGlvbiBzZW5kKHdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGRvbWFpbk1hdGNoZXIgPSAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLmRvbWFpbiB8fCBcIipcIjtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgLTE7XG4gICAgICAgICAgICB2YXIgY2hpbGRUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDVlMztcbiAgICAgICAgICAgIHZhciBmaXJlQW5kRm9yZ2V0ID0gb3B0aW9ucy5maXJlQW5kRm9yZ2V0IHx8ICExO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKG5hbWUsIHdpbiwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBkb21haW4gJiYgIUFycmF5LmlzQXJyYXkoZG9tYWluKSAmJiAhdXRpbF9pc1JlZ2V4KGRvbWFpbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIEV4cGVjdGVkIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KGRvbWFpbikgKyBcIiB0byBiZSBhIHN0cmluZywgYXJyYXksIG9yIHJlZ2V4XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZW5kIFwiICsgbmFtZSArIFwiLiBUYXJnZXQgd2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICB9KG5hbWUsIHdpbiwgZG9tYWluTWF0Y2hlcik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFBhcmVudCA9IGdldEFuY2VzdG9yKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFBhcmVudCkgcmV0dXJuIGFjdHVhbFBhcmVudCA9PT0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0VG9wKGNoaWxkKSA9PT0gY2hpbGQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxNSA9IDAsIF9nZXRGcmFtZXM4ID0gZ2V0RnJhbWVzKHBhcmVudCk7IF9pMTUgPCBfZ2V0RnJhbWVzOC5sZW5ndGg7IF9pMTUrKykgaWYgKF9nZXRGcmFtZXM4W19pMTVdID09PSBjaGlsZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfSh3aW5kb3csIHdpbikpIHJldHVybiBmdW5jdGlvbih3aW4sIHRpbWVvdXQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB0aW1lb3V0ICYmICh0aW1lb3V0ID0gNWUzKTtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuYW1lICYmIChuYW1lID0gXCJXaW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0od2luKTtcbiAgICAgICAgICAgICAgICAgICAgLTEgIT09IHRpbWVvdXQgJiYgKHByb21pc2UgPSBwcm9taXNlLnRpbWVvdXQodGltZW91dCwgbmV3IEVycm9yKG5hbWUgKyBcIiBkaWQgbm90IGxvYWQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCJtc1wiKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9KHdpbiwgY2hpbGRUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihfdGVtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih3aW4sIHRhcmdldERvbWFpbiwgYWN0dWFsRG9tYWluLCBfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZi5zZW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiB0YXJnZXREb21haW4gPyB0YXJnZXREb21haW4gOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3R1YWxEb21haW4gfHwgc2F5SGVsbG8od2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihub3JtYWxpemVkRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbih0YXJnZXREb21haW4sIHRhcmdldERvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkRvbWFpbiBcIiArIHN0cmluZ2lmeSh0YXJnZXREb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWREb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KHdpbiwgZG9tYWluTWF0Y2hlciwgKHZvaWQgMCA9PT0gX3RlbXAgPyB7fSA6IF90ZW1wKS5kb21haW4sIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHRhcmdldERvbWFpbikge1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0YXJnZXREb21haW47XG4gICAgICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbmFtZSAmJiBkYXRhICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRhdGEubmFtZSA/IGRhdGEubmFtZSArIFwiKClcIiA6IG5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBuYW1lICsgXCJfXCIgKyB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgIGlmICghZmlyZUFuZEZvcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuc2V0KGhhc2gsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfShoYXNoLCByZXNwb25zZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcVByb21pc2VzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYXRjaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxBY2tUaW1lb3V0ID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJrbm93bldpbmRvd3NcIikuZ2V0KHdpbiwgITEpO1xuICAgICAgICAgICAgICAgICAgICB9KHdpbikgPyAxZTQgOiAyZTM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJlc1RpbWVvdXQgPSByZXNwb25zZVRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2tUaW1lb3V0ID0gdG90YWxBY2tUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzVGltZW91dCA9IHRvdGFsUmVzVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2FmZUludGVydmFsKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIFwiICsgKHJlc3BvbnNlTGlzdGVuZXIuYWNrID8gXCJyZXNwb25zZVwiIDogXCJhY2tcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUxpc3RlbmVyLmNhbmNlbGxlZCkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlc3BvbnNlIGxpc3RlbmVyIHdhcyBjYW5jZWxsZWQgZm9yIFwiICsgbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNrVGltZW91dCA9IE1hdGgubWF4KGFja1RpbWVvdXQgLSA1MDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHJlc1RpbWVvdXQgJiYgKHJlc1RpbWVvdXQgPSBNYXRoLm1heChyZXNUaW1lb3V0IC0gNTAwLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VMaXN0ZW5lci5hY2sgfHwgMCAhPT0gYWNrVGltZW91dCA/IDAgPT09IHJlc1RpbWVvdXQgPyBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxSZXNUaW1lb3V0ICsgXCJtc1wiKSkgOiB2b2lkIDAgOiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBhY2sgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsQWNrVGltZW91dCArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMuc3BsaWNlKHJlcVByb21pc2VzLmluZGV4T2YocHJvbWlzZSwgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmlyZUFuZEZvcmdldFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG4gICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJlQW5kRm9yZ2V0ID8gcHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVxdWVzdCBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmosIHtcbiAgICAgICAgICAgICAgICBvbjogb25fb24sXG4gICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBvbjogb25fb24sXG4gICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cF90b1Byb3h5V2luZG93KHdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGliX2dsb2JhbF9nZXRHbG9iYWwod2luKSB7XG4gICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcbiAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZ2V0IGdsb2JhbCBmb3Igd2luZG93IG9uIGRpZmZlcmVudCBkb21haW5cIik7XG4gICAgICAgICAgICB3aW4uX196b2lkXzlfMF82M19fIHx8ICh3aW4uX196b2lkXzlfMF82M19fID0ge30pO1xuICAgICAgICAgICAgcmV0dXJuIHdpbi5fX3pvaWRfOV8wXzYzX187XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UHJveHlPYmplY3Qob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNvdXJjZSAmJiBfdGhpcy5zb3VyY2UgIT09IHdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjYWxsIGdldCBvbiBwcm94eSBvYmplY3QgZnJvbSBhIHJlbW90ZSB3aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUFJPUF9UWVBFID0ge1xuICAgICAgICAgICAgU1RSSU5HOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgT0JKRUNUOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgRlVOQ1RJT046IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIEJPT0xFQU46IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgTlVNQkVSOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgQVJSQVk6IFwiYXJyYXlcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgUFJPUF9TRVJJQUxJWkFUSU9OID0ge1xuICAgICAgICAgICAgSlNPTjogXCJqc29uXCIsXG4gICAgICAgICAgICBET1RJRlk6IFwiZG90aWZ5XCIsXG4gICAgICAgICAgICBCQVNFNjQ6IFwiYmFzZTY0XCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIENPTlRFWFQgPSBXSU5ET1dfVFlQRTtcbiAgICAgICAgdmFyIEVWRU5UID0ge1xuICAgICAgICAgICAgUkVOREVSOiBcInpvaWQtcmVuZGVyXCIsXG4gICAgICAgICAgICBSRU5ERVJFRDogXCJ6b2lkLXJlbmRlcmVkXCIsXG4gICAgICAgICAgICBESVNQTEFZOiBcInpvaWQtZGlzcGxheVwiLFxuICAgICAgICAgICAgRVJST1I6IFwiem9pZC1lcnJvclwiLFxuICAgICAgICAgICAgQ0xPU0U6IFwiem9pZC1jbG9zZVwiLFxuICAgICAgICAgICAgREVTVFJPWTogXCJ6b2lkLWRlc3Ryb3lcIixcbiAgICAgICAgICAgIFBST1BTOiBcInpvaWQtcHJvcHNcIixcbiAgICAgICAgICAgIFJFU0laRTogXCJ6b2lkLXJlc2l6ZVwiLFxuICAgICAgICAgICAgRk9DVVM6IFwiem9pZC1mb2N1c1wiXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkUHJvcChwcm9wc0RlZiwgcHJvcHMsIGtleSwgdmFsdWUsIGhlbHBlcnMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHNEZWYuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5jaGlsZERlY29yYXRlID8gcHJvcC5jaGlsZERlY29yYXRlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdWlkOiBoZWxwZXJzLnVpZCxcbiAgICAgICAgICAgICAgICBjbG9zZTogaGVscGVycy5jbG9zZSxcbiAgICAgICAgICAgICAgICBmb2N1czogaGVscGVycy5mb2N1cyxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBoZWxwZXJzLm9uRXJyb3IsXG4gICAgICAgICAgICAgICAgb25Qcm9wczogaGVscGVycy5vblByb3BzLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogaGVscGVycy5yZXNpemUsXG4gICAgICAgICAgICAgICAgZ2V0UGFyZW50OiBoZWxwZXJzLmdldFBhcmVudCxcbiAgICAgICAgICAgICAgICBnZXRQYXJlbnREb21haW46IGhlbHBlcnMuZ2V0UGFyZW50RG9tYWluLFxuICAgICAgICAgICAgICAgIHNob3c6IGhlbHBlcnMuc2hvdyxcbiAgICAgICAgICAgICAgICBoaWRlOiBoZWxwZXJzLmhpZGVcbiAgICAgICAgICAgIH0pIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDaGlsZFdpbmRvd05hbWUod2luZG93TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlubGluZU1lbW9pemUocGFyc2VDaGlsZFdpbmRvd05hbWUsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvd05hbWUpIHRocm93IG5ldyBFcnJvcihcIk5vIHdpbmRvdyBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIHZhciBfd2luZG93TmFtZSRzcGxpdCA9IHdpbmRvd05hbWUuc3BsaXQoXCJfX1wiKSwgem9pZGNvbXAgPSBfd2luZG93TmFtZSRzcGxpdFsxXSwgbmFtZSA9IF93aW5kb3dOYW1lJHNwbGl0WzJdLCBlbmNvZGVkUGF5bG9hZCA9IF93aW5kb3dOYW1lJHNwbGl0WzNdO1xuICAgICAgICAgICAgICAgIGlmIChcInpvaWRcIiAhPT0gem9pZGNvbXApIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBub3QgcmVuZGVyZWQgYnkgem9pZCAtIGdvdCBcIiArIHpvaWRjb21wKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGNvbXBvbmVudCBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghZW5jb2RlZFBheWxvYWQpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVuY29kZWQgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGF0b2IpIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoW10ubWFwLmNhbGwoYXRvYihzdHIpLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgd2luZG93LmF0b2Igb3IgQnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KGVuY29kZWRQYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVjb2RlIHdpbmRvdyBuYW1lIHBheWxvYWQ6IFwiICsgZW5jb2RlZFBheWxvYWQgKyBcIjogXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgWyB3aW5kb3dOYW1lIF0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldENoaWxkUGF5bG9hZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2hpbGRXaW5kb3dOYW1lKHdpbmRvdy5uYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGlsZF9mb2N1cygpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkX2Rlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xvc2UoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9wc19nZXRRdWVyeVBhcmFtKHByb3AsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHByb3AucXVlcnlQYXJhbSA/IHByb3AucXVlcnlQYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgcHJvcC5xdWVyeVBhcmFtID8gcHJvcC5xdWVyeVBhcmFtIDoga2V5O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFF1ZXJ5VmFsdWUocHJvcCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5xdWVyeVZhbHVlICYmIGlzRGVmaW5lZCh2YWx1ZSkgPyBwcm9wLnF1ZXJ5VmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSA6IHZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudENvbXBvbmVudChvcHRpb25zLCBvdmVycmlkZXMsIHBhcmVudFdpbikge1xuICAgICAgICAgICAgdm9pZCAwID09PSBvdmVycmlkZXMgJiYgKG92ZXJyaWRlcyA9IHt9KTtcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcGFyZW50V2luICYmIChwYXJlbnRXaW4gPSB3aW5kb3cpO1xuICAgICAgICAgICAgdmFyIHByb3BzRGVmID0gb3B0aW9ucy5wcm9wc0RlZiwgY29udGFpbmVyVGVtcGxhdGUgPSBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlLCBwcmVyZW5kZXJUZW1wbGF0ZSA9IG9wdGlvbnMucHJlcmVuZGVyVGVtcGxhdGUsIHRhZyA9IG9wdGlvbnMudGFnLCBuYW1lID0gb3B0aW9ucy5uYW1lLCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLCBkaW1lbnNpb25zID0gb3B0aW9ucy5kaW1lbnNpb25zLCBhdXRvUmVzaXplID0gb3B0aW9ucy5hdXRvUmVzaXplLCB1cmwgPSBvcHRpb25zLnVybCwgZG9tYWluTWF0Y2ggPSBvcHRpb25zLmRvbWFpbjtcbiAgICAgICAgICAgIHZhciBpbml0UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVkRXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgY2xlYW4gPSBjbGVhbnVwKCk7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHZpc2libGU6ICEwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gb3ZlcnJpZGVzLmV2ZW50ID8gb3ZlcnJpZGVzLmV2ZW50IDogKHRyaWdnZXJlZCA9IHt9LCBoYW5kbGVycyA9IHt9LCBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBoYW5kbGVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGlzdC5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTGlzdC5zcGxpY2UoaGFuZGxlckxpc3QuaW5kZXhPZihoYW5kbGVyKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25jZTogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMub24oZXZlbnROYW1lLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKF9pMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlckxpc3RbX2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBoYW5kbGVyTGlzdC5sZW5ndGg7IF9pMisrKSBfbG9vcChfaTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyT25jZTogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyZWRbZXZlbnROYW1lXSkgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkW2V2ZW50TmFtZV0gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgWyBldmVudE5hbWUgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJlZCwgaGFuZGxlcnM7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBvdmVycmlkZXMucHJvcHMgPyBvdmVycmlkZXMucHJvcHMgOiB7fTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UHJveHlXaW47XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb3h5Q29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIGNoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIG9uRXJyb3JPdmVycmlkZSA9IG92ZXJyaWRlcy5vbkVycm9yO1xuICAgICAgICAgICAgdmFyIGdldFByb3h5Q29udGFpbmVyT3ZlcnJpZGUgPSBvdmVycmlkZXMuZ2V0UHJveHlDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc2hvd092ZXJyaWRlID0gb3ZlcnJpZGVzLnNob3c7XG4gICAgICAgICAgICB2YXIgaGlkZU92ZXJyaWRlID0gb3ZlcnJpZGVzLmhpZGU7XG4gICAgICAgICAgICB2YXIgY2xvc2VPdmVycmlkZSA9IG92ZXJyaWRlcy5jbG9zZTtcbiAgICAgICAgICAgIHZhciByZW5kZXJDb250YWluZXJPdmVycmlkZSA9IG92ZXJyaWRlcy5yZW5kZXJDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgZ2V0UHJveHlXaW5kb3dPdmVycmlkZSA9IG92ZXJyaWRlcy5nZXRQcm94eVdpbmRvdztcbiAgICAgICAgICAgIHZhciBzZXRQcm94eVdpbk92ZXJyaWRlID0gb3ZlcnJpZGVzLnNldFByb3h5V2luO1xuICAgICAgICAgICAgdmFyIG9wZW5GcmFtZU92ZXJyaWRlID0gb3ZlcnJpZGVzLm9wZW5GcmFtZTtcbiAgICAgICAgICAgIHZhciBvcGVuUHJlcmVuZGVyRnJhbWVPdmVycmlkZSA9IG92ZXJyaWRlcy5vcGVuUHJlcmVuZGVyRnJhbWU7XG4gICAgICAgICAgICB2YXIgcHJlcmVuZGVyT3ZlcnJpZGUgPSBvdmVycmlkZXMucHJlcmVuZGVyO1xuICAgICAgICAgICAgdmFyIG9wZW5PdmVycmlkZSA9IG92ZXJyaWRlcy5vcGVuO1xuICAgICAgICAgICAgdmFyIG9wZW5QcmVyZW5kZXJPdmVycmlkZSA9IG92ZXJyaWRlcy5vcGVuUHJlcmVuZGVyO1xuICAgICAgICAgICAgdmFyIHdhdGNoRm9yVW5sb2FkT3ZlcnJpZGUgPSBvdmVycmlkZXMud2F0Y2hGb3JVbmxvYWQ7XG4gICAgICAgICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlID0gb3ZlcnJpZGVzLmdldEludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB2YXIgc2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlID0gb3ZlcnJpZGVzLnNldEludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB2YXIgZ2V0UHJvcHNGb3JDaGlsZCA9IGZ1bmN0aW9uKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9PYmplY3Qka2V5czJbX2kyXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgICAgICAgICBwcm9wICYmICExID09PSBwcm9wLnNlbmRUb0NoaWxkIHx8IHByb3AgJiYgcHJvcC5zYW1lRG9tYWluICYmICFtYXRjaERvbWFpbihkb21haW4sIGdldERvbWFpbih3aW5kb3cpKSB8fCAocmVzdWx0W2tleV0gPSBwcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2gocmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlID8gZ2V0SW50ZXJuYWxTdGF0ZU92ZXJyaWRlKCkgOiBpbnRlcm5hbFN0YXRlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGZ1bmN0aW9uKG5ld0ludGVybmFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEludGVybmFsU3RhdGVPdmVycmlkZSA/IHNldEludGVybmFsU3RhdGVPdmVycmlkZShuZXdJbnRlcm5hbFN0YXRlKSA6IGludGVybmFsU3RhdGUgPSBfZXh0ZW5kcyh7fSwgaW50ZXJuYWxTdGF0ZSwgbmV3SW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXRQcm94eVdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eVdpbmRvd092ZXJyaWRlID8gZ2V0UHJveHlXaW5kb3dPdmVycmlkZSgpIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd1Byb3AgPSBwcm9wcy53aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3dQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Byb3h5V2luID0gc2V0dXBfdG9Qcm94eVdpbmRvdyh3aW5kb3dQcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93UHJvcC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm94eVdpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvd19Qcm94eVdpbmRvdyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXRQcm94eUNvbnRhaW5lciA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eUNvbnRhaW5lck92ZXJyaWRlID8gZ2V0UHJveHlDb250YWluZXJPdmVycmlkZShjb250YWluZXIpIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRSZWFkeShjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihjb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzU2hhZG93RWxlbWVudChjb250YWluZXJFbGVtZW50KSAmJiAoY29udGFpbmVyRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dIb3N0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3dSb290ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtlbGVtZW50LnBhcmVudE5vZGU7ICkgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2hhZG93RWxlbWVudChlbGVtZW50KSkgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhZG93Um9vdC5ob3N0KSByZXR1cm4gc2hhZG93Um9vdC5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hhZG93SG9zdCkgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCBpcyBub3QgaW4gc2hhZG93IGRvbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NoYWRvd0VsZW1lbnQoc2hhZG93SG9zdCkpIHRocm93IG5ldyBFcnJvcihcIkhvc3QgZWxlbWVudCBpcyBhbHNvIGluIHNoYWRvdyBkb21cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2xvdE5hbWUgPSBcInNoYWRvdy1zbG90LVwiICsgdW5pcXVlSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNsb3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgc2xvdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChzbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbG90UHJvdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdFByb3ZpZGVyLnNldEF0dHJpYnV0ZShcInNsb3RcIiwgc2xvdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93SG9zdC5hcHBlbmRDaGlsZChzbG90UHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsb3RQcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgICAgfShjb250YWluZXJFbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm94eU9iamVjdChjb250YWluZXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNldFByb3h5V2luID0gZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJveHlXaW5PdmVycmlkZSA/IHNldFByb3h5V2luT3ZlcnJpZGUocHJveHlXaW4pIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3h5V2luID0gcHJveHlXaW47XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3dPdmVycmlkZSA/IHNob3dPdmVycmlkZSgpIDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlOiBzZXRJbnRlcm5hbFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzaG93RWxlbWVudDogY3VycmVudFByb3h5Q29udGFpbmVyID8gY3VycmVudFByb3h5Q29udGFpbmVyLmdldCgpLnRoZW4oc2hvd0VsZW1lbnQpIDogbnVsbFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkZU92ZXJyaWRlID8gaGlkZU92ZXJyaWRlKCkgOiBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGU6IHNldEludGVybmFsU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogITFcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHNob3dFbGVtZW50OiBjdXJyZW50UHJveHlDb250YWluZXIgPyBjdXJyZW50UHJveHlDb250YWluZXIuZ2V0KCkudGhlbihoaWRlRWxlbWVudCkgOiBudWxsXG4gICAgICAgICAgICAgICAgfSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0VXJsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdXJsID8gdXJsKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgICAgICAgICAgfSkgOiB1cmw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBhdHRyaWJ1dGVzID8gYXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgIH0pIDogYXR0cmlidXRlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0Q2hpbGREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluTWF0Y2ggJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZG9tYWluTWF0Y2ggPyBkb21haW5NYXRjaCA6IGdldERvbWFpbkZyb21VcmwoZ2V0VXJsKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnZXREb21haW5NYXRjaGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbk1hdGNoICYmIHV0aWxfaXNSZWdleChkb21haW5NYXRjaCkgPyBkb21haW5NYXRjaCA6IGdldENoaWxkRG9tYWluKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9wZW5GcmFtZSA9IGZ1bmN0aW9uKGNvbnRleHQsIF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luZG93TmFtZSA9IF9yZWYud2luZG93TmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlbkZyYW1lT3ZlcnJpZGUgPyBvcGVuRnJhbWVPdmVycmlkZShjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IHdpbmRvd05hbWVcbiAgICAgICAgICAgICAgICB9KSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkgcmV0dXJuIGdldFByb3h5T2JqZWN0KGRvbV9pZnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHdpbmRvd05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGdldEF0dHJpYnV0ZXMoKS5pZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9wZW5QcmVyZW5kZXJGcmFtZSA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblByZXJlbmRlckZyYW1lT3ZlcnJpZGUgPyBvcGVuUHJlcmVuZGVyRnJhbWVPdmVycmlkZShjb250ZXh0KSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkgcmV0dXJuIGdldFByb3h5T2JqZWN0KGRvbV9pZnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX196b2lkX3ByZXJlbmRlcl9mcmFtZV9fXCIgKyBuYW1lICsgXCJfXCIgKyB1bmlxdWVJRCgpICsgXCJfX1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcInByZXJlbmRlcl9fXCIgKyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBnZXRBdHRyaWJ1dGVzKCkuaWZyYW1lKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvcGVuUHJlcmVuZGVyID0gZnVuY3Rpb24oY29udGV4dCwgcHJveHlXaW4sIHByb3h5UHJlcmVuZGVyRnJhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlblByZXJlbmRlck92ZXJyaWRlID8gb3BlblByZXJlbmRlck92ZXJyaWRlKGNvbnRleHQsIHByb3h5V2luLCBwcm94eVByZXJlbmRlckZyYW1lKSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm94eVByZXJlbmRlckZyYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcm94eSBmcmFtZSB0byBiZSBwYXNzZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlQcmVyZW5kZXJGcmFtZS5nZXQoKS50aGVuKChmdW5jdGlvbihwcmVyZW5kZXJGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lFbGVtZW50KHByZXJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0RnJhbWVXaW5kb3cocHJlcmVuZGVyRnJhbWUpLnRoZW4oKGZ1bmN0aW9uKHByZXJlbmRlckZyYW1lV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHByZXJlbmRlckZyYW1lV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cF90b1Byb3h5V2luZG93KHdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlbmRlciBjb250ZXh0IGF2YWlsYWJsZSBmb3IgXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJveHlXaW4pIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyBldmVudC50cmlnZ2VyKEVWRU5ULkZPQ1VTKSwgY3VycmVudFByb3h5V2luLmZvY3VzKCkgXSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFdpbmRvd1JlZiA9IGZ1bmN0aW9uKHRhcmdldCwgZG9tYWluLCB1aWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluID09PSBnZXREb21haW4od2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsID0gbGliX2dsb2JhbF9nZXRHbG9iYWwod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLndpbmRvd3MgPSBnbG9iYWwud2luZG93cyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLndpbmRvd3NbdWlkXSA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbC53aW5kb3dzW3VpZF07XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2xvYmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCA9PT0gQ09OVEVYVC5QT1BVUCA/IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvcGVuZXJcIlxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGFyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBnZXREaXN0YW5jZUZyb21Ub3Aod2luZG93KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGluaXRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkRXhwb3J0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZENvbXBvbmVudCA9IGNoaWxkRXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRFeHBvcnRzLmNsb3NlLmZpcmVBbmRGb3JnZXQoKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzaXplID0gZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCwgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50cmlnZ2VyKEVWRU5ULlJFU0laRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50cmlnZ2VyKEVWRU5ULkRFU1RST1kpO1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaChzcmNfdXRpbF9ub29wKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuLmFsbChlcnIpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2UuYXN5bmNSZWplY3QoZXJyIHx8IG5ldyBFcnJvcihcIkNvbXBvbmVudCBkZXN0cm95ZWRcIikpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSBtZW1vaXplKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZChjbG9zZU92ZXJyaWRlLl9fc291cmNlX18pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VPdmVycmlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRyaWdnZXIoRVZFTlQuQ0xPU0UpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzdHJveShlcnIgfHwgbmV3IEVycm9yKFwiQ29tcG9uZW50IGNsb3NlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IGZ1bmN0aW9uKGNvbnRleHQsIF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3h5V2luID0gX3JlZjMucHJveHlXaW4sIHByb3h5RnJhbWUgPSBfcmVmMy5wcm94eUZyYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuT3ZlcnJpZGUgPyBvcGVuT3ZlcnJpZGUoY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogcHJveHlXaW4sXG4gICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IHByb3h5RnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IF9yZWYzLndpbmRvd05hbWVcbiAgICAgICAgICAgICAgICB9KSA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSBDT05URVhULklGUkFNRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm94eUZyYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcm94eSBmcmFtZSB0byBiZSBwYXNzZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlGcmFtZS5nZXQoKS50aGVuKChmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdEZyYW1lV2luZG93KGZyYW1lKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lFbGVtZW50KGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3JlcXVlc3RQcm9taXNlcyRnZXQyID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0KHdpbiwgW10pOyBfaTIgPCBfcmVxdWVzdFByb21pc2VzJGdldDIubGVuZ3RoOyBfaTIrKykgX3JlcXVlc3RQcm9taXNlcyRnZXQyW19pMl0ucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBcIiArIChpc1dpbmRvd0Nsb3NlZCh3aW4pID8gXCJjbG9zZWRcIiA6IFwiY2xlYW5lZCB1cFwiKSArIFwiIGJlZm9yZSByZXNwb25zZVwiKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVuZGVyIGNvbnRleHQgYXZhaWxhYmxlIGZvciBcIiArIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlXaW4uc2V0V2luZG93KHdpbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlXaW47XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB3YXRjaEZvclVubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5sb2FkV2luZG93TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJ1bmxvYWRcIiwgb25jZSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95KG5ldyBFcnJvcihcIldpbmRvdyBuYXZpZ2F0ZWQgYXdheVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVBhcmVudFdpbmRvd0xpc3RlbmVyID0gb25DbG9zZVdpbmRvdyhwYXJlbnRXaW4sIGRlc3Ryb3ksIDNlMyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKGNsb3NlUGFyZW50V2luZG93TGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIodW5sb2FkV2luZG93TGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhdGNoRm9yVW5sb2FkT3ZlcnJpZGUpIHJldHVybiB3YXRjaEZvclVubG9hZE92ZXJyaWRlKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjaGVja1dpbmRvd0Nsb3NlID0gZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VkID0gITE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5V2luLmlzQ2xvc2VkKCkudGhlbigoZnVuY3Rpb24oaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZShuZXcgRXJyb3IoXCJEZXRlY3RlZCBjb21wb25lbnQgd2luZG93IGNsb3NlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuZGVsYXkoMjAwKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eVdpbi5pc0Nsb3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oc2Vjb25kSXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWNvbmRJc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZShuZXcgRXJyb3IoXCJEZXRlY3RlZCBjb21wb25lbnQgd2luZG93IGNsb3NlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25FcnJvck92ZXJyaWRlID8gb25FcnJvck92ZXJyaWRlKGVycikgOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGhhbmRsZWRFcnJvcnMuaW5kZXhPZihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRQcm9taXNlLmFzeW5jUmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHJpZ2dlcihFVkVOVC5FUlJPUiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbml0Q2hpbGQub25FcnJvciA9IG9uRXJyb3I7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVGVtcGxhdGUgPSBmdW5jdGlvbihyZW5kZXJlciwgX3JlZjYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIoe1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IF9yZWY2LmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3JlZjYuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdWlkOiBfcmVmNi51aWQsXG4gICAgICAgICAgICAgICAgICAgIGRvYzogX3JlZjYuZG9jLFxuICAgICAgICAgICAgICAgICAgICBmcmFtZTogX3JlZjYuZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lOiBfcmVmNi5wcmVyZW5kZXJGcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHByZXJlbmRlciA9IGZ1bmN0aW9uKHByb3h5UHJlcmVuZGVyV2luLCBfcmVmNykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3JlZjcuY29udGV4dCwgdWlkID0gX3JlZjcudWlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVyZW5kZXJPdmVycmlkZSA/IHByZXJlbmRlck92ZXJyaWRlKHByb3h5UHJlcmVuZGVyV2luLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgfSkgOiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlcmVuZGVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVyZW5kZXJXaW5kb3cgPSBwcm94eVByZXJlbmRlcldpbi5nZXRXaW5kb3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVyZW5kZXJXaW5kb3cgJiYgaXNTYW1lRG9tYWluKHByZXJlbmRlcldpbmRvdykgJiYgZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4ubG9jYXRpb24uaHJlZikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJhYm91dDpibGFua1wiID09PSB3aW4ubG9jYXRpb24uaHJlZikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByZXJlbmRlcldpbmRvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gKHByZXJlbmRlcldpbmRvdyA9IGFzc2VydFNhbWVEb21haW4ocHJlcmVuZGVyV2luZG93KSkuZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gcmVuZGVyVGVtcGxhdGUocHJlcmVuZGVyVGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYzogZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSBkb2MpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHByZXJlbmRlciB0ZW1wbGF0ZSB0byBoYXZlIGJlZW4gY3JlYXRlZCB3aXRoIGRvY3VtZW50IGZyb20gY2hpbGQgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24od2luLCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImh0bWxcIiAhPT0gdGFnKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGJlIGh0bWwsIGdvdCBcIiArIHRhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gd2luLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9hcnJheUZyb20yID0gYXJyYXlGcm9tKGRvY3VtZW50RWxlbWVudC5jaGlsZHJlbik7IF9pNiA8IF9hcnJheUZyb20yLmxlbmd0aDsgX2k2KyspIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChfYXJyYXlGcm9tMltfaTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pOCA9IDAsIF9hcnJheUZyb200ID0gYXJyYXlGcm9tKGVsLmNoaWxkcmVuKTsgX2k4IDwgX2FycmF5RnJvbTQubGVuZ3RoOyBfaTgrKykgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKF9hcnJheUZyb200W19pOF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHByZXJlbmRlcldpbmRvdywgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2F1dG9SZXNpemUkd2lkdGggPSBhdXRvUmVzaXplLndpZHRoLCB3aWR0aCA9IHZvaWQgMCAhPT0gX2F1dG9SZXNpemUkd2lkdGggJiYgX2F1dG9SZXNpemUkd2lkdGgsIF9hdXRvUmVzaXplJGhlaWdodCA9IGF1dG9SZXNpemUuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgIT09IF9hdXRvUmVzaXplJGhlaWdodCAmJiBfYXV0b1Jlc2l6ZSRoZWlnaHQsIF9hdXRvUmVzaXplJGVsZW1lbnQgPSBhdXRvUmVzaXplLmVsZW1lbnQsIGVsZW1lbnQgPSB2b2lkIDAgPT09IF9hdXRvUmVzaXplJGVsZW1lbnQgPyBcImJvZHlcIiA6IF9hdXRvUmVzaXplJGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbWVudCA9IGdldEVsZW1lbnRTYWZlKGVsZW1lbnQsIGRvYykpICYmICh3aWR0aCB8fCBoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlcmVuZGVyUmVzaXplTGlzdGVuZXIgPSBvblJlc2l6ZShlbGVtZW50LCAoZnVuY3Rpb24oX3JlZjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggPyBfcmVmOC53aWR0aCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBfcmVmOC5oZWlnaHQgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogcHJlcmVuZGVyV2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULlJFTkRFUkVELCBwcmVyZW5kZXJSZXNpemVMaXN0ZW5lci5jYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZW5kZXJDb250YWluZXIgPSBmdW5jdGlvbihwcm94eUNvbnRhaW5lciwgX3JlZjkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJveHlGcmFtZSA9IF9yZWY5LnByb3h5RnJhbWUsIHByb3h5UHJlcmVuZGVyRnJhbWUgPSBfcmVmOS5wcm94eVByZXJlbmRlckZyYW1lLCBjb250ZXh0ID0gX3JlZjkuY29udGV4dCwgdWlkID0gX3JlZjkudWlkO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJDb250YWluZXJPdmVycmlkZSA/IHJlbmRlckNvbnRhaW5lck92ZXJyaWRlKHByb3h5Q29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IHByb3h5RnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3h5UHJlcmVuZGVyRnJhbWU6IHByb3h5UHJlcmVuZGVyRnJhbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgfSkgOiBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBwcm94eUNvbnRhaW5lci5nZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgZnJhbWU6IHByb3h5RnJhbWUgPyBwcm94eUZyYW1lLmdldCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyRnJhbWU6IHByb3h5UHJlcmVuZGVyRnJhbWUgPyBwcm94eVByZXJlbmRlckZyYW1lLmdldCgpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxTdGF0ZTogZ2V0SW50ZXJuYWxTdGF0ZSgpXG4gICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfcmVmMTAuY29udGFpbmVyLCB2aXNpYmxlID0gX3JlZjEwLmludGVybmFsU3RhdGUudmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyQ29udGFpbmVyID0gcmVuZGVyVGVtcGxhdGUoY29udGFpbmVyVGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWU6IF9yZWYxMC5mcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lOiBfcmVmMTAucHJlcmVuZGVyRnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2M6IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGUgfHwgaGlkZUVsZW1lbnQoaW5uZXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBpbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyV2F0Y2hlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gb25jZShoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYWNyaWZpY2lhbEZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYWNyaWZpY2lhbEZyYW1lV2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTggPSAwOyBfaTE4IDwgbXV0YXRpb25PYnNlcnZlcnMubGVuZ3RoOyBfaTE4KyspIG11dGF0aW9uT2JzZXJ2ZXJzW19pMThdLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgJiYgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhY3JpZmljaWFsRnJhbWVXaW4gJiYgc2FjcmlmaWNpYWxGcmFtZVdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIGVsZW1lbnRDbG9zZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWNyaWZpY2lhbEZyYW1lICYmIGRlc3Ryb3lFbGVtZW50KHNhY3JpZmljaWFsRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRDbG9zZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50Q2xvc2VkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRDbG9zZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25FbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDttdXRhdGlvbkVsZW1lbnQ7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRWxlbWVudENsb3NlZChlbGVtZW50KSAmJiBlbGVtZW50Q2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUobXV0YXRpb25FbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0OiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbk9ic2VydmVycy5wdXNoKG11dGF0aW9uT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25FbGVtZW50ID0gbXV0YXRpb25FbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNhY3JpZmljaWFsRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpKS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiX19kZXRlY3RfY2xvc2VfXCIgKyB1bmlxdWVJRCgpICsgXCJfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWNyaWZpY2lhbEZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdEZyYW1lV2luZG93KHNhY3JpZmljaWFsRnJhbWUpLnRoZW4oKGZ1bmN0aW9uKGZyYW1lV2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzYWNyaWZpY2lhbEZyYW1lV2luID0gYXNzZXJ0U2FtZURvbWFpbihmcmFtZVdpbikpLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgZWxlbWVudENsb3NlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc2FjcmlmaWNpYWxGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzYWZlSW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VsZW1lbnRDbG9zZWQoZWxlbWVudCkgJiYgZWxlbWVudENsb3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxZTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oaW5uZXJDb250YWluZXIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2UobmV3IEVycm9yKFwiRGV0ZWN0ZWQgY29udGFpbmVyIGVsZW1lbnQgcmVtb3ZlZCBmcm9tIERPTVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcldhdGNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lFbGVtZW50KGlubmVyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UHJveHlDb250YWluZXIgPSBnZXRQcm94eU9iamVjdChpbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldEhlbHBlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICBmb2N1czogZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogcmVzaXplLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogdXBkYXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzZXRQcm9wcyA9IGZ1bmN0aW9uKG5ld1Byb3BzLCBpc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaXNVcGRhdGUgJiYgKGlzVXBkYXRlID0gITEpO1xuICAgICAgICAgICAgICAgIHZhciBoZWxwZXJzID0gZ2V0SGVscGVycygpO1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbihwcm9wc0RlZiwgcHJvcHMsIGlucHV0UHJvcHMsIGhlbHBlcnMsIGlzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gaXNVcGRhdGUgJiYgKGlzVXBkYXRlID0gITEpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocHJvcHMsIGlucHV0UHJvcHMgPSBpbnB1dFByb3BzIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lcyA9IGlzVXBkYXRlID8gW10gOiBbXS5jb25jYXQoT2JqZWN0LmtleXMocHJvcHNEZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKGlucHV0UHJvcHMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXMyW19pMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gcHJvcE5hbWVzLmluZGV4T2Yoa2V5KSAmJiBwcm9wTmFtZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGlhc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhlbHBlcnMuc3RhdGUsIGNsb3NlID0gaGVscGVycy5jbG9zZSwgZm9jdXMgPSBoZWxwZXJzLmZvY3VzLCBldmVudCA9IGhlbHBlcnMuZXZlbnQsIG9uRXJyb3IgPSBoZWxwZXJzLm9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHByb3BOYW1lcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleSA9IHByb3BOYW1lc1tfaTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BEZWYgPSBwcm9wc0RlZltfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0UHJvcHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcERlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGlhcyA9IHByb3BEZWYuYWxpYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc0RlZmluZWQodmFsdWUpICYmIGlzRGVmaW5lZChpbnB1dFByb3BzW2FsaWFzXSkgJiYgKHZhbHVlID0gaW5wdXRQcm9wc1thbGlhc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzLnB1c2goYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wRGVmLnZhbHVlICYmICh2YWx1ZSA9IHByb3BEZWYudmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1czogZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNEZWZpbmVkKHZhbHVlKSAmJiBwcm9wRGVmLmRlZmF1bHQgJiYgKHZhbHVlID0gcHJvcERlZi5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkgJiYgKFwiYXJyYXlcIiA9PT0gcHJvcERlZi50eXBlID8gIUFycmF5LmlzQXJyYXkodmFsdWUpIDogdHlwZW9mIHZhbHVlICE9PSBwcm9wRGVmLnR5cGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcCBpcyBub3Qgb2YgdHlwZSBcIiArIHByb3BEZWYudHlwZSArIFwiOiBcIiArIF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW19rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgYWxpYXNlcy5sZW5ndGg7IF9pNisrKSBkZWxldGUgcHJvcHNbYWxpYXNlc1tfaTZdXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX09iamVjdCRrZXlzNCA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2k4IDwgX09iamVjdCRrZXlzNC5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleTIgPSBfT2JqZWN0JGtleXM0W19pOF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Byb3BEZWYgPSBwcm9wc0RlZltfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3ZhbHVlID0gcHJvcHNbX2tleTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Byb3BEZWYgJiYgaXNEZWZpbmVkKF92YWx1ZSkgJiYgX3Byb3BEZWYuZGVjb3JhdGUgJiYgKHByb3BzW19rZXkyXSA9IF9wcm9wRGVmLmRlY29yYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfT2JqZWN0JGtleXM2ID0gT2JqZWN0LmtleXMocHJvcHNEZWYpOyBfaTEwIDwgX09iamVjdCRrZXlzNi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9rZXkzID0gX09iamVjdCRrZXlzNltfaTEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gcHJvcHNEZWZbX2tleTNdLnJlcXVpcmVkICYmICFpc0RlZmluZWQocHJvcHNbX2tleTNdKSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcm9wIFwiJyArIF9rZXkzICsgJ1wiIHRvIGJlIGRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0ocHJvcHNEZWYsIHByb3BzLCBuZXdQcm9wcywgaGVscGVycywgaXNVcGRhdGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVQcm9wcyA9IGZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgc2V0UHJvcHMobmV3UHJvcHMsICEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2UudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHlXaW4gPSBjdXJyZW50UHJveHlXaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCAmJiBwcm94eVdpbikgcmV0dXJuIGdldFByb3BzRm9yQ2hpbGQoZ2V0RG9tYWluTWF0Y2hlcigpKS50aGVuKChmdW5jdGlvbihjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQudXBkYXRlUHJvcHMoY2hpbGRQcm9wcykuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1dpbmRvd0Nsb3NlKHByb3h5V2luKS50aGVuKChmdW5jdGlvbihjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUkVOREVSLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9uUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vbihFVkVOVC5ESVNQTEFZLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLm9uRGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUkVOREVSRUQsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25SZW5kZXJlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuQ0xPU0UsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuREVTVFJPWSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vbkRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULlJFU0laRSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuRk9DVVMsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub25Gb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQub24oRVZFTlQuUFJPUFMsIChmdW5jdGlvbihuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5vblByb3BzKG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULkVSUk9SLCAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzICYmIHByb3BzLm9uRXJyb3IgPyBwcm9wcy5vbkVycm9yKGVycikgOiBpbml0UHJvbWlzZS5yZWplY3QoZXJyKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbi5yZWdpc3RlcihldmVudC5yZXNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24odGFyZ2V0LCBjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gXCJ6b2lkLVwiICsgdGFnICsgXCItXCIgKyB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbk1hdGNoZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZERvbWFpbiA9IGdldENoaWxkRG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24odGFyZ2V0LCBkb21haW4sIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVRvcFdpbmRvdyh3aW5kb3csIHRhcmdldCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IHJlbmRlclRvIGFuIGFkamFjZW50IGZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oZG9tYWluLCBvcmlnaW4pICYmICFpc1NhbWVEb21haW4odGFyZ2V0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZW5kZXIgcmVtb3RlbHkgdG8gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIC0gY2FuIG9ubHkgcmVuZGVyIHRvIFwiICsgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBjb250YWluZXIpIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBwYXNzZWQgdG8gcmVuZGVyVG8gbXVzdCBiZSBhIHN0cmluZyBzZWxlY3RvciwgZ290IFwiICsgdHlwZW9mIGNvbnRhaW5lciArIFwiIH1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSh0YXJnZXQsIGRvbWFpbiwgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZVByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHdpbmRvdykgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHQsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGVQcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfT2JqZWN0JGtleXM0ID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaTQgPCBfT2JqZWN0JGtleXM0Lmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IF9PYmplY3Qka2V5czRbX2k0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wRGVmID0gcHJvcHNEZWZbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcERlZiAmJiBwcm9wRGVmLmFsbG93RGVsZWdhdGUgJiYgKGRlbGVnYXRlUHJvcHNbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRPdmVycmlkZXNQcm9taXNlID0gc2VuZF9zZW5kKHRhcmdldCwgXCJ6b2lkX2RlbGVnYXRlX1wiICsgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGRlbGVnYXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEludGVybmFsU3RhdGU6IGdldEludGVybmFsU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZTogc2V0SW50ZXJuYWxTdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb21wID0gX3JlZjExLmRhdGEucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQodGFyZ2V0KSkgcmV0dXJuIHBhcmVudENvbXAuZGVzdHJveShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudENvbXAuZ2V0RGVsZWdhdGVPdmVycmlkZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWxlZ2F0ZSByZW5kZXJpbmcuIFBvc3NpYmx5IHRoZSBjb21wb25lbnQgaXMgbm90IGxvYWRlZCBpbiB0aGUgdGFyZ2V0IHdpbmRvdy5cXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3h5Q29udGFpbmVyT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXMuZ2V0UHJveHlDb250YWluZXIuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb250YWluZXJPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLnJlbmRlckNvbnRhaW5lci5hcHBseShjaGlsZE92ZXJyaWRlcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLnNob3cuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZS50aGVuKChmdW5jdGlvbihjaGlsZE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlcy5oaWRlLmFwcGx5KGNoaWxkT3ZlcnJpZGVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JVbmxvYWRPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLndhdGNoRm9yVW5sb2FkLmFwcGx5KGNoaWxkT3ZlcnJpZGVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IENPTlRFWFQuSUZSQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQcm94eVdpbmRvd092ZXJyaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZS50aGVuKChmdW5jdGlvbihjaGlsZE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXMuZ2V0UHJveHlXaW5kb3cuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuRnJhbWVPdmVycmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLm9wZW5GcmFtZS5hcHBseShjaGlsZE92ZXJyaWRlcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5QcmVyZW5kZXJGcmFtZU92ZXJyaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSBhcmdzW19rZXk4XSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZS50aGVuKChmdW5jdGlvbihjaGlsZE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXMub3BlblByZXJlbmRlckZyYW1lLmFwcGx5KGNoaWxkT3ZlcnJpZGVzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIGFyZ3NbX2tleTldID0gYXJndW1lbnRzW19rZXk5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRPdmVycmlkZXNQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKGNoaWxkT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlcy5wcmVyZW5kZXIuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIGFyZ3NbX2tleTEwXSA9IGFyZ3VtZW50c1tfa2V5MTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLm9wZW4uYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuUHJlcmVuZGVyT3ZlcnJpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMSksIF9rZXkxMSA9IDA7IF9rZXkxMSA8IF9sZW4xMTsgX2tleTExKyspIGFyZ3NbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE92ZXJyaWRlc1Byb21pc2UudGhlbigoZnVuY3Rpb24oY2hpbGRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzLm9wZW5QcmVyZW5kZXIuYXBwbHkoY2hpbGRPdmVycmlkZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkT3ZlcnJpZGVzUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGNvbnRleHQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luZG93UHJvcCA9IHByb3BzLndpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YXRjaEZvclVubG9hZFByb21pc2UgPSB3YXRjaEZvclVubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkVXJsUHJvbWlzZSA9IGZ1bmN0aW9uKHByb3BzRGVmLCBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKGtleXMubWFwKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCkgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgcHJvcC5xdWVyeVBhcmFtKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyBwcm9wc19nZXRRdWVyeVBhcmFtKHByb3AsIGtleSwgdmFsdWUpLCBnZXRRdWVyeVZhbHVlKHByb3AsIDAsIHZhbHVlKSBdKS50aGVuKChmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW0gPSBfcmVmWzBdLCBxdWVyeVZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImJvb2xlYW5cIiA9PSB0eXBlb2YgcXVlcnlWYWx1ZSkgcmVzdWx0ID0gcXVlcnlWYWx1ZS50b1N0cmluZygpOyBlbHNlIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBxdWVyeVZhbHVlKSByZXN1bHQgPSBxdWVyeVZhbHVlLnRvU3RyaW5nKCk7IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHF1ZXJ5VmFsdWUgJiYgbnVsbCAhPT0gcXVlcnlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5zZXJpYWxpemF0aW9uID09PSBQUk9QX1NFUklBTElaQVRJT04uSlNPTikgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocXVlcnlWYWx1ZSk7IGVsc2UgaWYgKHByb3Auc2VyaWFsaXphdGlvbiA9PT0gUFJPUF9TRVJJQUxJWkFUSU9OLkJBU0U2NCkgcmVzdWx0ID0gYnRvYShKU09OLnN0cmluZ2lmeShxdWVyeVZhbHVlKSk7IGVsc2UgaWYgKHByb3Auc2VyaWFsaXphdGlvbiA9PT0gUFJPUF9TRVJJQUxJWkFUSU9OLkRPVElGWSB8fCAhcHJvcC5zZXJpYWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jdGlvbiBkb3RpZnkob2JqLCBwcmVmaXgsIG5ld29iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gcHJlZml4ICYmIChwcmVmaXggPSBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG5ld29iaiAmJiAobmV3b2JqID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCA/IHByZWZpeCArIFwiLlwiIDogcHJlZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG51bGwgIT0gb2JqW2tleV0gJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvYmpba2V5XSAmJiAob2JqW2tleV0gJiYgQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgb2JqW2tleV0ubGVuZ3RoICYmIG9ialtrZXldLmV2ZXJ5KChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgPyBuZXdvYmpbXCJcIiArIHByZWZpeCArIGtleSArIFwiW11cIl0gPSBvYmpba2V5XS5qb2luKFwiLFwiKSA6IG9ialtrZXldICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG9ialtrZXldID8gbmV3b2JqID0gZG90aWZ5KG9ialtrZXldLCBcIlwiICsgcHJlZml4ICsga2V5LCBuZXdvYmopIDogbmV3b2JqW1wiXCIgKyBwcmVmaXggKyBrZXldID0gb2JqW2tleV0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld29iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0ocXVlcnlWYWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfT2JqZWN0JGtleXM4ID0gT2JqZWN0LmtleXMocmVzdWx0KTsgX2kxMiA8IF9PYmplY3Qka2V5czgubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90a2V5ID0gX09iamVjdCRrZXlzOFtfaTEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZG90a2V5XSA9IHJlc3VsdFtkb3RrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIFwibnVtYmVyXCIgPT0gdHlwZW9mIHF1ZXJ5VmFsdWUgJiYgKHJlc3VsdCA9IHF1ZXJ5VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3F1ZXJ5UGFyYW1dID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByb3BzRGVmLCBwcm9wcykudGhlbigoZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IG9wdGlvbnMucXVlcnkgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gb3B0aW9ucy5oYXNoIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdXJsJHNwbGl0ID0gdXJsLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxIYXNoID0gX3VybCRzcGxpdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vcmlnaW5hbFVybCRzcGxpdCA9IChvcmlnaW5hbFVybCA9IF91cmwkc3BsaXRbMF0pLnNwbGl0KFwiP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxVcmwgPSBfb3JpZ2luYWxVcmwkc3BsaXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IGV4dGVuZFF1ZXJ5KF9vcmlnaW5hbFVybCRzcGxpdFsxXSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaFN0cmluZyA9IGV4dGVuZFF1ZXJ5KG9yaWdpbmFsSGFzaCwgaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nICYmIChvcmlnaW5hbFVybCA9IG9yaWdpbmFsVXJsICsgXCI/XCIgKyBxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdHJpbmcgJiYgKG9yaWdpbmFsVXJsID0gb3JpZ2luYWxVcmwgKyBcIiNcIiArIGhhc2hTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZG9tYWluID0gZ2V0RG9tYWluRnJvbVVybCh1cmwpLCAwID09PSBkb21haW4uaW5kZXhPZihcIm1vY2s6XCIpKSkgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9jayB1cmxzIG5vdCBzdXBwb3J0ZWQgb3V0IG9mIHRlc3QgbW9kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGdldFVybCgpKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvblJlbmRlclByb21pc2UgPSBldmVudC50cmlnZ2VyKEVWRU5ULlJFTkRFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UHJveHlDb250YWluZXJQcm9taXNlID0gZ2V0UHJveHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRQcm94eVdpbmRvd1Byb21pc2UgPSBnZXRQcm94eVdpbmRvdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkV2luZG93TmFtZVByb21pc2UgPSBnZXRQcm94eVdpbmRvd1Byb21pc2UudGhlbigoZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oX3RlbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gdm9pZCAwID09PSBfdGVtcCA/IHt9IDogX3RlbXAsIHByb3h5V2luID0gX3JlZjQucHJveHlXaW4sIGNoaWxkRG9tYWluID0gX3JlZjQuY2hpbGREb21haW4sIGRvbWFpbiA9IF9yZWY0LmRvbWFpbiwgY29udGV4dCA9ICh2b2lkIDAgPT09IF9yZWY0LnRhcmdldCAmJiB3aW5kb3csIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNC5jb250ZXh0KSwgdWlkID0gX3JlZjQudWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJveHlXaW4sIGNoaWxkRG9tYWluLCBkb21haW4sIHVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3BzRm9yQ2hpbGQoZG9tYWluKS50aGVuKChmdW5jdGlvbihjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2V0dXBfc2VyaWFsaXplTWVzc2FnZShwcm94eVdpbiwgZG9tYWluLCBjaGlsZFByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcFJlZiA9IGNoaWxkRG9tYWluID09PSBnZXREb21haW4oKSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJhd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInVpZFwiID09PSBwcm9wUmVmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdsb2JhbCA9IGxpYl9nbG9iYWxfZ2V0R2xvYmFsKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5wcm9wcyA9IGdsb2JhbC5wcm9wcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLnByb3BzW3VpZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4ucmVnaXN0ZXIoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbC5wcm9wc1t1aWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHByb3h5V2luLCBjaGlsZERvbWFpbiwgZG9tYWluLCB1aWQpLnRoZW4oKGZ1bmN0aW9uKHByb3BzUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCI5XzBfNjNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERvbWFpbjogY2hpbGREb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RG9tYWluOiBnZXREb21haW4od2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGdldFdpbmRvd1JlZigwLCBjaGlsZERvbWFpbiwgdWlkLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogc2V0dXBfc2VyaWFsaXplTWVzc2FnZShwcm94eVdpbiwgZG9tYWluLCAod2luID0gcHJveHlXaW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogaW5pdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogY2xvc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrV2luZG93Q2xvc2Uod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiAoX3JlZjUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogcHJveHlXaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERvbWFpbjogY2hpbGREb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnByb3h5V2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERvbWFpbjogX3JlZjUuY2hpbGREb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX3JlZjUuZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IF9yZWY1LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3JlZjUuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBfcmVmNS51aWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihjaGlsZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX196b2lkX19cIiArIG5hbWUgKyBcIl9fXCIgKyBiYXNlNjRlbmNvZGUoSlNPTi5zdHJpbmdpZnkoY2hpbGRQYXlsb2FkKSkgKyBcIl9fXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuRnJhbWVQcm9taXNlID0gYnVpbGRXaW5kb3dOYW1lUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW5kb3dOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5GcmFtZShjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IHdpbmRvd05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVuUHJlcmVuZGVyRnJhbWVQcm9taXNlID0gb3BlblByZXJlbmRlckZyYW1lKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlckNvbnRhaW5lclByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUNvbnRhaW5lcjogZ2V0UHJveHlDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IG9wZW5GcmFtZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlQcmVyZW5kZXJGcmFtZTogb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckNvbnRhaW5lcihfcmVmMTIucHJveHlDb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IF9yZWYxMi5wcm94eUZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVByZXJlbmRlckZyYW1lOiBfcmVmMTIucHJveHlQcmVyZW5kZXJGcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHByb3h5Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5Qcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93TmFtZTogYnVpbGRXaW5kb3dOYW1lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUZyYW1lOiBvcGVuRnJhbWVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiBnZXRQcm94eVdpbmRvd1Byb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWYxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm94eVdpbiA9IF9yZWYxMy5wcm94eVdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93UHJvcCA/IHByb3h5V2luIDogb3Blbihjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IF9yZWYxMy53aW5kb3dOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogcHJveHlXaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5RnJhbWU6IF9yZWYxMy5wcm94eUZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlblByZXJlbmRlclByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpbjogb3BlblByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlQcmVyZW5kZXJGcmFtZTogb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjE0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5QcmVyZW5kZXIoY29udGV4dCwgX3JlZjE0LnByb3h5V2luLCBfcmVmMTQucHJveHlQcmVyZW5kZXJGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0U3RhdGVQcm9taXNlID0gb3BlblByb21pc2UudGhlbigoZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJveHlXaW4gPSBwcm94eVdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJveHlXaW4ocHJveHlXaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXJlbmRlclByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eVByZXJlbmRlcldpbjogb3BlblByZXJlbmRlclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHNldFN0YXRlUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjE1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXJlbmRlcihfcmVmMTUucHJveHlQcmVyZW5kZXJXaW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRXaW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiBvcGVuUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lOiBidWlsZFdpbmRvd05hbWVQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93UHJvcCkgcmV0dXJuIF9yZWYxNi5wcm94eVdpbi5zZXROYW1lKF9yZWYxNi53aW5kb3dOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2FkVXJsUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2luOiBvcGVuUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsdFVybDogYnVpbGRVcmxQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd05hbWU6IHNldFdpbmRvd05hbWVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcjogcHJlcmVuZGVyUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjE3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYxNy5wcm94eVdpbi5zZXRMb2NhdGlvbihfcmVmMTcuYnVpbHRVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhdGNoRm9yQ2xvc2VQcm9taXNlID0gb3BlblByb21pc2UudGhlbigoZnVuY3Rpb24ocHJveHlXaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gd2F0Y2hGb3JDbG9zZShwcm94eVdpbiwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuLnJlZ2lzdGVyKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5kZWxheSgyZTMpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5V2luLmlzQ2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihpc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQ2xvc2VkID8gY2xvc2UobmV3IEVycm9yKFwiRGV0ZWN0ZWQgXCIgKyBjb250ZXh0ICsgXCIgY2xvc2VcIikpIDogY2FuY2VsbGVkID8gdm9pZCAwIDogd2F0Y2hGb3JDbG9zZShwcm94eVdpbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHByb3h5V2luLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkRpc3BsYXlQcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiByZW5kZXJDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcjogcHJlcmVuZGVyUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRyaWdnZXIoRVZFTlQuRElTUExBWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbkJyaWRnZVByb21pc2UgPSBvcGVuUHJvbWlzZS50aGVuKChmdW5jdGlvbihwcm94eVdpbikge30pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5UaW1lb3V0UHJvbWlzZSA9IGxvYWRVcmxQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHByb3BzLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSByZXR1cm4gaW5pdFByb21pc2UudGltZW91dCh0aW1lb3V0LCBuZXcgRXJyb3IoXCJMb2FkaW5nIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCIgbWlsbGlzZWNvbmRzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25SZW5kZXJlZFByb21pc2UgPSBpbml0UHJvbWlzZS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudHJpZ2dlcihFVkVOVC5SRU5ERVJFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFByb21pc2U6IGluaXRQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkVXJsUHJvbWlzZTogYnVpbGRVcmxQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyUHJvbWlzZTogb25SZW5kZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3h5Q29udGFpbmVyUHJvbWlzZTogZ2V0UHJveHlDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5GcmFtZVByb21pc2U6IG9wZW5GcmFtZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZTogb3BlblByZXJlbmRlckZyYW1lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb250YWluZXJQcm9taXNlOiByZW5kZXJDb250YWluZXJQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9taXNlOiBvcGVuUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuUHJlcmVuZGVyUHJvbWlzZTogb3BlblByZXJlbmRlclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGVQcm9taXNlOiBzZXRTdGF0ZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyUHJvbWlzZTogcHJlcmVuZGVyUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVXJsUHJvbWlzZTogbG9hZFVybFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRXaW5kb3dOYW1lUHJvbWlzZTogYnVpbGRXaW5kb3dOYW1lUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRXaW5kb3dOYW1lUHJvbWlzZTogc2V0V2luZG93TmFtZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JDbG9zZVByb21pc2U6IHdhdGNoRm9yQ2xvc2VQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheVByb21pc2U6IG9uRGlzcGxheVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkJyaWRnZVByb21pc2U6IG9wZW5CcmlkZ2VQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1blRpbWVvdXRQcm9taXNlOiBydW5UaW1lb3V0UHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlbmRlcmVkUHJvbWlzZTogb25SZW5kZXJlZFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVQcm9taXNlOiBkZWxlZ2F0ZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JVbmxvYWRQcm9taXNlOiB3YXRjaEZvclVubG9hZFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIG9uRXJyb3IoZXJyKSwgZGVzdHJveShlcnIpIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgc2V0UHJvcHM6IHNldFByb3BzLFxuICAgICAgICAgICAgICAgIGdldEhlbHBlcnM6IGdldEhlbHBlcnMsXG4gICAgICAgICAgICAgICAgZ2V0RGVsZWdhdGVPdmVycmlkZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UHJveHlDb250YWluZXI6IGdldFByb3h5Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogaGlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb250YWluZXI6IHJlbmRlckNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQcm94eVdpbmRvdzogZ2V0UHJveHlXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hGb3JVbmxvYWQ6IHdhdGNoRm9yVW5sb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5GcmFtZTogb3BlbkZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5QcmVyZW5kZXJGcmFtZTogb3BlblByZXJlbmRlckZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXJlbmRlcjogcHJlcmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlblByZXJlbmRlcjogb3BlblByZXJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm94eVdpbjogc2V0UHJveHlXaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWFjdCA9IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YWcsIHByb3BzRGVmLCBpbml0LCBfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIFJlYWN0ID0gX3JlZi5SZWFjdCwgUmVhY3RET00gPSBfcmVmLlJlYWN0RE9NO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9pbmhlcml0c0xvb3NlKF9jbGFzcywgX1JlYWN0JENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgX3Byb3RvID0gX2NsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5pdChleHRlbmQoe30sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW5kZXIoZWwsIENPTlRFWFQuSUZSQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLnBhcmVudCAmJiB0aGlzLnN0YXRlLnBhcmVudC51cGRhdGVQcm9wcyhleHRlbmQoe30sIHRoaXMucHJvcHMpKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jbGFzcztcbiAgICAgICAgICAgICAgICB9KFJlYWN0LkNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2dWUgPSB7XG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24odGFnLCBwcm9wc0RlZiwgaW5pdCwgVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS5jb21wb25lbnQodGFnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3JlYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRBdHRyczogITEsXG4gICAgICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy4kZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IGluaXQoX2V4dGVuZHMoe30sIHRoaXMuJGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5yZW5kZXIoZWwsIENPTlRFWFQuSUZSQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLiRhdHRycyAmJiB0aGlzLnBhcmVudC51cGRhdGVQcm9wcyhfZXh0ZW5kcyh7fSwgdGhpcy4kYXR0cnMpKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXA6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFuZ3VsYXIgPSB7XG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24odGFnLCBwcm9wc0RlZiwgaW5pdCwgbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmcubW9kdWxlKHRhZywgW10pLmRpcmVjdGl2ZSh0YWcucmVwbGFjZSgvLShbYS16XSkvZywgKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KSksIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9PYmplY3Qka2V5czIgPSBPYmplY3Qua2V5cyhwcm9wc0RlZik7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykgc2NvcGVbX09iamVjdCRrZXlzMltfaTJdXSA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5wcm9wcyA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcjogWyBcIiRzY29wZVwiLCBcIiRlbGVtZW50XCIsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzYWZlQXBwbHkoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIiRhcHBseVwiICE9PSAkc2NvcGUuJHJvb3QuJCRwaGFzZSAmJiBcIiRkaWdlc3RcIiAhPT0gJHNjb3BlLiRyb290LiQkcGhhc2UpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldFByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlT2JqZWN0KCRzY29wZS5wcm9wcywgKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVBcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDogaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5pdChnZXRQcm9wcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoJGVsZW1lbnRbMF0sIENPTlRFWFQuSUZSQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlUHJvcHMoZ2V0UHJvcHMoKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgYW5ndWxhcjIgPSB7XG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24odGFnLCBwcm9wc0RlZiwgaW5pdCwgX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBOZ01vZHVsZSA9IF9yZWYuTmdNb2R1bGUsIEVsZW1lbnRSZWYgPSBfcmVmLkVsZW1lbnRSZWYsIE5nWm9uZSA9IF9yZWYuTmdab25lO1xuICAgICAgICAgICAgICAgIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZU9iamVjdChfZXh0ZW5kcyh7fSwgY29tcG9uZW50LmludGVybmFsUHJvcHMsIGNvbXBvbmVudC5wcm9wcyksIChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LnpvbmUucnVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgQ29tcG9uZW50SW5zdGFuY2UgPSAoMCwgX3JlZi5Db21wb25lbnQpKHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbIFwicHJvcHNcIiBdXG4gICAgICAgICAgICAgICAgfSkuQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogWyBFbGVtZW50UmVmLCBOZ1pvbmUsIGZ1bmN0aW9uKGVsZW1lbnRSZWYsIHpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgICAgICAgICAgICAgfSBdLFxuICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBpbml0KGdldFByb3BzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbmRlcih0YXJnZXRFbGVtZW50LCBDT05URVhULklGUkFNRSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG5nRG9DaGVjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgIWZ1bmN0aW9uKG9iajEsIG9iajIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmoxKSBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRba2V5XSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBvYmoyKSBpZiAoIWNoZWNrZWRbX2tleV0pIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHRoaXMuX3Byb3BzLCB0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZVByb3BzKGdldFByb3BzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBOZ01vZHVsZSh7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogWyBDb21wb25lbnRJbnN0YW5jZSBdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbIENvbXBvbmVudEluc3RhbmNlIF1cbiAgICAgICAgICAgICAgICB9KS5DbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXJUZW1wbGF0ZShfcmVmKSB7XG4gICAgICAgICAgICB2YXIgdWlkID0gX3JlZi51aWQsIGZyYW1lID0gX3JlZi5mcmFtZSwgcHJlcmVuZGVyRnJhbWUgPSBfcmVmLnByZXJlbmRlckZyYW1lLCBkb2MgPSBfcmVmLmRvYywgcHJvcHMgPSBfcmVmLnByb3BzLCBldmVudCA9IF9yZWYuZXZlbnQsIF9yZWYkZGltZW5zaW9ucyA9IF9yZWYuZGltZW5zaW9ucywgd2lkdGggPSBfcmVmJGRpbWVuc2lvbnMud2lkdGgsIGhlaWdodCA9IF9yZWYkZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoZnJhbWUgJiYgcHJlcmVuZGVyRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHVpZCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgICAgICBwcm9wcy5jc3BOb25jZSAmJiBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBwcm9wcy5jc3BOb25jZSk7XG4gICAgICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKFwiXFxuICAgICAgICAgICAgI1wiICsgdWlkICsgXCIge1xcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiICsgd2lkdGggKyBcIjtcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIGhlaWdodCArIFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAjXCIgKyB1aWQgKyBcIiA+IGlmcmFtZSB7XFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgICAgIGxlZnQ6IDA7XFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjJzIGVhc2UtaW4tb3V0O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAjXCIgKyB1aWQgKyBcIiA+IGlmcmFtZS56b2lkLWludmlzaWJsZSB7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICNcIiArIHVpZCArIFwiID4gaWZyYW1lLnpvaWQtdmlzaWJsZSB7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgICB9XFxuICAgICAgICBcIikpO1xuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHByZXJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lLmNsYXNzTGlzdC5hZGQoXCJ6b2lkLXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgZnJhbWUuY2xhc3NMaXN0LmFkZChcInpvaWQtaW52aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgIGV2ZW50Lm9uKEVWRU5ULlJFTkRFUkVELCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lLmNsYXNzTGlzdC5yZW1vdmUoXCJ6b2lkLXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlckZyYW1lLmNsYXNzTGlzdC5hZGQoXCJ6b2lkLWludmlzaWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuY2xhc3NMaXN0LnJlbW92ZShcInpvaWQtaW52aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5jbGFzc0xpc3QuYWRkKFwiem9pZC12aXNpYmxlXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lFbGVtZW50KHByZXJlbmRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIDEpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBldmVudC5vbihFVkVOVC5SRVNJWkUsIChmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBfcmVmMi53aWR0aCwgbmV3SGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclwiID09IHR5cGVvZiBuZXdXaWR0aCAmJiAoZGl2LnN0eWxlLndpZHRoID0gdG9DU1MobmV3V2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgbmV3SGVpZ2h0ICYmIChkaXYuc3R5bGUuaGVpZ2h0ID0gdG9DU1MobmV3SGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFByZXJlbmRlclRlbXBsYXRlKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBfcmVmLmRvYywgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgICAgICB2YXIgc3Bpbm5lciA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgc3Bpbm5lci5jbGFzc0xpc3QuYWRkKFwic3Bpbm5lclwiKTtcbiAgICAgICAgICAgIHByb3BzLmNzcE5vbmNlICYmIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHByb3BzLmNzcE5vbmNlKTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoYm9keSk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKHNwaW5uZXIpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXCJcXG4gICAgICAgICAgICBodG1sLCBib2R5IHtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLnNwaW5uZXIge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgICAgICAgICAgIG1heC1oZWlnaHQ6IDYwdm1pbjtcXG4gICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA2MHZtaW47XFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDBweDtcXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQwcHg7XFxuICAgICAgICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICAgICAgICBsZWZ0OiA1MCU7XFxuICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHJnYmEoMCwgMCwgMCwgLjIpO1xcbiAgICAgICAgICAgICAgICBib3JkZXItdG9wLWNvbG9yOiByZ2JhKDMzLCAxMjgsIDE5MiwgMC44KTtcXG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiByb3RhdGlvbiAuN3MgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBAa2V5ZnJhbWVzIHJvdGF0aW9uIHtcXG4gICAgICAgICAgICAgICAgZnJvbSB7XFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdG8ge1xcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDM1OWRlZyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICBcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzX2RlZmF1bHROb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjX3V0aWxfbm9vcDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb3BzX2RlY29yYXRlT25jZSA9IGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBvbmNlKF9yZWYudmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xlYW5JbnN0YW5jZXMgPSBjbGVhbnVwKCk7XG4gICAgICAgIHZhciBjbGVhblpvaWQgPSBjbGVhbnVwKCk7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvbmVudF9jb21wb25lbnQob3B0cykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMudGFnLCB1cmwgPSBvcHRpb25zLnVybCwgZG9tYWluID0gb3B0aW9ucy5kb21haW4sIGJyaWRnZVVybCA9IG9wdGlvbnMuYnJpZGdlVXJsLCBfb3B0aW9ucyRwcm9wcyA9IG9wdGlvbnMucHJvcHMsIHByb3BzRGVmID0gdm9pZCAwID09PSBfb3B0aW9ucyRwcm9wcyA/IHt9IDogX29wdGlvbnMkcHJvcHMsIF9vcHRpb25zJGRpbWVuc2lvbnMgPSBvcHRpb25zLmRpbWVuc2lvbnMsIGRpbWVuc2lvbnMgPSB2b2lkIDAgPT09IF9vcHRpb25zJGRpbWVuc2lvbnMgPyB7fSA6IF9vcHRpb25zJGRpbWVuc2lvbnMsIF9vcHRpb25zJGF1dG9SZXNpemUgPSBvcHRpb25zLmF1dG9SZXNpemUsIGF1dG9SZXNpemUgPSB2b2lkIDAgPT09IF9vcHRpb25zJGF1dG9SZXNpemUgPyB7fSA6IF9vcHRpb25zJGF1dG9SZXNpemUsIF9vcHRpb25zJGFsbG93ZWRQYXJlbiA9IG9wdGlvbnMuYWxsb3dlZFBhcmVudERvbWFpbnMsIGFsbG93ZWRQYXJlbnREb21haW5zID0gdm9pZCAwID09PSBfb3B0aW9ucyRhbGxvd2VkUGFyZW4gPyBcIipcIiA6IF9vcHRpb25zJGFsbG93ZWRQYXJlbiwgX29wdGlvbnMkYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcywgYXR0cmlidXRlcyA9IHZvaWQgMCA9PT0gX29wdGlvbnMkYXR0cmlidXRlcyA/IHt9IDogX29wdGlvbnMkYXR0cmlidXRlcywgX29wdGlvbnMkZGVmYXVsdENvbnRlID0gb3B0aW9ucy5kZWZhdWx0Q29udGV4dCwgZGVmYXVsdENvbnRleHQgPSB2b2lkIDAgPT09IF9vcHRpb25zJGRlZmF1bHRDb250ZSA/IENPTlRFWFQuSUZSQU1FIDogX29wdGlvbnMkZGVmYXVsdENvbnRlLCBfb3B0aW9ucyRjb250YWluZXJUZW0gPSBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlLCBjb250YWluZXJUZW1wbGF0ZSA9IHZvaWQgMCA9PT0gX29wdGlvbnMkY29udGFpbmVyVGVtID8gZGVmYXVsdENvbnRhaW5lclRlbXBsYXRlIDogX29wdGlvbnMkY29udGFpbmVyVGVtLCBfb3B0aW9ucyRwcmVyZW5kZXJUZW0gPSBvcHRpb25zLnByZXJlbmRlclRlbXBsYXRlLCBwcmVyZW5kZXJUZW1wbGF0ZSA9IHZvaWQgMCA9PT0gX29wdGlvbnMkcHJlcmVuZGVyVGVtID8gZGVmYXVsdFByZXJlbmRlclRlbXBsYXRlIDogX29wdGlvbnMkcHJlcmVuZGVyVGVtLCB2YWxpZGF0ZSA9IG9wdGlvbnMudmFsaWRhdGUsIF9vcHRpb25zJGVsaWdpYmxlID0gb3B0aW9ucy5lbGlnaWJsZSwgZWxpZ2libGUgPSB2b2lkIDAgPT09IF9vcHRpb25zJGVsaWdpYmxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGlnaWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IDogX29wdGlvbnMkZWxpZ2libGUsIF9vcHRpb25zJGxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyLCBsb2dnZXIgPSB2b2lkIDAgPT09IF9vcHRpb25zJGxvZ2dlciA/IHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbzogc3JjX3V0aWxfbm9vcFxuICAgICAgICAgICAgICAgIH0gOiBfb3B0aW9ucyRsb2dnZXI7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0YWcucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgdmFyIF9kaW1lbnNpb25zJHdpZHRoID0gZGltZW5zaW9ucy53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9kaW1lbnNpb25zJHdpZHRoID8gXCIzMDBweFwiIDogX2RpbWVuc2lvbnMkd2lkdGgsIF9kaW1lbnNpb25zJGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9kaW1lbnNpb25zJGhlaWdodCA/IFwiMTUwcHhcIiA6IF9kaW1lbnNpb25zJGhlaWdodDtcbiAgICAgICAgICAgICAgICBwcm9wc0RlZiA9IF9leHRlbmRzKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93RGVsZWdhdGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1dpbmRvdyh2YWx1ZSkgJiYgIXdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgV2luZG93IG9yIFByb3h5V2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvdyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVEb21haW4odmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgbm90IHNhbWUgZG9tYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBfdG9Qcm94eVdpbmRvdyhfcmVmMy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRGVjb3JhdGU6IGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmNsb3NlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjUuZm9jdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjYucmVzaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERlY29yYXRlOiBmdW5jdGlvbihfcmVmNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy51aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNzcE5vbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFBhcmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjguZ2V0UGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRQYXJlbnREb21haW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRGVjb3JhdGU6IGZ1bmN0aW9uKF9yZWY5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY5LmdldFBhcmVudERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGREZWNvcmF0ZTogZnVuY3Rpb24oX3JlZjEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYxMC5zaG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERlY29yYXRlOiBmdW5jdGlvbihfcmVmMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjExLmhpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dEZWxlZ2F0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlOiBwcm9wc19kZWNvcmF0ZU9uY2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZW5kZXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcHJvcHNfZGVmYXVsdE5vb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0ZTogcHJvcHNfZGVjb3JhdGVPbmNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlOiBwcm9wc19kZWNvcmF0ZU9uY2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dEZWxlZ2F0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRlOiBwcm9wc19kZWNvcmF0ZU9uY2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZXN0cm95OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0RlbGVnYXRlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHByb3BzX2RlZmF1bHROb29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb3JhdGU6IHByb3BzX2RlY29yYXRlT25jZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblJlc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dEZWxlZ2F0ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBwcm9wc19kZWZhdWx0Tm9vcFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0RlbGVnYXRlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHByb3BzX2RlZmF1bHROb29wXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkRGVjb3JhdGU6IGZ1bmN0aW9uKF9yZWYxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMTIub25FcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcHJvcHNfZGVmYXVsdE5vb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZERlY29yYXRlOiBmdW5jdGlvbihfcmVmMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjEzLm9uUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBwcm9wc0RlZik7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJUZW1wbGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIHRlbXBsYXRlIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZVVybDogYnJpZGdlVXJsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wc0RlZjogcHJvcHNEZWYsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF1dG9SZXNpemU6IGF1dG9SZXNpemUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRQYXJlbnREb21haW5zOiBhbGxvd2VkUGFyZW50RG9tYWlucyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENvbnRleHQ6IGRlZmF1bHRDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJUZW1wbGF0ZTogY29udGFpbmVyVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgIHByZXJlbmRlclRlbXBsYXRlOiBwcmVyZW5kZXJUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IGxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgZWxpZ2libGU6IGVsaWdpYmxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0ob3B0cyk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSwgdGFnID0gb3B0aW9ucy50YWcsIGRlZmF1bHRDb250ZXh0ID0gb3B0aW9ucy5kZWZhdWx0Q29udGV4dCwgcHJvcHNEZWYgPSBvcHRpb25zLnByb3BzRGVmLCBlbGlnaWJsZSA9IG9wdGlvbnMuZWxpZ2libGU7XG4gICAgICAgICAgICB2YXIgZ2xvYmFsID0gbGliX2dsb2JhbF9nZXRHbG9iYWwoKTtcbiAgICAgICAgICAgIHZhciBkcml2ZXJDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGlzQ2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGdldENoaWxkUGF5bG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHBheWxvYWQgJiYgcGF5bG9hZC50YWcgPT09IHRhZyAmJiBwYXlsb2FkLmNoaWxkRG9tYWluID09PSBnZXREb21haW4oKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyQ2hpbGQgPSBtZW1vaXplKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cueHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsLmNvbXBvbmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVnaXN0ZXIgXCIgKyBuYW1lICsgXCIgYXMgY2hpbGQgLSBjaGlsZCBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzRGVmID0gb3B0aW9ucy5wcm9wc0RlZiwgYXV0b1Jlc2l6ZSA9IG9wdGlvbnMuYXV0b1Jlc2l6ZSwgYWxsb3dlZFBhcmVudERvbWFpbnMgPSBvcHRpb25zLmFsbG93ZWRQYXJlbnREb21haW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uUHJvcEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQYXlsb2FkID0gZ2V0Q2hpbGRQYXlsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkUGF5bG9hZCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hpbGQgcGF5bG9hZCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIjlfMF82M1wiICE9PSBjaGlsZFBheWxvYWQudmVyc2lvbikgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IHdpbmRvdyBoYXMgem9pZCB2ZXJzaW9uIFwiICsgY2hpbGRQYXlsb2FkLnZlcnNpb24gKyBcIiwgY2hpbGQgd2luZG93IGhhcyB2ZXJzaW9uIDlfMF82M1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSBjaGlsZFBheWxvYWQudWlkLCBwYXJlbnREb21haW4gPSBjaGlsZFBheWxvYWQucGFyZW50RG9tYWluLCBleHBvcnRzID0gY2hpbGRQYXlsb2FkLmV4cG9ydHMsIGNvbnRleHQgPSBjaGlsZFBheWxvYWQuY29udGV4dCwgcHJvcHNSZWYgPSBjaGlsZFBheWxvYWQucHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29tcG9uZW50V2luZG93ID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvcGVuZXJcIiA9PT0gdHlwZSkgcmV0dXJuIGFzc2VydEV4aXN0cyhcIm9wZW5lclwiLCBnZXRPcGVuZXIod2luZG93KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicGFyZW50XCIgPT09IHR5cGUgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgcmVmLmRpc3RhbmNlKSByZXR1cm4gYXNzZXJ0RXhpc3RzKFwicGFyZW50XCIsIGZ1bmN0aW9uKHdpbiwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG4gJiYgKG4gPSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHdpbiwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBuICYmIChuID0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gd2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHV0aWxzX2dldFBhcmVudChwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGdldERpc3RhbmNlRnJvbVRvcCh3aW4pIC0gbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW5kb3csIHJlZi5kaXN0YW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImdsb2JhbFwiID09PSB0eXBlICYmIHJlZi51aWQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgcmVmLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gcmVmLnVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gZ2V0QW5jZXN0b3Iod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmNlc3RvcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGFuY2VzdG9yIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2dldEFsbEZyYW1lc0luV2luZG93MiA9IGdldEFsbEZyYW1lc0luV2luZG93KGFuY2VzdG9yKTsgX2kyIDwgX2dldEFsbEZyYW1lc0luV2luZG93Mi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZ2V0QWxsRnJhbWVzSW5XaW5kb3cyW19pMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKGZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbG9iYWwgPSBsaWJfZ2xvYmFsX2dldEdsb2JhbChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbCAmJiBnbG9iYWwud2luZG93cyAmJiBnbG9iYWwud2luZG93c1t1aWRdKSByZXR1cm4gZ2xvYmFsLndpbmRvd3NbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBcIiArIHR5cGUgKyBcIiBwYXJlbnQgY29tcG9uZW50IHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oY2hpbGRQYXlsb2FkLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gc2V0dXBfZGVzZXJpYWxpemVNZXNzYWdlKHBhcmVudENvbXBvbmVudFdpbmRvdywgcGFyZW50RG9tYWluLCBleHBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG93ID0gcGFyZW50LnNob3csIGhpZGUgPSBwYXJlbnQuaGlkZSwgY2xvc2UgPSBwYXJlbnQuY2xvc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudFdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0UGFyZW50RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Qcm9wcyA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblByb3BIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm9uRXJyb3IpIHJldHVybiBwYXJlbnQub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNpemUgPSBmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQucmVzaXplLmZpcmVBbmRGb3JnZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3JlZjIud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3JlZjIuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldFByb3BzID0gZnVuY3Rpb24obmV3UHJvcHMsIG9yaWdpbiwgaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGlzVXBkYXRlICYmIChpc1VwZGF0ZSA9ICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFByb3BzID0gZnVuY3Rpb24ocGFyZW50Q29tcG9uZW50V2luZG93LCBwcm9wc0RlZiwgcHJvcHMsIG9yaWdpbiwgaGVscGVycywgaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBpc1VwZGF0ZSAmJiAoaXNVcGRhdGUgPSAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kyIDwgX09iamVjdCRrZXlzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzMltfaTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc0RlZltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wIHx8ICFwcm9wLnNhbWVEb21haW4gfHwgb3JpZ2luID09PSBnZXREb21haW4od2luZG93KSAmJiBpc1NhbWVEb21haW4ocGFyZW50Q29tcG9uZW50V2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZUNoaWxkUHJvcChwcm9wc0RlZiwgMCwga2V5LCBwcm9wc1trZXldLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgJiYgcHJvcC5hbGlhcyAmJiAhcmVzdWx0W3Byb3AuYWxpYXNdICYmIChyZXN1bHRbcHJvcC5hbGlhc10gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VwZGF0ZSkgZm9yICh2YXIgX2k0ID0gMCwgX09iamVjdCRrZXlzNCA9IE9iamVjdC5rZXlzKHByb3BzRGVmKTsgX2k0IDwgX09iamVjdCRrZXlzNC5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2tleSA9IF9PYmplY3Qka2V5czRbX2k0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KF9rZXkpIHx8IChyZXN1bHRbX2tleV0gPSBub3JtYWxpemVDaGlsZFByb3AocHJvcHNEZWYsIDAsIF9rZXksIHZvaWQgMCwgaGVscGVycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShwYXJlbnRDb21wb25lbnRXaW5kb3csIHByb3BzRGVmLCBuZXdQcm9wcywgb3JpZ2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGNoaWxkX2ZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemU6IHJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9wczogb25Qcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UGFyZW50OiBnZXRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFBhcmVudERvbWFpbjogZ2V0UGFyZW50RG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlzVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA/IGV4dGVuZChwcm9wcywgbm9ybWFsaXplZFByb3BzKSA6IHByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG9uUHJvcEhhbmRsZXJzLmxlbmd0aDsgX2k0KyspICgwLCBvblByb3BIYW5kbGVyc1tfaTRdKShwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVByb3BzID0gZnVuY3Rpb24obmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFByb3BzKG5ld1Byb3BzLCBwYXJlbnREb21haW4sICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oYWxsb3dlZFBhcmVudERvbWFpbnMsIGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oYWxsb3dlZFBhcmVudERvbWFpbnMsIGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYmUgcmVuZGVyZWQgYnkgZG9tYWluOiBcIiArIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGFsbG93ZWRQYXJlbnREb21haW5zLCBwYXJlbnREb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya1dpbmRvd0tub3duKHBhcmVudENvbXBvbmVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hlY2tDbG9zZS5maXJlQW5kRm9yZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoZWNrQ2xvc2UuZmlyZUFuZEZvcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlV2luZG93KHBhcmVudENvbXBvbmVudFdpbmRvdywgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZF9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pbml0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogdXBkYXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGNoaWxkX2Rlc3Ryb3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hdXRvUmVzaXplJHdpZHRoID0gYXV0b1Jlc2l6ZS53aWR0aCwgd2lkdGggPSB2b2lkIDAgIT09IF9hdXRvUmVzaXplJHdpZHRoICYmIF9hdXRvUmVzaXplJHdpZHRoLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdXRvUmVzaXplJGhlaWdodCA9IGF1dG9SZXNpemUuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgIT09IF9hdXRvUmVzaXplJGhlaWdodCAmJiBfYXV0b1Jlc2l6ZSRoZWlnaHQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2F1dG9SZXNpemUkZWxlbWVudCA9IGF1dG9SZXNpemUuZWxlbWVudCwgZWxlbWVudFJlYWR5KHZvaWQgMCA9PT0gX2F1dG9SZXNpemUkZWxlbWVudCA/IFwiYm9keVwiIDogX2F1dG9SZXNpemUkZWxlbWVudCkuY2F0Y2goc3JjX3V0aWxfbm9vcCkudGhlbigoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKS50aGVuKChmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9yZWYzLndpZHRoLCBoZWlnaHQgPSBfcmVmMy5oZWlnaHQsIGVsZW1lbnQgPSBfcmVmMy5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgJiYgKHdpZHRoIHx8IGhlaWdodCkgJiYgY29udGV4dCAhPT0gQ09OVEVYVC5QT1BVUCAmJiBvblJlc2l6ZShlbGVtZW50LCAoZnVuY3Rpb24oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCA/IF9yZWY0LndpZHRoIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBfcmVmNC5oZWlnaHQgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hdXRvUmVzaXplJHdpZHRoLCB3aWR0aCwgX2F1dG9SZXNpemUkaGVpZ2h0LCBoZWlnaHQsIF9hdXRvUmVzaXplJGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzKSByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3BzKGZ1bmN0aW9uKHBhcmVudENvbXBvbmVudFdpbmRvdywgZG9tYWluLCBfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9yZWYudHlwZSwgdWlkID0gX3JlZi51aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJyYXdcIiA9PT0gdHlwZSkgcHJvcHMgPSBfcmVmLnZhbHVlOyBlbHNlIGlmIChcInVpZFwiID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NhbWVEb21haW4ocGFyZW50Q29tcG9uZW50V2luZG93KSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGNvbXBvbmVudCB3aW5kb3cgaXMgb24gYSBkaWZmZXJlbnQgZG9tYWluIC0gZXhwZWN0ZWQgXCIgKyBnZXREb21haW4oKSArIFwiIC0gY2FuIG5vdCByZXRyaWV2ZSBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsID0gbGliX2dsb2JhbF9nZXRHbG9iYWwocGFyZW50Q29tcG9uZW50V2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IGFzc2VydEV4aXN0cyhcInByb3BzXCIsIGdsb2JhbCAmJiBnbG9iYWwucHJvcHNbdWlkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BzKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2UocGFyZW50Q29tcG9uZW50V2luZG93LCBkb21haW4sIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShwYXJlbnRDb21wb25lbnRXaW5kb3csIHBhcmVudERvbWFpbiwgcHJvcHNSZWYpLCBwYXJlbnREb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KHByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZhciBfZWxpZ2libGUgPSBlbGlnaWJsZSh7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyA9IHByb3BzIHx8IHt9XG4gICAgICAgICAgICAgICAgfSksIGVsaWdpYmlsaXR5ID0gX2VsaWdpYmxlLmVsaWdpYmxlLCByZWFzb24gPSBfZWxpZ2libGUucmVhc29uO1xuICAgICAgICAgICAgICAgIHZhciBvbkRlc3Ryb3kgPSBwcm9wcy5vbkRlc3Ryb3k7XG4gICAgICAgICAgICAgICAgcHJvcHMub25EZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlICYmIGVsaWdpYmlsaXR5ICYmIGluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VzLmluZGV4T2YoaW5zdGFuY2UpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVzdHJveSkgcmV0dXJuIG9uRGVzdHJveS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50Q29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbml0KCk7XG4gICAgICAgICAgICAgICAgZWxpZ2liaWxpdHkgPyBwYXJlbnQuc2V0UHJvcHMocHJvcHMpIDogcHJvcHMub25EZXN0cm95ICYmIHByb3BzLm9uRGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGNsZWFuSW5zdGFuY2VzLnJlZ2lzdGVyKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmRlc3Ryb3koZXJyIHx8IG5ldyBFcnJvcihcInpvaWQgZGVzdHJveWVkIGFsbCBjb21wb25lbnRzXCIpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIF9yZW5kZXIgPSBmdW5jdGlvbih0YXJnZXQsIGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWxpZ2liaWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHJlYXNvbiB8fCBuYW1lICsgXCIgY29tcG9uZW50IGlzIG5vdCBlbGlnaWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmRlc3Ryb3koZXJyKS50aGVuKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3codGFyZ2V0KSkgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIHdpbmRvdyB0byByZW5kZXJUb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMud2luZG93KSByZXR1cm4gc2V0dXBfdG9Qcm94eVdpbmRvdyhwcm9wcy53aW5kb3cpLmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSBDT05URVhULklGUkFNRSAmJiBjb250ZXh0ICE9PSBDT05URVhULlBPUFVQKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgY29udGV4dDogXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKGZpbmFsQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gZnVuY3Rpb24oY29udGV4dCwgY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgY29udGFpbmVyICYmICFpc0VsZW1lbnQoY29udGFpbmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBvciBlbGVtZW50IHNlbGVjdG9yIHRvIGJlIHBhc3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IENPTlRFWFQuUE9QVVApIHJldHVybiBcImJvZHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGJlIHBhc3NlZCB0byByZW5kZXIgaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShmaW5hbENvbnRleHQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LnJlbmRlcih0YXJnZXQsIGNvbnRhaW5lciwgZmluYWxDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZGVzdHJveShlcnIpLnRoZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBfZXh0ZW5kcyh7fSwgcGFyZW50LmdldEhlbHBlcnMoKSwge1xuICAgICAgICAgICAgICAgICAgICBpc0VsaWdpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGlnaWJpbGl0eTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKF90ZW1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjMkZGVjb3JhdGUgPSAodm9pZCAwID09PSBfdGVtcCA/IHt9IDogX3RlbXApLmRlY29yYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXQoKHZvaWQgMCA9PT0gX3JlZjMkZGVjb3JhdGUgPyBpZGVudGl0eSA6IF9yZWYzJGRlY29yYXRlKShwcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZW5kZXIod2luZG93LCBjb250YWluZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUbzogZnVuY3Rpb24odGFyZ2V0LCBjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVuZGVyKHRhcmdldCwgY29udGFpbmVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsaWdpYmlsaXR5ICYmIGluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVnaXN0ZXJDaGlsZCgpO1xuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGxvd0RlbGVnYXRlTGlzdGVuZXIgPSBvbl9vbihcInpvaWRfYWxsb3dfZGVsZWdhdGVfXCIgKyBuYW1lLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlTGlzdGVuZXIgPSBvbl9vbihcInpvaWRfZGVsZWdhdGVfXCIgKyBuYW1lLCAoZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRDb21wb25lbnQob3B0aW9ucywgX3JlZi5kYXRhLm92ZXJyaWRlcywgX3JlZi5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNsZWFuWm9pZC5yZWdpc3RlcihhbGxvd0RlbGVnYXRlTGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICBjbGVhblpvaWQucmVnaXN0ZXIoZGVsZWdhdGVMaXN0ZW5lci5jYW5jZWwpO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgZ2xvYmFsLmNvbXBvbmVudHMgPSBnbG9iYWwuY29tcG9uZW50cyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChnbG9iYWwuY29tcG9uZW50c1t0YWddKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSB0YWc6IFwiICsgdGFnKTtcbiAgICAgICAgICAgIGdsb2JhbC5jb21wb25lbnRzW3RhZ10gPSAhMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBkcml2ZXI6IGZ1bmN0aW9uKGRyaXZlck5hbWUsIGRlcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0OiByZWFjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXI6IGFuZ3VsYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2dWU6IHZ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIyOiBhbmd1bGFyMlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRyaXZlcnNbZHJpdmVyTmFtZV0pIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGRyaXZlciBmb3IgZnJhbWV3b3JrOiBcIiArIGRyaXZlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBkcml2ZXJDYWNoZVtkcml2ZXJOYW1lXSB8fCAoZHJpdmVyQ2FjaGVbZHJpdmVyTmFtZV0gPSBkcml2ZXJzW2RyaXZlck5hbWVdLnJlZ2lzdGVyKHRhZywgcHJvcHNEZWYsIGluaXQsIGRlcCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHJpdmVyQ2FjaGVbZHJpdmVyTmFtZV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc0NoaWxkOiBpc0NoaWxkLFxuICAgICAgICAgICAgICAgIGNhblJlbmRlclRvOiBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZCh3aW4sIFwiem9pZF9hbGxvd19kZWxlZ2F0ZV9cIiArIG5hbWUpLnRoZW4oKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjIuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJDaGlsZDogcmVnaXN0ZXJDaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbF9nZXRHbG9iYWwoKS5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBvbiA9IChfcmVmMyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KS5vbiwgc2VuZCA9IF9yZWYzLnNlbmQsIChnbG9iYWwgPSBnbG9iYWxfZ2V0R2xvYmFsKCkpLnJlY2VpdmVNZXNzYWdlID0gZ2xvYmFsLnJlY2VpdmVNZXNzYWdlIHx8IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjUub24sIHNlbmQgPSBfcmVmNS5zZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoKS5nZXRPclNldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIiwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgXCJtZXNzYWdlXCIsIChmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZXZlbnQsIF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNC5vbiwgc2VuZCA9IF9yZWY0LnNlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuc291cmNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZXZlbnQub3JpZ2luIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibnVsbFwiID09PSBvcmlnaW4gJiYgKG9yaWdpbiA9IFwiZmlsZTovL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgZGlkIG5vdCBoYXZlIG9yaWdpbiBkb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZXZlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmOC5vbiwgc2VuZCA9IF9yZWY4LnNlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJoZWxsb0xpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBvbihcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZShfcmVmMy5zb3VyY2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX3JlZjMub3JpZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogZ2V0SW5zdGFuY2VJRCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRBbmNlc3RvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiBzYXlIZWxsbyhwYXJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChmdW5jdGlvbihlcnIpIHt9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYzLCBvbiwgc2VuZCwgZ2xvYmFsO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRfY29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLmluaXQocHJvcHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuZHJpdmVyID0gZnVuY3Rpb24obmFtZSwgZGVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAuZHJpdmVyKG5hbWUsIGRlcCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5pdC5pc0NoaWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAuaXNDaGlsZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuY2FuUmVuZGVyVG8gPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5jYW5SZW5kZXJUbyh3aW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuaW5zdGFuY2VzID0gY29tcC5pbnN0YW5jZXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjb21wLnJlZ2lzdGVyQ2hpbGQoKTtcbiAgICAgICAgICAgIGNoaWxkICYmICh3aW5kb3cueHByb3BzID0gaW5pdC54cHJvcHMgPSBjaGlsZC5nZXRQcm9wcygpKTtcbiAgICAgICAgICAgIHJldHVybiBpbml0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3lDb21wb25lbnRzKGVycikge1xuICAgICAgICAgICAgdmFyIGRlc3Ryb3lQcm9taXNlID0gY2xlYW5JbnN0YW5jZXMuYWxsKGVycik7XG4gICAgICAgICAgICBjbGVhbkluc3RhbmNlcyA9IGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJldHVybiBkZXN0cm95UHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzdHJveUFsbCA9IGRlc3Ryb3lDb21wb25lbnRzO1xuICAgICAgICBmdW5jdGlvbiBjb21wb25lbnRfZGVzdHJveShlcnIpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lBbGwoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuX196b2lkXzlfMF82M19fO1xuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXJzID0gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMiA9IHJlc3BvbnNlTGlzdGVuZXJzLmtleXMoKTsgX2kyIDwgX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IF9yZXNwb25zZUxpc3RlbmVycyRrZTJbX2kyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHJlc3BvbnNlTGlzdGVuZXJzLmdldChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyICYmIChsaXN0ZW5lci5jYW5jZWxsZWQgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVycy5kZWwoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgKGxpc3RlbmVyID0gZ2xvYmFsU3RvcmUoKS5nZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIpKSAmJiBsaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5fX3Bvc3Rfcm9ib3RfMTBfMF80Ml9fO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFuWm9pZC5hbGwoZXJyKTtcbiAgICAgICAgfVxuICAgIH0gXSk7XG59KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/zoid/dist/zoid.frameworks.frame.js\n");

/***/ })

};
;